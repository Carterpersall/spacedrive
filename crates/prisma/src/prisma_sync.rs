// Code generated by SD Sync Generator. DO NOT EDIT

use crate::prisma;
pub enum ModelSyncData {
	Location(location::SyncId, sd_sync::SharedOperationData),
	FilePath(file_path::SyncId, sd_sync::SharedOperationData),
	Object(object::SyncId, sd_sync::SharedOperationData),
	Tag(tag::SyncId, sd_sync::SharedOperationData),
	Preference(preference::SyncId, sd_sync::SharedOperationData),
}
impl ModelSyncData {
	pub fn from_op(op: sd_sync::CRDTOperationType) -> Option<Self> {
		Some(match op {
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::location::NAME => {
				Self::Location(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::file_path::NAME => {
				Self::FilePath(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::object::NAME => {
				Self::Object(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::tag::NAME => {
				Self::Tag(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::preference::NAME => {
				Self::Preference(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			_ => return None,
		})
	}
}
pub mod shared_operation {
	use super::prisma::*;
	impl shared_operation::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				shared_operation::id::NAME => {
					shared_operation::id::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::timestamp::NAME => {
					shared_operation::timestamp::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::model::NAME => {
					shared_operation::model::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::record_id::NAME => {
					shared_operation::record_id::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::kind::NAME => {
					shared_operation::kind::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::data::NAME => {
					shared_operation::data::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::instance::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					shared_operation::instance::connect(
						instance::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
	impl shared_operation::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				shared_operation::id::NAME => {
					shared_operation::id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod node {
	use super::prisma::*;
	impl node::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				node::id::NAME => node::id::set(::serde_json::from_value(val).unwrap()),
				node::pub_id::NAME => node::pub_id::set(::serde_json::from_value(val).unwrap()),
				node::name::NAME => node::name::set(::serde_json::from_value(val).unwrap()),
				node::platform::NAME => node::platform::set(::serde_json::from_value(val).unwrap()),
				node::date_created::NAME => {
					node::date_created::set(::serde_json::from_value(val).unwrap())
				}
				node::identity::NAME => node::identity::set(::serde_json::from_value(val).unwrap()),
				node::node_peer_id::NAME => {
					node::node_peer_id::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl node::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				node::id::NAME => node::id::equals(::serde_json::from_value(val).unwrap()),
				node::pub_id::NAME => node::pub_id::equals(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
}
pub mod instance {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub id: i32,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = instance::Types;
	}
	impl sd_sync::SyncType for instance::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::LocalSyncType;
	}
	impl instance::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				instance::id::NAME => instance::id::set(::serde_json::from_value(val).unwrap()),
				instance::pub_id::NAME => {
					instance::pub_id::set(::serde_json::from_value(val).unwrap())
				}
				instance::identity::NAME => {
					instance::identity::set(::serde_json::from_value(val).unwrap())
				}
				instance::node_id::NAME => {
					instance::node_id::set(::serde_json::from_value(val).unwrap())
				}
				instance::node_name::NAME => {
					instance::node_name::set(::serde_json::from_value(val).unwrap())
				}
				instance::node_platform::NAME => {
					instance::node_platform::set(::serde_json::from_value(val).unwrap())
				}
				instance::last_seen::NAME => {
					instance::last_seen::set(::serde_json::from_value(val).unwrap())
				}
				instance::date_created::NAME => {
					instance::date_created::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl instance::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				instance::id::NAME => instance::id::equals(::serde_json::from_value(val).unwrap()),
				instance::pub_id::NAME => {
					instance::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod statistics {
	use super::prisma::*;
	impl statistics::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				statistics::id::NAME => statistics::id::set(::serde_json::from_value(val).unwrap()),
				statistics::date_captured::NAME => {
					statistics::date_captured::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_object_count::NAME => {
					statistics::total_object_count::set(::serde_json::from_value(val).unwrap())
				}
				statistics::library_db_size::NAME => {
					statistics::library_db_size::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_bytes_used::NAME => {
					statistics::total_bytes_used::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_bytes_capacity::NAME => {
					statistics::total_bytes_capacity::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_unique_bytes::NAME => {
					statistics::total_unique_bytes::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_bytes_free::NAME => {
					statistics::total_bytes_free::set(::serde_json::from_value(val).unwrap())
				}
				statistics::preview_media_bytes::NAME => {
					statistics::preview_media_bytes::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl statistics::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				statistics::id::NAME => {
					statistics::id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod volume {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub id: i32,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = volume::Types;
	}
	impl sd_sync::SyncType for volume::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::LocalSyncType;
	}
	impl volume::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				volume::id::NAME => volume::id::set(::serde_json::from_value(val).unwrap()),
				volume::name::NAME => volume::name::set(::serde_json::from_value(val).unwrap()),
				volume::mount_point::NAME => {
					volume::mount_point::set(::serde_json::from_value(val).unwrap())
				}
				volume::total_bytes_capacity::NAME => {
					volume::total_bytes_capacity::set(::serde_json::from_value(val).unwrap())
				}
				volume::total_bytes_available::NAME => {
					volume::total_bytes_available::set(::serde_json::from_value(val).unwrap())
				}
				volume::disk_type::NAME => {
					volume::disk_type::set(::serde_json::from_value(val).unwrap())
				}
				volume::filesystem::NAME => {
					volume::filesystem::set(::serde_json::from_value(val).unwrap())
				}
				volume::is_system::NAME => {
					volume::is_system::set(::serde_json::from_value(val).unwrap())
				}
				volume::date_modified::NAME => {
					volume::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl volume::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				volume::id::NAME => volume::id::equals(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
}
pub mod location {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = location::Types;
	}
	impl sd_sync::SyncType for location::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl location::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				location::id::NAME => location::id::set(::serde_json::from_value(val).unwrap()),
				location::pub_id::NAME => {
					location::pub_id::set(::serde_json::from_value(val).unwrap())
				}
				location::name::NAME => location::name::set(::serde_json::from_value(val).unwrap()),
				location::path::NAME => location::path::set(::serde_json::from_value(val).unwrap()),
				location::total_capacity::NAME => {
					location::total_capacity::set(::serde_json::from_value(val).unwrap())
				}
				location::available_capacity::NAME => {
					location::available_capacity::set(::serde_json::from_value(val).unwrap())
				}
				location::is_archived::NAME => {
					location::is_archived::set(::serde_json::from_value(val).unwrap())
				}
				location::generate_preview_media::NAME => {
					location::generate_preview_media::set(::serde_json::from_value(val).unwrap())
				}
				location::sync_preview_media::NAME => {
					location::sync_preview_media::set(::serde_json::from_value(val).unwrap())
				}
				location::hidden::NAME => {
					location::hidden::set(::serde_json::from_value(val).unwrap())
				}
				location::date_created::NAME => {
					location::date_created::set(::serde_json::from_value(val).unwrap())
				}
				location::instance_id::NAME => {
					location::instance_id::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl location::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				location::id::NAME => location::id::equals(::serde_json::from_value(val).unwrap()),
				location::pub_id::NAME => {
					location::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod file_path {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = file_path::Types;
	}
	impl sd_sync::SyncType for file_path::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl file_path::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				file_path::id::NAME => file_path::id::set(::serde_json::from_value(val).unwrap()),
				file_path::pub_id::NAME => {
					file_path::pub_id::set(::serde_json::from_value(val).unwrap())
				}
				file_path::is_dir::NAME => {
					file_path::is_dir::set(::serde_json::from_value(val).unwrap())
				}
				file_path::cas_id::NAME => {
					file_path::cas_id::set(::serde_json::from_value(val).unwrap())
				}
				file_path::integrity_checksum::NAME => {
					file_path::integrity_checksum::set(::serde_json::from_value(val).unwrap())
				}
				file_path::location::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					file_path::location::connect(
						location::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				file_path::materialized_path::NAME => {
					file_path::materialized_path::set(::serde_json::from_value(val).unwrap())
				}
				file_path::name::NAME => {
					file_path::name::set(::serde_json::from_value(val).unwrap())
				}
				file_path::extension::NAME => {
					file_path::extension::set(::serde_json::from_value(val).unwrap())
				}
				file_path::size_in_bytes::NAME => {
					file_path::size_in_bytes::set(::serde_json::from_value(val).unwrap())
				}
				file_path::size_in_bytes_bytes::NAME => {
					file_path::size_in_bytes_bytes::set(::serde_json::from_value(val).unwrap())
				}
				file_path::inode::NAME => {
					file_path::inode::set(::serde_json::from_value(val).unwrap())
				}
				file_path::device::NAME => {
					file_path::device::set(::serde_json::from_value(val).unwrap())
				}
				file_path::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					file_path::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				file_path::key_id::NAME => {
					file_path::key_id::set(::serde_json::from_value(val).unwrap())
				}
				file_path::date_created::NAME => {
					file_path::date_created::set(::serde_json::from_value(val).unwrap())
				}
				file_path::date_modified::NAME => {
					file_path::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				file_path::date_indexed::NAME => {
					file_path::date_indexed::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl file_path::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				file_path::id::NAME => {
					file_path::id::equals(::serde_json::from_value(val).unwrap())
				}
				file_path::pub_id::NAME => {
					file_path::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod object {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = object::Types;
	}
	impl sd_sync::SyncType for object::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl object::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				object::id::NAME => object::id::set(::serde_json::from_value(val).unwrap()),
				object::pub_id::NAME => object::pub_id::set(::serde_json::from_value(val).unwrap()),
				object::kind::NAME => object::kind::set(::serde_json::from_value(val).unwrap()),
				object::key_id::NAME => object::key_id::set(::serde_json::from_value(val).unwrap()),
				object::hidden::NAME => object::hidden::set(::serde_json::from_value(val).unwrap()),
				object::favorite::NAME => {
					object::favorite::set(::serde_json::from_value(val).unwrap())
				}
				object::important::NAME => {
					object::important::set(::serde_json::from_value(val).unwrap())
				}
				object::note::NAME => object::note::set(::serde_json::from_value(val).unwrap()),
				object::date_created::NAME => {
					object::date_created::set(::serde_json::from_value(val).unwrap())
				}
				object::date_accessed::NAME => {
					object::date_accessed::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl object::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				object::id::NAME => object::id::equals(::serde_json::from_value(val).unwrap()),
				object::pub_id::NAME => {
					object::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod media_data {
	use super::prisma::*;
	impl media_data::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				media_data::date_created::NAME => {
					media_data::date_created::set(::serde_json::from_value(val).unwrap())
				}
				media_data::date_taken::NAME => {
					media_data::date_taken::set(::serde_json::from_value(val).unwrap())
				}
				media_data::pixel_width::NAME => {
					media_data::pixel_width::set(::serde_json::from_value(val).unwrap())
				}
				media_data::pixel_height::NAME => {
					media_data::pixel_height::set(::serde_json::from_value(val).unwrap())
				}
				media_data::color_space::NAME => {
					media_data::color_space::set(::serde_json::from_value(val).unwrap())
				}
				media_data::longitude::NAME => {
					media_data::longitude::set(::serde_json::from_value(val).unwrap())
				}
				media_data::latitude::NAME => {
					media_data::latitude::set(::serde_json::from_value(val).unwrap())
				}
				media_data::codecs::NAME => {
					media_data::codecs::set(::serde_json::from_value(val).unwrap())
				}
				media_data::device_make::NAME => {
					media_data::device_make::set(::serde_json::from_value(val).unwrap())
				}
				media_data::device_model::NAME => {
					media_data::device_model::set(::serde_json::from_value(val).unwrap())
				}
				media_data::device_software::NAME => {
					media_data::device_software::set(::serde_json::from_value(val).unwrap())
				}
				media_data::focal_length::NAME => {
					media_data::focal_length::set(::serde_json::from_value(val).unwrap())
				}
				media_data::shutter_speed::NAME => {
					media_data::shutter_speed::set(::serde_json::from_value(val).unwrap())
				}
				media_data::orientation::NAME => {
					media_data::orientation::set(::serde_json::from_value(val).unwrap())
				}
				media_data::copyright::NAME => {
					media_data::copyright::set(::serde_json::from_value(val).unwrap())
				}
				media_data::flash::NAME => {
					media_data::flash::set(::serde_json::from_value(val).unwrap())
				}
				media_data::artist::NAME => {
					media_data::artist::set(::serde_json::from_value(val).unwrap())
				}
				media_data::duration::NAME => {
					media_data::duration::set(::serde_json::from_value(val).unwrap())
				}
				media_data::fps::NAME => {
					media_data::fps::set(::serde_json::from_value(val).unwrap())
				}
				media_data::streams::NAME => {
					media_data::streams::set(::serde_json::from_value(val).unwrap())
				}
				media_data::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					media_data::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
	impl media_data::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				media_data::id::NAME => {
					media_data::id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod tag {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = tag::Types;
	}
	impl sd_sync::SyncType for tag::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl tag::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				tag::id::NAME => tag::id::set(::serde_json::from_value(val).unwrap()),
				tag::pub_id::NAME => tag::pub_id::set(::serde_json::from_value(val).unwrap()),
				tag::name::NAME => tag::name::set(::serde_json::from_value(val).unwrap()),
				tag::color::NAME => tag::color::set(::serde_json::from_value(val).unwrap()),
				tag::redundancy_goal::NAME => {
					tag::redundancy_goal::set(::serde_json::from_value(val).unwrap())
				}
				tag::date_created::NAME => {
					tag::date_created::set(::serde_json::from_value(val).unwrap())
				}
				tag::date_modified::NAME => {
					tag::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl tag::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				tag::id::NAME => tag::id::equals(::serde_json::from_value(val).unwrap()),
				tag::pub_id::NAME => tag::pub_id::equals(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
}
pub mod tag_on_object {
	use super::prisma::*;
	impl tag_on_object::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				tag_on_object::tag::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					tag_on_object::tag::connect(
						tag::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				tag_on_object::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					tag_on_object::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
pub mod label {
	use super::prisma::*;
	impl label::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				label::id::NAME => label::id::set(::serde_json::from_value(val).unwrap()),
				label::pub_id::NAME => label::pub_id::set(::serde_json::from_value(val).unwrap()),
				label::name::NAME => label::name::set(::serde_json::from_value(val).unwrap()),
				label::date_created::NAME => {
					label::date_created::set(::serde_json::from_value(val).unwrap())
				}
				label::date_modified::NAME => {
					label::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl label::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				label::id::NAME => label::id::equals(::serde_json::from_value(val).unwrap()),
				label::pub_id::NAME => {
					label::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod label_on_object {
	use super::prisma::*;
	impl label_on_object::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				label_on_object::date_created::NAME => {
					label_on_object::date_created::set(::serde_json::from_value(val).unwrap())
				}
				label_on_object::label::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					label_on_object::label::connect(
						label::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				label_on_object::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					label_on_object::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
pub mod space {
	use super::prisma::*;
	impl space::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				space::id::NAME => space::id::set(::serde_json::from_value(val).unwrap()),
				space::pub_id::NAME => space::pub_id::set(::serde_json::from_value(val).unwrap()),
				space::name::NAME => space::name::set(::serde_json::from_value(val).unwrap()),
				space::description::NAME => {
					space::description::set(::serde_json::from_value(val).unwrap())
				}
				space::date_created::NAME => {
					space::date_created::set(::serde_json::from_value(val).unwrap())
				}
				space::date_modified::NAME => {
					space::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl space::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				space::id::NAME => space::id::equals(::serde_json::from_value(val).unwrap()),
				space::pub_id::NAME => {
					space::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod object_in_space {
	use super::prisma::*;
	impl object_in_space::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				object_in_space::space::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					object_in_space::space::connect(
						space::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				object_in_space::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					object_in_space::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
pub mod job {
	use super::prisma::*;
	impl job::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				job::id::NAME => job::id::set(::serde_json::from_value(val).unwrap()),
				job::name::NAME => job::name::set(::serde_json::from_value(val).unwrap()),
				job::action::NAME => job::action::set(::serde_json::from_value(val).unwrap()),
				job::status::NAME => job::status::set(::serde_json::from_value(val).unwrap()),
				job::errors_text::NAME => {
					job::errors_text::set(::serde_json::from_value(val).unwrap())
				}
				job::data::NAME => job::data::set(::serde_json::from_value(val).unwrap()),
				job::metadata::NAME => job::metadata::set(::serde_json::from_value(val).unwrap()),
				job::task_count::NAME => {
					job::task_count::set(::serde_json::from_value(val).unwrap())
				}
				job::completed_task_count::NAME => {
					job::completed_task_count::set(::serde_json::from_value(val).unwrap())
				}
				job::date_estimated_completion::NAME => {
					job::date_estimated_completion::set(::serde_json::from_value(val).unwrap())
				}
				job::date_created::NAME => {
					job::date_created::set(::serde_json::from_value(val).unwrap())
				}
				job::date_started::NAME => {
					job::date_started::set(::serde_json::from_value(val).unwrap())
				}
				job::date_completed::NAME => {
					job::date_completed::set(::serde_json::from_value(val).unwrap())
				}
				job::parent::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					job::parent::connect(job::UniqueWhereParam::deserialize(&val.0, val.1).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl job::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				job::id::NAME => job::id::equals(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
}
pub mod indexer_rule {
	use super::prisma::*;
	impl indexer_rule::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				indexer_rule::id::NAME => {
					indexer_rule::id::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::pub_id::NAME => {
					indexer_rule::pub_id::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::name::NAME => {
					indexer_rule::name::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::default::NAME => {
					indexer_rule::default::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::rules_per_kind::NAME => {
					indexer_rule::rules_per_kind::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::date_created::NAME => {
					indexer_rule::date_created::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::date_modified::NAME => {
					indexer_rule::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl indexer_rule::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				indexer_rule::id::NAME => {
					indexer_rule::id::equals(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::pub_id::NAME => {
					indexer_rule::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod indexer_rules_in_location {
	use super::prisma::*;
	impl indexer_rules_in_location::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				indexer_rules_in_location::location::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					indexer_rules_in_location::location::connect(
						location::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				indexer_rules_in_location::indexer_rule::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					indexer_rules_in_location::indexer_rule::connect(
						indexer_rule::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
pub mod preference {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub key: String,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = preference::Types;
	}
	impl sd_sync::SyncType for preference::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl preference::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				preference::key::NAME => {
					preference::key::set(::serde_json::from_value(val).unwrap())
				}
				preference::value::NAME => {
					preference::value::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl preference::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				preference::key::NAME => {
					preference::key::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod notification {
	use super::prisma::*;
	impl notification::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				notification::id::NAME => {
					notification::id::set(::serde_json::from_value(val).unwrap())
				}
				notification::read::NAME => {
					notification::read::set(::serde_json::from_value(val).unwrap())
				}
				notification::data::NAME => {
					notification::data::set(::serde_json::from_value(val).unwrap())
				}
				notification::expires_at::NAME => {
					notification::expires_at::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl notification::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				notification::id::NAME => {
					notification::id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
