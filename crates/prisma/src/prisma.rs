// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str =
	include_str!("/Users/broken/Code/spacedrive/core/prisma/schema.prisma");
static DATABASE_STR: &'static str = "sqlite";
use ::prisma_client_rust::migrations::include_dir;
pub static MIGRATIONS_DIR: &::prisma_client_rust::migrations::include_dir::Dir = &::prisma_client_rust::migrations::include_dir::include_dir!(
	"/Users/broken/Code/spacedrive/core/prisma/migrations"
);
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
	url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder()
		.with_url(url.to_string())
		.build()
		.await
}
pub mod shared_operation {
	use super::_prisma::*;
	pub const NAME: &str = "SharedOperation";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::BytesFilter),
		Timestamp(super::_prisma::read_filters::BigIntFilter),
		Model(super::_prisma::read_filters::StringFilter),
		RecordId(super::_prisma::read_filters::BytesFilter),
		Kind(super::_prisma::read_filters::StringFilter),
		Data(super::_prisma::read_filters::BytesFilter),
		InstanceId(super::_prisma::read_filters::IntFilter),
		InstanceIs(Vec<super::instance::WhereParam>),
		InstanceIsNot(Vec<super::instance::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::Timestamp(value) => (timestamp::NAME, value.into()),
				Self::Model(value) => (model::NAME, value.into()),
				Self::RecordId(value) => (record_id::NAME, value.into()),
				Self::Kind(value) => (kind::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::InstanceId(value) => (instance_id::NAME, value.into()),
				Self::InstanceIs(where_params) => (
					instance::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::InstanceIsNot(where_params) => (
					instance::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		Timestamp(super::SortOrder),
		Model(super::SortOrder),
		RecordId(super::SortOrder),
		Kind(super::SortOrder),
		Data(super::SortOrder),
		InstanceId(super::SortOrder),
		Instance(Vec<super::instance::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::Timestamp(param) => ("timestamp", param.into()),
				Self::Model(param) => ("model", param.into()),
				Self::RecordId(param) => ("record_id", param.into()),
				Self::Kind(param) => ("kind", param.into()),
				Self::Data(param) => ("data", param.into()),
				Self::InstanceId(param) => ("instance_id", param.into()),
				Self::Instance(param) => (
					"instance",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Instance(super::instance::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Instance(args) => {
					let mut selections = < super :: instance :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(instance::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::BytesParam),
		Timestamp(super::_prisma::write_params::BigIntParam),
		Model(super::_prisma::write_params::StringParam),
		RecordId(super::_prisma::write_params::BytesParam),
		Kind(super::_prisma::write_params::StringParam),
		Data(super::_prisma::write_params::BytesParam),
		InstanceId(super::_prisma::write_params::IntParam),
		ConnectInstance(super::instance::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::Timestamp(value) => (timestamp::NAME, value.into()),
				Self::Model(value) => (model::NAME, value.into()),
				Self::RecordId(value) => (record_id::NAME, value.into()),
				Self::Kind(value) => (kind::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::InstanceId(value) => (instance_id::NAME, value.into()),
				Self::ConnectInstance(where_param) => (
					instance::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::instance::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::BytesParam),
		Timestamp(super::_prisma::write_params::BigIntParam),
		Model(super::_prisma::write_params::StringParam),
		RecordId(super::_prisma::write_params::BytesParam),
		Kind(super::_prisma::write_params::StringParam),
		Data(super::_prisma::write_params::BytesParam),
		InstanceId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::Timestamp(value) => ("timestamp", value.into()),
				Self::Model(value) => ("model", value.into()),
				Self::RecordId(value) => ("record_id", value.into()),
				Self::Kind(value) => ("kind", value.into()),
				Self::Data(value) => ("data", value.into()),
				Self::InstanceId(value) => ("instance_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_shared_operation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: shared_operation :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: shared_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: shared_operation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: shared_operation :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: shared_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: shared_operation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , timestamp , model , record_id , kind , data , instance_id , instance } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: shared_operation :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: shared_operation :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: shared_operation :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: shared_operation :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: shared_operation :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: shared_operation :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: shared_operation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: shared_operation :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "timestamp" , "model" , "record_id" , "kind" , "data" , "instance_id" , "instance"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: shared_operation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; instance : $ selection_mode : ident { $ ($ selections : tt) + }) => { instance :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: shared_operation :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SharedOperation" , available relations are "id, timestamp, model, record_id, kind, data, instance_id, instance")) } ; (@ field_module ; instance : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: instance :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: shared_operation :: SelectParam > :: into (sd_prisma :: prisma :: shared_operation :: id :: Select) } ; (@ selection_field_to_selection_param ; timestamp) => { Into :: < sd_prisma :: prisma :: shared_operation :: SelectParam > :: into (sd_prisma :: prisma :: shared_operation :: timestamp :: Select) } ; (@ selection_field_to_selection_param ; model) => { Into :: < sd_prisma :: prisma :: shared_operation :: SelectParam > :: into (sd_prisma :: prisma :: shared_operation :: model :: Select) } ; (@ selection_field_to_selection_param ; record_id) => { Into :: < sd_prisma :: prisma :: shared_operation :: SelectParam > :: into (sd_prisma :: prisma :: shared_operation :: record_id :: Select) } ; (@ selection_field_to_selection_param ; kind) => { Into :: < sd_prisma :: prisma :: shared_operation :: SelectParam > :: into (sd_prisma :: prisma :: shared_operation :: kind :: Select) } ; (@ selection_field_to_selection_param ; data) => { Into :: < sd_prisma :: prisma :: shared_operation :: SelectParam > :: into (sd_prisma :: prisma :: shared_operation :: data :: Select) } ; (@ selection_field_to_selection_param ; instance_id) => { Into :: < sd_prisma :: prisma :: shared_operation :: SelectParam > :: into (sd_prisma :: prisma :: shared_operation :: instance_id :: Select) } ; (@ selection_field_to_selection_param ; instance $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: shared_operation :: SelectParam > :: into (sd_prisma :: prisma :: shared_operation :: instance :: Select :: $ selection_mode (sd_prisma :: prisma :: instance :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; instance $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: shared_operation :: SelectParam > :: into (sd_prisma :: prisma :: shared_operation :: instance :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: shared_operation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; model) => { "model" } ; (@ field_serde_name ; record_id) => { "record_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; instance_id) => { "instance_id" } ; (@ field_serde_name ; instance) => { "instance" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_shared_operation as select;
	pub enum SelectParam {
		Id(id::Select),
		Timestamp(timestamp::Select),
		Model(model::Select),
		RecordId(record_id::Select),
		Kind(kind::Select),
		Data(data::Select),
		InstanceId(instance_id::Select),
		Instance(instance::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Timestamp(data) => data.to_selection(),
				Self::Model(data) => data.to_selection(),
				Self::RecordId(data) => data.to_selection(),
				Self::Kind(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::InstanceId(data) => data.to_selection(),
				Self::Instance(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_shared_operation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: shared_operation :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: shared_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: shared_operation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: shared_operation :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: shared_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: shared_operation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { instance } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: shared_operation :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: shared_operation :: id :: NAME)] pub id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: shared_operation :: timestamp :: NAME)] pub timestamp : i64 , # [specta (rename_from_path = sd_prisma :: prisma :: shared_operation :: model :: NAME)] pub model : String , # [specta (rename_from_path = sd_prisma :: prisma :: shared_operation :: record_id :: NAME)] pub record_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: shared_operation :: kind :: NAME)] pub kind : String , # [specta (rename_from_path = sd_prisma :: prisma :: shared_operation :: data :: NAME)] pub data : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: shared_operation :: instance_id :: NAME)] pub instance_id : i32 , $ (# [specta (rename_from_path = sd_prisma :: prisma :: shared_operation :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: shared_operation :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (timestamp) , stringify ! (model) , stringify ! (record_id) , stringify ! (kind) , stringify ! (data) , stringify ! (instance_id)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: shared_operation :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: shared_operation :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: shared_operation :: timestamp :: NAME , & self . timestamp) ? ; state . serialize_field (sd_prisma :: prisma :: shared_operation :: model :: NAME , & self . model) ? ; state . serialize_field (sd_prisma :: prisma :: shared_operation :: record_id :: NAME , & self . record_id) ? ; state . serialize_field (sd_prisma :: prisma :: shared_operation :: kind :: NAME , & self . kind) ? ; state . serialize_field (sd_prisma :: prisma :: shared_operation :: data :: NAME , & self . data) ? ; state . serialize_field (sd_prisma :: prisma :: shared_operation :: instance_id :: NAME , & self . instance_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , timestamp , model , record_id , kind , data , instance_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: shared_operation :: $ field :: NAME) , + , sd_prisma :: prisma :: shared_operation :: id :: NAME , sd_prisma :: prisma :: shared_operation :: timestamp :: NAME , sd_prisma :: prisma :: shared_operation :: model :: NAME , sd_prisma :: prisma :: shared_operation :: record_id :: NAME , sd_prisma :: prisma :: shared_operation :: kind :: NAME , sd_prisma :: prisma :: shared_operation :: data :: NAME , sd_prisma :: prisma :: shared_operation :: instance_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: shared_operation :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: shared_operation :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: shared_operation :: timestamp :: NAME => Ok (Field :: timestamp) , sd_prisma :: prisma :: shared_operation :: model :: NAME => Ok (Field :: model) , sd_prisma :: prisma :: shared_operation :: record_id :: NAME => Ok (Field :: record_id) , sd_prisma :: prisma :: shared_operation :: kind :: NAME => Ok (Field :: kind) , sd_prisma :: prisma :: shared_operation :: data :: NAME => Ok (Field :: data) , sd_prisma :: prisma :: shared_operation :: instance_id :: NAME => Ok (Field :: instance_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut timestamp = None ; let mut model = None ; let mut record_id = None ; let mut kind = None ; let mut data = None ; let mut instance_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: shared_operation :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: timestamp => { if timestamp . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: shared_operation :: timestamp :: NAME)) ; } timestamp = Some (map . next_value () ?) ; } Field :: model => { if model . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: shared_operation :: model :: NAME)) ; } model = Some (map . next_value () ?) ; } Field :: record_id => { if record_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: shared_operation :: record_id :: NAME)) ; } record_id = Some (map . next_value () ?) ; } Field :: kind => { if kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: shared_operation :: kind :: NAME)) ; } kind = Some (map . next_value () ?) ; } Field :: data => { if data . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: shared_operation :: data :: NAME)) ; } data = Some (map . next_value () ?) ; } Field :: instance_id => { if instance_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: shared_operation :: instance_id :: NAME)) ; } instance_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: shared_operation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: shared_operation :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: shared_operation :: id :: NAME)) ? ; let timestamp = timestamp . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: shared_operation :: timestamp :: NAME)) ? ; let model = model . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: shared_operation :: model :: NAME)) ? ; let record_id = record_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: shared_operation :: record_id :: NAME)) ? ; let kind = kind . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: shared_operation :: kind :: NAME)) ? ; let data = data . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: shared_operation :: data :: NAME)) ? ; let instance_id = instance_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: shared_operation :: instance_id :: NAME)) ? ; Ok (Data { id , timestamp , model , record_id , kind , data , instance_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "timestamp" , "model" , "record_id" , "kind" , "data" , "instance_id" , "instance"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: shared_operation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; instance : $ selection_mode : ident { $ ($ selections : tt) + }) => { instance :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: shared_operation :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SharedOperation" , available relations are "instance")) } ; (@ field_module ; instance : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: instance :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; instance $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: shared_operation :: IncludeParam > :: into (sd_prisma :: prisma :: shared_operation :: instance :: Include :: $ selection_mode (sd_prisma :: prisma :: instance :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; instance $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: shared_operation :: IncludeParam > :: into (sd_prisma :: prisma :: shared_operation :: instance :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: shared_operation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; model) => { "model" } ; (@ field_serde_name ; record_id) => { "record_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; instance_id) => { "instance_id" } ; (@ field_serde_name ; instance) => { "instance" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_shared_operation as include;
	pub enum IncludeParam {
		Id(id::Include),
		Timestamp(timestamp::Include),
		Model(model::Include),
		RecordId(record_id::Include),
		Kind(kind::Include),
		Data(data::Include),
		InstanceId(instance_id::Include),
		Instance(instance::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Timestamp(data) => data.to_selection(),
				Self::Model(data) => data.to_selection(),
				Self::RecordId(data) => data.to_selection(),
				Self::Kind(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::InstanceId(data) => data.to_selection(),
				Self::Instance(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod data {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "data";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::Data(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Data, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Data(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Data(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Data(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Id, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod instance {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "instance";
		pub type Type = instance::Data;
		pub type RecursiveSafeType = Box<instance::Data>;
		pub fn is(value: Vec<instance::WhereParam>) -> WhereParam {
			WhereParam::InstanceIs(value)
		}
		pub fn is_not(value: Vec<instance::WhereParam>) -> WhereParam {
			WhereParam::InstanceIsNot(value)
		}
		pub struct Order(Vec<instance::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<instance::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Instance(v)
			}
		}
		pub struct Fetch(pub instance::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<instance::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Instance(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(instance::UniqueArgs::new())
		}
		pub struct Connect(instance::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectInstance(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: instance::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<instance::SelectParam>),
			Include(Vec<instance::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Instance(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<instance::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("instance", None, [], selections)
			}
			pub fn select(nested_selections: Vec<instance::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<instance::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<instance::SelectParam>),
			Include(Vec<instance::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Instance(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = < instance :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<instance::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("instance", None, [], selections)
			}
			pub fn select(nested_selections: Vec<instance::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<instance::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod instance_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "instance_id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::InstanceId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			InstanceId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::InstanceId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::InstanceId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::InstanceId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::InstanceId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::InstanceId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod kind {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "kind";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Kind(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Kind, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Kind(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Kind(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Kind(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Kind(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Kind(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Kind(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Kind(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod model {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "model";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Model(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			Model,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Model(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Model(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Model(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Model(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Model(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Model(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Model(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod record_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "record_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::RecordId(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			RecordId,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::RecordId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RecordId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::RecordId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::RecordId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RecordId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::RecordId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::RecordId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod timestamp {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "timestamp";
		pub type Type = i64;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i64) -> WhereParam {
			WhereParam::Timestamp(_prisma::read_filters::BigIntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BigIntFilter,
			Timestamp,
			{
				fn in_vec(_: Vec<i64>) -> InVec;
				fn not_in_vec(_: Vec<i64>) -> NotInVec;
				fn lt(_: i64) -> Lt;
				fn lte(_: i64) -> Lte;
				fn gt(_: i64) -> Gt;
				fn gte(_: i64) -> Gte;
				fn not(_: i64) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Timestamp(v)
			}
		}
		pub struct Set(pub i64);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Timestamp(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Timestamp(_prisma::write_params::BigIntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i64) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Timestamp(_prisma::write_params::BigIntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Timestamp(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Timestamp(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Timestamp(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub id: Vec<u8>,
		pub timestamp: i64,
		pub model: String,
		pub record_id: Vec<u8>,
		pub kind: String,
		pub data: Vec<u8>,
		pub instance: super::instance::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.shared_operation().create(
				self.id,
				self.timestamp,
				self.model,
				self.record_id,
				self.kind,
				self.data,
				self.instance,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				id::set(self.id),
				timestamp::set(self.timestamp),
				model::set(self.model),
				record_id::set(self.record_id),
				kind::set(self.kind),
				data::set(self.data),
				instance::connect(self.instance),
			]);
			self._params
		}
	}
	pub fn create(
		id: Vec<u8>,
		timestamp: i64,
		model: String,
		record_id: Vec<u8>,
		kind: String,
		data: Vec<u8>,
		instance: super::instance::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			id,
			timestamp,
			model,
			record_id,
			kind,
			data,
			instance,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub id: Vec<u8>,
		pub timestamp: i64,
		pub model: String,
		pub record_id: Vec<u8>,
		pub kind: String,
		pub data: Vec<u8>,
		pub instance_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.shared_operation().create_unchecked(
				self.id,
				self.timestamp,
				self.model,
				self.record_id,
				self.kind,
				self.data,
				self.instance_id,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				id::set(self.id),
				timestamp::set(self.timestamp),
				model::set(self.model),
				record_id::set(self.record_id),
				kind::set(self.kind),
				data::set(self.data),
				instance_id::set(self.instance_id),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		id: Vec<u8>,
		timestamp: i64,
		model: String,
		record_id: Vec<u8>,
		kind: String,
		data: Vec<u8>,
		instance_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			id,
			timestamp,
			model,
			record_id,
			kind,
			data,
			instance_id,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(timestamp::NAME),
				::prisma_client_rust::sel(model::NAME),
				::prisma_client_rust::sel(record_id::NAME),
				::prisma_client_rust::sel(kind::NAME),
				::prisma_client_rust::sel(data::NAME),
				::prisma_client_rust::sel(instance_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "SharedOperation", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "timestamp")]
		pub timestamp: timestamp::Type,
		#[serde(rename = "model")]
		pub model: model::Type,
		#[serde(rename = "record_id")]
		pub record_id: record_id::Type,
		#[serde(rename = "kind")]
		pub kind: kind::Type,
		#[serde(rename = "data")]
		pub data: data::Type,
		#[serde(rename = "instance_id")]
		pub instance_id: instance_id::Type,
		#[serde(rename = "instance")]
		#[specta(skip)]
		pub instance: Option<instance::RecursiveSafeType>,
	}
	impl Data {
		pub fn instance(
			&self,
		) -> Result<&super::instance::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.instance
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(instance),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_shared_operation { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: shared_operation struct $ struct_name { # [serde (rename = "id")] pub id : Vec < u8 > , # [serde (rename = "timestamp")] pub timestamp : i64 , # [serde (rename = "model")] pub model : String , # [serde (rename = "record_id")] pub record_id : Vec < u8 > , # [serde (rename = "kind")] pub kind : String , # [serde (rename = "data")] pub data : Vec < u8 > , # [serde (rename = "instance_id")] pub instance_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_shared_operation as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			id: Vec<u8>,
			timestamp: i64,
			model: String,
			record_id: Vec<u8>,
			kind: String,
			data: Vec<u8>,
			instance: super::instance::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				id::set(id),
				timestamp::set(timestamp),
				model::set(model),
				record_id::set(record_id),
				kind::set(kind),
				data::set(data),
				instance::connect(instance),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			id: Vec<u8>,
			timestamp: i64,
			model: String,
			record_id: Vec<u8>,
			kind: String,
			data: Vec<u8>,
			instance_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				id::set(id),
				timestamp::set(timestamp),
				model::set(model),
				record_id::set(record_id),
				kind::set(kind),
				data::set(data),
				instance_id::set(instance_id),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod node {
	use super::_prisma::*;
	pub const NAME: &str = "Node";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringFilter),
		Platform(super::_prisma::read_filters::IntFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		Identity(super::_prisma::read_filters::BytesNullableFilter),
		NodePeerId(super::_prisma::read_filters::StringNullableFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Platform(value) => (platform::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::Identity(value) => (identity::NAME, value.into()),
				Self::NodePeerId(value) => (node_peer_id::NAME, value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		Platform(super::SortOrder),
		DateCreated(super::SortOrder),
		Identity(super::SortOrder),
		NodePeerId(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Platform(param) => ("platform", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::Identity(param) => ("identity", param.into()),
				Self::NodePeerId(param) => ("node_peer_id", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringParam),
		Platform(super::_prisma::write_params::IntParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		Identity(super::_prisma::write_params::BytesNullableParam),
		NodePeerId(super::_prisma::write_params::StringNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Platform(value) => (platform::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::Identity(value) => (identity::NAME, value.into()),
				Self::NodePeerId(value) => (node_peer_id::NAME, value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringParam),
		Platform(super::_prisma::write_params::IntParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		Identity(super::_prisma::write_params::BytesNullableParam),
		NodePeerId(super::_prisma::write_params::StringNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Platform(value) => ("platform", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::Identity(value) => ("identity", value.into()),
				Self::NodePeerId(value) => ("node_peer_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_node { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: node :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: node :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: node :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: node :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: node :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: node :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , platform , date_created , identity , node_peer_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: node :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: node :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: node :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: node :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: node :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: node :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: node :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: node :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "platform" , "date_created" , "identity" , "node_peer_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: node :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: node :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Node" , available relations are "id, pub_id, name, platform, date_created, identity, node_peer_id")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: node :: SelectParam > :: into (sd_prisma :: prisma :: node :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < sd_prisma :: prisma :: node :: SelectParam > :: into (sd_prisma :: prisma :: node :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < sd_prisma :: prisma :: node :: SelectParam > :: into (sd_prisma :: prisma :: node :: name :: Select) } ; (@ selection_field_to_selection_param ; platform) => { Into :: < sd_prisma :: prisma :: node :: SelectParam > :: into (sd_prisma :: prisma :: node :: platform :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: node :: SelectParam > :: into (sd_prisma :: prisma :: node :: date_created :: Select) } ; (@ selection_field_to_selection_param ; identity) => { Into :: < sd_prisma :: prisma :: node :: SelectParam > :: into (sd_prisma :: prisma :: node :: identity :: Select) } ; (@ selection_field_to_selection_param ; node_peer_id) => { Into :: < sd_prisma :: prisma :: node :: SelectParam > :: into (sd_prisma :: prisma :: node :: node_peer_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: node :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; platform) => { "platform" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; identity) => { "identity" } ; (@ field_serde_name ; node_peer_id) => { "node_peer_id" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_node as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		Platform(platform::Select),
		DateCreated(date_created::Select),
		Identity(identity::Select),
		NodePeerId(node_peer_id::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Platform(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::Identity(data) => data.to_selection(),
				Self::NodePeerId(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_node { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: node :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: node :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: node :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: node :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: node :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: node :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: node :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: node :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: node :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: node :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: node :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: node :: name :: NAME)] pub name : String , # [specta (rename_from_path = sd_prisma :: prisma :: node :: platform :: NAME)] pub platform : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: node :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = sd_prisma :: prisma :: node :: identity :: NAME)] pub identity : Option < Vec < u8 > > , # [specta (rename_from_path = sd_prisma :: prisma :: node :: node_peer_id :: NAME)] pub node_peer_id : Option < String > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: node :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: node :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (platform) , stringify ! (date_created) , stringify ! (identity) , stringify ! (node_peer_id)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: node :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: node :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: node :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (sd_prisma :: prisma :: node :: name :: NAME , & self . name) ? ; state . serialize_field (sd_prisma :: prisma :: node :: platform :: NAME , & self . platform) ? ; state . serialize_field (sd_prisma :: prisma :: node :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: node :: identity :: NAME , & self . identity) ? ; state . serialize_field (sd_prisma :: prisma :: node :: node_peer_id :: NAME , & self . node_peer_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , platform , date_created , identity , node_peer_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: node :: $ field :: NAME) , + , sd_prisma :: prisma :: node :: id :: NAME , sd_prisma :: prisma :: node :: pub_id :: NAME , sd_prisma :: prisma :: node :: name :: NAME , sd_prisma :: prisma :: node :: platform :: NAME , sd_prisma :: prisma :: node :: date_created :: NAME , sd_prisma :: prisma :: node :: identity :: NAME , sd_prisma :: prisma :: node :: node_peer_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: node :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: node :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: node :: pub_id :: NAME => Ok (Field :: pub_id) , sd_prisma :: prisma :: node :: name :: NAME => Ok (Field :: name) , sd_prisma :: prisma :: node :: platform :: NAME => Ok (Field :: platform) , sd_prisma :: prisma :: node :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: node :: identity :: NAME => Ok (Field :: identity) , sd_prisma :: prisma :: node :: node_peer_id :: NAME => Ok (Field :: node_peer_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut platform = None ; let mut date_created = None ; let mut identity = None ; let mut node_peer_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: node :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: node :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: node :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: platform => { if platform . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: node :: platform :: NAME)) ; } platform = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: node :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: identity => { if identity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: node :: identity :: NAME)) ; } identity = Some (map . next_value () ?) ; } Field :: node_peer_id => { if node_peer_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: node :: node_peer_id :: NAME)) ; } node_peer_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: node :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: node :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: node :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: node :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: node :: name :: NAME)) ? ; let platform = platform . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: node :: platform :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: node :: date_created :: NAME)) ? ; let identity = identity . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: node :: identity :: NAME)) ? ; let node_peer_id = node_peer_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: node :: node_peer_id :: NAME)) ? ; Ok (Data { id , pub_id , name , platform , date_created , identity , node_peer_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "platform" , "date_created" , "identity" , "node_peer_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: node :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: node :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Node" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: node :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; platform) => { "platform" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; identity) => { "identity" } ; (@ field_serde_name ; node_peer_id) => { "node_peer_id" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_node as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		Platform(platform::Include),
		DateCreated(date_created::Include),
		Identity(identity::Include),
		NodePeerId(node_peer_id::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Platform(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::Identity(data) => data.to_selection(),
				Self::NodePeerId(data) => data.to_selection(),
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type =
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod identity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "identity";
		pub type Type = Option<Vec<u8>>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::Identity(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			Identity,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Identity(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Identity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Identity(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Identity(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Identity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Identity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Identity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod node_peer_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node_peer_id";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::NodePeerId(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			NodePeerId,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::NodePeerId(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodePeerId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodePeerId(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodePeerId(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodePeerId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NodePeerId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NodePeerId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod platform {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "platform";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::Platform(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			Platform,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Platform(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Platform(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Platform(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Platform(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Platform(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Platform(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Platform(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub name: String,
		pub platform: i32,
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.node().create(
				self.pub_id,
				self.name,
				self.platform,
				self.date_created,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				pub_id::set(self.pub_id),
				name::set(self.name),
				platform::set(self.platform),
				date_created::set(self.date_created),
			]);
			self._params
		}
	}
	pub fn create(
		pub_id: Vec<u8>,
		name: String,
		platform: i32,
		date_created: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			pub_id,
			name,
			platform,
			date_created,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub name: String,
		pub platform: i32,
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.node().create_unchecked(
				self.pub_id,
				self.name,
				self.platform,
				self.date_created,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				pub_id::set(self.pub_id),
				name::set(self.name),
				platform::set(self.platform),
				date_created::set(self.date_created),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		pub_id: Vec<u8>,
		name: String,
		platform: i32,
		date_created: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			pub_id,
			name,
			platform,
			date_created,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(platform::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(identity::NAME),
				::prisma_client_rust::sel(node_peer_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Node", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: pub_id::Type,
		#[serde(rename = "name")]
		pub name: name::Type,
		#[serde(rename = "platform")]
		pub platform: platform::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "identity")]
		pub identity: identity::Type,
		#[serde(rename = "node_peer_id")]
		pub node_peer_id: node_peer_id::Type,
	}
	impl Data {}
	#[macro_export]
	macro_rules ! _partial_unchecked_node { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: node struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] pub name : String , # [serde (rename = "platform")] pub platform : i32 , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "identity")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub identity : Option < Vec < u8 > > , # [serde (rename = "node_peer_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub node_peer_id : Option < String > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_node as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			pub_id: Vec<u8>,
			name: String,
			platform: i32,
			date_created: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				pub_id::set(pub_id),
				name::set(name),
				platform::set(platform),
				date_created::set(date_created),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			name: String,
			platform: i32,
			date_created: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				pub_id::set(pub_id),
				name::set(name),
				platform::set(platform),
				date_created::set(date_created),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod instance {
	use super::_prisma::*;
	pub const NAME: &str = "Instance";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Identity(super::_prisma::read_filters::BytesFilter),
		NodeId(super::_prisma::read_filters::BytesFilter),
		NodeName(super::_prisma::read_filters::StringFilter),
		NodePlatform(super::_prisma::read_filters::IntFilter),
		LastSeen(super::_prisma::read_filters::DateTimeFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		SharedOperationSome(Vec<super::shared_operation::WhereParam>),
		SharedOperationEvery(Vec<super::shared_operation::WhereParam>),
		SharedOperationNone(Vec<super::shared_operation::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Identity(value) => (identity::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::NodeName(value) => (node_name::NAME, value.into()),
				Self::NodePlatform(value) => (node_platform::NAME, value.into()),
				Self::LastSeen(value) => (last_seen::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::SharedOperationSome(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SharedOperationEvery(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SharedOperationNone(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Identity(super::SortOrder),
		NodeId(super::SortOrder),
		NodeName(super::SortOrder),
		NodePlatform(super::SortOrder),
		LastSeen(super::SortOrder),
		DateCreated(super::SortOrder),
		SharedOperation(Vec<super::shared_operation::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Identity(param) => ("identity", param.into()),
				Self::NodeId(param) => ("node_id", param.into()),
				Self::NodeName(param) => ("node_name", param.into()),
				Self::NodePlatform(param) => ("node_platform", param.into()),
				Self::LastSeen(param) => ("last_seen", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::SharedOperation(param) => (
					"SharedOperation",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		SharedOperation(super::shared_operation::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::SharedOperation(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						shared_operation::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Identity(super::_prisma::write_params::BytesParam),
		NodeId(super::_prisma::write_params::BytesParam),
		NodeName(super::_prisma::write_params::StringParam),
		NodePlatform(super::_prisma::write_params::IntParam),
		LastSeen(super::_prisma::write_params::DateTimeParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		ConnectSharedOperation(Vec<super::shared_operation::UniqueWhereParam>),
		DisconnectSharedOperation(Vec<super::shared_operation::UniqueWhereParam>),
		SetSharedOperation(Vec<super::shared_operation::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Identity(value) => (identity::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::NodeName(value) => (node_name::NAME, value.into()),
				Self::NodePlatform(value) => (node_platform::NAME, value.into()),
				Self::LastSeen(value) => (last_seen::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::ConnectSharedOperation(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::shared_operation::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectSharedOperation(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::shared_operation::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetSharedOperation(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::shared_operation::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Identity(super::_prisma::write_params::BytesParam),
		NodeId(super::_prisma::write_params::BytesParam),
		NodeName(super::_prisma::write_params::StringParam),
		NodePlatform(super::_prisma::write_params::IntParam),
		LastSeen(super::_prisma::write_params::DateTimeParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Identity(value) => ("identity", value.into()),
				Self::NodeId(value) => ("node_id", value.into()),
				Self::NodeName(value) => ("node_name", value.into()),
				Self::NodePlatform(value) => ("node_platform", value.into()),
				Self::LastSeen(value) => ("last_seen", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_instance { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: instance :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: instance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: instance :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: instance :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: instance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: instance :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , identity , node_id , node_name , node_platform , last_seen , date_created , shared_operation } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: instance :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: instance :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: instance :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: instance :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: instance :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: instance :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "identity" , "node_id" , "node_name" , "node_platform" , "last_seen" , "date_created" , "SharedOperation"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: instance :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; shared_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < shared_operation :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: instance :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Instance" , available relations are "id, pub_id, identity, node_id, node_name, node_platform, last_seen, date_created, shared_operation")) } ; (@ field_module ; shared_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: shared_operation :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; identity) => { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: identity :: Select) } ; (@ selection_field_to_selection_param ; node_id) => { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: node_id :: Select) } ; (@ selection_field_to_selection_param ; node_name) => { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: node_name :: Select) } ; (@ selection_field_to_selection_param ; node_platform) => { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: node_platform :: Select) } ; (@ selection_field_to_selection_param ; last_seen) => { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: last_seen :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: date_created :: Select) } ; (@ selection_field_to_selection_param ; shared_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: shared_operation :: Select :: $ selection_mode (sd_prisma :: prisma :: shared_operation :: ManyArgs :: new (sd_prisma :: prisma :: shared_operation :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: shared_operation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; shared_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: instance :: SelectParam > :: into (sd_prisma :: prisma :: instance :: shared_operation :: Select :: Fetch (sd_prisma :: prisma :: shared_operation :: ManyArgs :: new (sd_prisma :: prisma :: shared_operation :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: instance :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; identity) => { "identity" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; node_name) => { "node_name" } ; (@ field_serde_name ; node_platform) => { "node_platform" } ; (@ field_serde_name ; last_seen) => { "last_seen" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; shared_operation) => { "SharedOperation" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_instance as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Identity(identity::Select),
		NodeId(node_id::Select),
		NodeName(node_name::Select),
		NodePlatform(node_platform::Select),
		LastSeen(last_seen::Select),
		DateCreated(date_created::Select),
		SharedOperation(shared_operation::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Identity(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::NodeName(data) => data.to_selection(),
				Self::NodePlatform(data) => data.to_selection(),
				Self::LastSeen(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::SharedOperation(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_instance { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: instance :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: instance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: instance :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: instance :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: instance :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: instance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: instance :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: instance :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { shared_operation } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: instance :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: instance :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: instance :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: instance :: identity :: NAME)] pub identity : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: instance :: node_id :: NAME)] pub node_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: instance :: node_name :: NAME)] pub node_name : String , # [specta (rename_from_path = sd_prisma :: prisma :: instance :: node_platform :: NAME)] pub node_platform : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: instance :: last_seen :: NAME)] pub last_seen : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = sd_prisma :: prisma :: instance :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: instance :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: instance :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (identity) , stringify ! (node_id) , stringify ! (node_name) , stringify ! (node_platform) , stringify ! (last_seen) , stringify ! (date_created)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: instance :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: instance :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: instance :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (sd_prisma :: prisma :: instance :: identity :: NAME , & self . identity) ? ; state . serialize_field (sd_prisma :: prisma :: instance :: node_id :: NAME , & self . node_id) ? ; state . serialize_field (sd_prisma :: prisma :: instance :: node_name :: NAME , & self . node_name) ? ; state . serialize_field (sd_prisma :: prisma :: instance :: node_platform :: NAME , & self . node_platform) ? ; state . serialize_field (sd_prisma :: prisma :: instance :: last_seen :: NAME , & self . last_seen) ? ; state . serialize_field (sd_prisma :: prisma :: instance :: date_created :: NAME , & self . date_created) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , identity , node_id , node_name , node_platform , last_seen , date_created } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: instance :: $ field :: NAME) , + , sd_prisma :: prisma :: instance :: id :: NAME , sd_prisma :: prisma :: instance :: pub_id :: NAME , sd_prisma :: prisma :: instance :: identity :: NAME , sd_prisma :: prisma :: instance :: node_id :: NAME , sd_prisma :: prisma :: instance :: node_name :: NAME , sd_prisma :: prisma :: instance :: node_platform :: NAME , sd_prisma :: prisma :: instance :: last_seen :: NAME , sd_prisma :: prisma :: instance :: date_created :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: instance :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: instance :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: instance :: pub_id :: NAME => Ok (Field :: pub_id) , sd_prisma :: prisma :: instance :: identity :: NAME => Ok (Field :: identity) , sd_prisma :: prisma :: instance :: node_id :: NAME => Ok (Field :: node_id) , sd_prisma :: prisma :: instance :: node_name :: NAME => Ok (Field :: node_name) , sd_prisma :: prisma :: instance :: node_platform :: NAME => Ok (Field :: node_platform) , sd_prisma :: prisma :: instance :: last_seen :: NAME => Ok (Field :: last_seen) , sd_prisma :: prisma :: instance :: date_created :: NAME => Ok (Field :: date_created) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut identity = None ; let mut node_id = None ; let mut node_name = None ; let mut node_platform = None ; let mut last_seen = None ; let mut date_created = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: identity => { if identity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: identity :: NAME)) ; } identity = Some (map . next_value () ?) ; } Field :: node_id => { if node_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: node_id :: NAME)) ; } node_id = Some (map . next_value () ?) ; } Field :: node_name => { if node_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: node_name :: NAME)) ; } node_name = Some (map . next_value () ?) ; } Field :: node_platform => { if node_platform . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: node_platform :: NAME)) ; } node_platform = Some (map . next_value () ?) ; } Field :: last_seen => { if last_seen . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: last_seen :: NAME)) ; } last_seen = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: instance :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: pub_id :: NAME)) ? ; let identity = identity . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: identity :: NAME)) ? ; let node_id = node_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: node_id :: NAME)) ? ; let node_name = node_name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: node_name :: NAME)) ? ; let node_platform = node_platform . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: node_platform :: NAME)) ? ; let last_seen = last_seen . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: last_seen :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: instance :: date_created :: NAME)) ? ; Ok (Data { id , pub_id , identity , node_id , node_name , node_platform , last_seen , date_created , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "identity" , "node_id" , "node_name" , "node_platform" , "last_seen" , "date_created" , "SharedOperation"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: instance :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; shared_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < shared_operation :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: instance :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Instance" , available relations are "shared_operation")) } ; (@ field_module ; shared_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: shared_operation :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; shared_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: instance :: IncludeParam > :: into (sd_prisma :: prisma :: instance :: shared_operation :: Include :: $ selection_mode (sd_prisma :: prisma :: shared_operation :: ManyArgs :: new (sd_prisma :: prisma :: shared_operation :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: shared_operation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; shared_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: instance :: IncludeParam > :: into (sd_prisma :: prisma :: instance :: shared_operation :: Include :: Fetch (sd_prisma :: prisma :: shared_operation :: ManyArgs :: new (sd_prisma :: prisma :: shared_operation :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: instance :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; identity) => { "identity" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; node_name) => { "node_name" } ; (@ field_serde_name ; node_platform) => { "node_platform" } ; (@ field_serde_name ; last_seen) => { "last_seen" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; shared_operation) => { "SharedOperation" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_instance as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Identity(identity::Include),
		NodeId(node_id::Include),
		NodeName(node_name::Include),
		NodePlatform(node_platform::Include),
		LastSeen(last_seen::Include),
		DateCreated(date_created::Include),
		SharedOperation(shared_operation::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Identity(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::NodeName(data) => data.to_selection(),
				Self::NodePlatform(data) => data.to_selection(),
				Self::LastSeen(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::SharedOperation(data) => data.to_selection(),
			}
		}
	}
	pub mod shared_operation {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "SharedOperation";
		pub type Type = Vec<shared_operation::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<shared_operation::WhereParam>) -> WhereParam {
			WhereParam::SharedOperationSome(value)
		}
		pub fn every(value: Vec<shared_operation::WhereParam>) -> WhereParam {
			WhereParam::SharedOperationEvery(value)
		}
		pub fn none(value: Vec<shared_operation::WhereParam>) -> WhereParam {
			WhereParam::SharedOperationNone(value)
		}
		pub struct Order(Vec<shared_operation::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<shared_operation::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::SharedOperation(v)
			}
		}
		pub struct Fetch(pub shared_operation::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<shared_operation::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: shared_operation::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: shared_operation::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::SharedOperation(v)
			}
		}
		pub fn fetch(params: Vec<shared_operation::WhereParam>) -> Fetch {
			Fetch(shared_operation::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<shared_operation::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectSharedOperation(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<shared_operation::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<shared_operation::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectSharedOperation(params)
		}
		pub fn set(params: Vec<shared_operation::UniqueWhereParam>) -> SetParam {
			SetParam::SetSharedOperation(params)
		}
		pub enum Select {
			Select(
				shared_operation::ManyArgs,
				Vec<shared_operation::SelectParam>,
			),
			Include(
				shared_operation::ManyArgs,
				Vec<shared_operation::IncludeParam>,
			),
			Fetch(shared_operation::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SharedOperation(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: shared_operation::ManyArgs,
				nested_selections: Vec<shared_operation::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: shared_operation::ManyArgs,
				nested_selections: Vec<shared_operation::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(
				shared_operation::ManyArgs,
				Vec<shared_operation::SelectParam>,
			),
			Include(
				shared_operation::ManyArgs,
				Vec<shared_operation::IncludeParam>,
			),
			Fetch(shared_operation::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SharedOperation(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: shared_operation::ManyArgs,
				nested_selections: Vec<shared_operation::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: shared_operation::ManyArgs,
				nested_selections: Vec<shared_operation::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type =
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod identity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "identity";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::Identity(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			Identity,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Identity(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Identity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Identity(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Identity(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Identity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Identity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Identity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod last_seen {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "last_seen";
		pub type Type =
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			LastSeen,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LastSeen(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LastSeen(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::LastSeen(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LastSeen(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LastSeen(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LastSeen(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LastSeen(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod node_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::NodeId(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			NodeId,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NodeId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NodeId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod node_name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node_name";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::NodeName(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			NodeName,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::NodeName(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeName(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeName(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeName(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeName(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NodeName(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NodeName(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod node_platform {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node_platform";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodePlatform(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			NodePlatform,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::NodePlatform(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodePlatform(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodePlatform(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodePlatform(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodePlatform(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NodePlatform(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NodePlatform(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub identity: Vec<u8>,
		pub node_id: Vec<u8>,
		pub node_name: String,
		pub node_platform: i32,
		pub last_seen:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.instance().create(
				self.pub_id,
				self.identity,
				self.node_id,
				self.node_name,
				self.node_platform,
				self.last_seen,
				self.date_created,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				pub_id::set(self.pub_id),
				identity::set(self.identity),
				node_id::set(self.node_id),
				node_name::set(self.node_name),
				node_platform::set(self.node_platform),
				last_seen::set(self.last_seen),
				date_created::set(self.date_created),
			]);
			self._params
		}
	}
	pub fn create(
		pub_id: Vec<u8>,
		identity: Vec<u8>,
		node_id: Vec<u8>,
		node_name: String,
		node_platform: i32,
		last_seen: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		date_created: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			pub_id,
			identity,
			node_id,
			node_name,
			node_platform,
			last_seen,
			date_created,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub identity: Vec<u8>,
		pub node_id: Vec<u8>,
		pub node_name: String,
		pub node_platform: i32,
		pub last_seen:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.instance().create_unchecked(
				self.pub_id,
				self.identity,
				self.node_id,
				self.node_name,
				self.node_platform,
				self.last_seen,
				self.date_created,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				pub_id::set(self.pub_id),
				identity::set(self.identity),
				node_id::set(self.node_id),
				node_name::set(self.node_name),
				node_platform::set(self.node_platform),
				last_seen::set(self.last_seen),
				date_created::set(self.date_created),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		pub_id: Vec<u8>,
		identity: Vec<u8>,
		node_id: Vec<u8>,
		node_name: String,
		node_platform: i32,
		last_seen: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		date_created: ::prisma_client_rust::chrono::DateTime<
			::prisma_client_rust::chrono::FixedOffset,
		>,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			pub_id,
			identity,
			node_id,
			node_name,
			node_platform,
			last_seen,
			date_created,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(identity::NAME),
				::prisma_client_rust::sel(node_id::NAME),
				::prisma_client_rust::sel(node_name::NAME),
				::prisma_client_rust::sel(node_platform::NAME),
				::prisma_client_rust::sel(last_seen::NAME),
				::prisma_client_rust::sel(date_created::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Instance", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: pub_id::Type,
		#[serde(rename = "identity")]
		pub identity: identity::Type,
		#[serde(rename = "node_id")]
		pub node_id: node_id::Type,
		#[serde(rename = "node_name")]
		pub node_name: node_name::Type,
		#[serde(rename = "node_platform")]
		pub node_platform: node_platform::Type,
		#[serde(rename = "last_seen")]
		pub last_seen: last_seen::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "SharedOperation")]
		#[specta(skip)]
		pub shared_operation: Option<shared_operation::RecursiveSafeType>,
	}
	impl Data {
		pub fn shared_operation(
			&self,
		) -> Result<&shared_operation::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.shared_operation.as_ref().ok_or(
				::prisma_client_rust::RelationNotFetchedError::new(stringify!(shared_operation)),
			)
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_instance { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: instance struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "identity")] pub identity : Vec < u8 > , # [serde (rename = "node_id")] pub node_id : Vec < u8 > , # [serde (rename = "node_name")] pub node_name : String , # [serde (rename = "node_platform")] pub node_platform : i32 , # [serde (rename = "last_seen")] pub last_seen : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_instance as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			pub_id: Vec<u8>,
			identity: Vec<u8>,
			node_id: Vec<u8>,
			node_name: String,
			node_platform: i32,
			last_seen: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
			date_created: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				pub_id::set(pub_id),
				identity::set(identity),
				node_id::set(node_id),
				node_name::set(node_name),
				node_platform::set(node_platform),
				last_seen::set(last_seen),
				date_created::set(date_created),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			identity: Vec<u8>,
			node_id: Vec<u8>,
			node_name: String,
			node_platform: i32,
			last_seen: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
			date_created: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				pub_id::set(pub_id),
				identity::set(identity),
				node_id::set(node_id),
				node_name::set(node_name),
				node_platform::set(node_platform),
				last_seen::set(last_seen),
				date_created::set(date_created),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod statistics {
	use super::_prisma::*;
	pub const NAME: &str = "Statistics";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		DateCaptured(super::_prisma::read_filters::DateTimeFilter),
		TotalObjectCount(super::_prisma::read_filters::IntFilter),
		LibraryDbSize(super::_prisma::read_filters::StringFilter),
		TotalBytesUsed(super::_prisma::read_filters::StringFilter),
		TotalBytesCapacity(super::_prisma::read_filters::StringFilter),
		TotalUniqueBytes(super::_prisma::read_filters::StringFilter),
		TotalBytesFree(super::_prisma::read_filters::StringFilter),
		PreviewMediaBytes(super::_prisma::read_filters::StringFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::DateCaptured(value) => (date_captured::NAME, value.into()),
				Self::TotalObjectCount(value) => (total_object_count::NAME, value.into()),
				Self::LibraryDbSize(value) => (library_db_size::NAME, value.into()),
				Self::TotalBytesUsed(value) => (total_bytes_used::NAME, value.into()),
				Self::TotalBytesCapacity(value) => (total_bytes_capacity::NAME, value.into()),
				Self::TotalUniqueBytes(value) => (total_unique_bytes::NAME, value.into()),
				Self::TotalBytesFree(value) => (total_bytes_free::NAME, value.into()),
				Self::PreviewMediaBytes(value) => (preview_media_bytes::NAME, value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		DateCaptured(super::SortOrder),
		TotalObjectCount(super::SortOrder),
		LibraryDbSize(super::SortOrder),
		TotalBytesUsed(super::SortOrder),
		TotalBytesCapacity(super::SortOrder),
		TotalUniqueBytes(super::SortOrder),
		TotalBytesFree(super::SortOrder),
		PreviewMediaBytes(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::DateCaptured(param) => ("date_captured", param.into()),
				Self::TotalObjectCount(param) => ("total_object_count", param.into()),
				Self::LibraryDbSize(param) => ("library_db_size", param.into()),
				Self::TotalBytesUsed(param) => ("total_bytes_used", param.into()),
				Self::TotalBytesCapacity(param) => ("total_bytes_capacity", param.into()),
				Self::TotalUniqueBytes(param) => ("total_unique_bytes", param.into()),
				Self::TotalBytesFree(param) => ("total_bytes_free", param.into()),
				Self::PreviewMediaBytes(param) => ("preview_media_bytes", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		DateCaptured(super::_prisma::write_params::DateTimeParam),
		TotalObjectCount(super::_prisma::write_params::IntParam),
		LibraryDbSize(super::_prisma::write_params::StringParam),
		TotalBytesUsed(super::_prisma::write_params::StringParam),
		TotalBytesCapacity(super::_prisma::write_params::StringParam),
		TotalUniqueBytes(super::_prisma::write_params::StringParam),
		TotalBytesFree(super::_prisma::write_params::StringParam),
		PreviewMediaBytes(super::_prisma::write_params::StringParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::DateCaptured(value) => (date_captured::NAME, value.into()),
				Self::TotalObjectCount(value) => (total_object_count::NAME, value.into()),
				Self::LibraryDbSize(value) => (library_db_size::NAME, value.into()),
				Self::TotalBytesUsed(value) => (total_bytes_used::NAME, value.into()),
				Self::TotalBytesCapacity(value) => (total_bytes_capacity::NAME, value.into()),
				Self::TotalUniqueBytes(value) => (total_unique_bytes::NAME, value.into()),
				Self::TotalBytesFree(value) => (total_bytes_free::NAME, value.into()),
				Self::PreviewMediaBytes(value) => (preview_media_bytes::NAME, value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		DateCaptured(super::_prisma::write_params::DateTimeParam),
		TotalObjectCount(super::_prisma::write_params::IntParam),
		LibraryDbSize(super::_prisma::write_params::StringParam),
		TotalBytesUsed(super::_prisma::write_params::StringParam),
		TotalBytesCapacity(super::_prisma::write_params::StringParam),
		TotalUniqueBytes(super::_prisma::write_params::StringParam),
		TotalBytesFree(super::_prisma::write_params::StringParam),
		PreviewMediaBytes(super::_prisma::write_params::StringParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::DateCaptured(value) => ("date_captured", value.into()),
				Self::TotalObjectCount(value) => ("total_object_count", value.into()),
				Self::LibraryDbSize(value) => ("library_db_size", value.into()),
				Self::TotalBytesUsed(value) => ("total_bytes_used", value.into()),
				Self::TotalBytesCapacity(value) => ("total_bytes_capacity", value.into()),
				Self::TotalUniqueBytes(value) => ("total_unique_bytes", value.into()),
				Self::TotalBytesFree(value) => ("total_bytes_free", value.into()),
				Self::PreviewMediaBytes(value) => ("preview_media_bytes", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_statistics { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: statistics :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: statistics :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: statistics :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: statistics :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: statistics :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: statistics :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , date_captured , total_object_count , library_db_size , total_bytes_used , total_bytes_capacity , total_unique_bytes , total_bytes_free , preview_media_bytes } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: statistics :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: statistics :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: statistics :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: statistics :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: statistics :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: statistics :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "date_captured" , "total_object_count" , "library_db_size" , "total_bytes_used" , "total_bytes_capacity" , "total_unique_bytes" , "total_bytes_free" , "preview_media_bytes"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: statistics :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: statistics :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Statistics" , available relations are "id, date_captured, total_object_count, library_db_size, total_bytes_used, total_bytes_capacity, total_unique_bytes, total_bytes_free, preview_media_bytes")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: statistics :: SelectParam > :: into (sd_prisma :: prisma :: statistics :: id :: Select) } ; (@ selection_field_to_selection_param ; date_captured) => { Into :: < sd_prisma :: prisma :: statistics :: SelectParam > :: into (sd_prisma :: prisma :: statistics :: date_captured :: Select) } ; (@ selection_field_to_selection_param ; total_object_count) => { Into :: < sd_prisma :: prisma :: statistics :: SelectParam > :: into (sd_prisma :: prisma :: statistics :: total_object_count :: Select) } ; (@ selection_field_to_selection_param ; library_db_size) => { Into :: < sd_prisma :: prisma :: statistics :: SelectParam > :: into (sd_prisma :: prisma :: statistics :: library_db_size :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_used) => { Into :: < sd_prisma :: prisma :: statistics :: SelectParam > :: into (sd_prisma :: prisma :: statistics :: total_bytes_used :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_capacity) => { Into :: < sd_prisma :: prisma :: statistics :: SelectParam > :: into (sd_prisma :: prisma :: statistics :: total_bytes_capacity :: Select) } ; (@ selection_field_to_selection_param ; total_unique_bytes) => { Into :: < sd_prisma :: prisma :: statistics :: SelectParam > :: into (sd_prisma :: prisma :: statistics :: total_unique_bytes :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_free) => { Into :: < sd_prisma :: prisma :: statistics :: SelectParam > :: into (sd_prisma :: prisma :: statistics :: total_bytes_free :: Select) } ; (@ selection_field_to_selection_param ; preview_media_bytes) => { Into :: < sd_prisma :: prisma :: statistics :: SelectParam > :: into (sd_prisma :: prisma :: statistics :: preview_media_bytes :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: statistics :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; date_captured) => { "date_captured" } ; (@ field_serde_name ; total_object_count) => { "total_object_count" } ; (@ field_serde_name ; library_db_size) => { "library_db_size" } ; (@ field_serde_name ; total_bytes_used) => { "total_bytes_used" } ; (@ field_serde_name ; total_bytes_capacity) => { "total_bytes_capacity" } ; (@ field_serde_name ; total_unique_bytes) => { "total_unique_bytes" } ; (@ field_serde_name ; total_bytes_free) => { "total_bytes_free" } ; (@ field_serde_name ; preview_media_bytes) => { "preview_media_bytes" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_statistics as select;
	pub enum SelectParam {
		Id(id::Select),
		DateCaptured(date_captured::Select),
		TotalObjectCount(total_object_count::Select),
		LibraryDbSize(library_db_size::Select),
		TotalBytesUsed(total_bytes_used::Select),
		TotalBytesCapacity(total_bytes_capacity::Select),
		TotalUniqueBytes(total_unique_bytes::Select),
		TotalBytesFree(total_bytes_free::Select),
		PreviewMediaBytes(preview_media_bytes::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::DateCaptured(data) => data.to_selection(),
				Self::TotalObjectCount(data) => data.to_selection(),
				Self::LibraryDbSize(data) => data.to_selection(),
				Self::TotalBytesUsed(data) => data.to_selection(),
				Self::TotalBytesCapacity(data) => data.to_selection(),
				Self::TotalUniqueBytes(data) => data.to_selection(),
				Self::TotalBytesFree(data) => data.to_selection(),
				Self::PreviewMediaBytes(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_statistics { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: statistics :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: statistics :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: statistics :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: statistics :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: statistics :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: statistics :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: statistics :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: statistics :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: statistics :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: statistics :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: statistics :: date_captured :: NAME)] pub date_captured : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = sd_prisma :: prisma :: statistics :: total_object_count :: NAME)] pub total_object_count : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: statistics :: library_db_size :: NAME)] pub library_db_size : String , # [specta (rename_from_path = sd_prisma :: prisma :: statistics :: total_bytes_used :: NAME)] pub total_bytes_used : String , # [specta (rename_from_path = sd_prisma :: prisma :: statistics :: total_bytes_capacity :: NAME)] pub total_bytes_capacity : String , # [specta (rename_from_path = sd_prisma :: prisma :: statistics :: total_unique_bytes :: NAME)] pub total_unique_bytes : String , # [specta (rename_from_path = sd_prisma :: prisma :: statistics :: total_bytes_free :: NAME)] pub total_bytes_free : String , # [specta (rename_from_path = sd_prisma :: prisma :: statistics :: preview_media_bytes :: NAME)] pub preview_media_bytes : String , $ (# [specta (rename_from_path = sd_prisma :: prisma :: statistics :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: statistics :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (date_captured) , stringify ! (total_object_count) , stringify ! (library_db_size) , stringify ! (total_bytes_used) , stringify ! (total_bytes_capacity) , stringify ! (total_unique_bytes) , stringify ! (total_bytes_free) , stringify ! (preview_media_bytes)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: statistics :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: statistics :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: statistics :: date_captured :: NAME , & self . date_captured) ? ; state . serialize_field (sd_prisma :: prisma :: statistics :: total_object_count :: NAME , & self . total_object_count) ? ; state . serialize_field (sd_prisma :: prisma :: statistics :: library_db_size :: NAME , & self . library_db_size) ? ; state . serialize_field (sd_prisma :: prisma :: statistics :: total_bytes_used :: NAME , & self . total_bytes_used) ? ; state . serialize_field (sd_prisma :: prisma :: statistics :: total_bytes_capacity :: NAME , & self . total_bytes_capacity) ? ; state . serialize_field (sd_prisma :: prisma :: statistics :: total_unique_bytes :: NAME , & self . total_unique_bytes) ? ; state . serialize_field (sd_prisma :: prisma :: statistics :: total_bytes_free :: NAME , & self . total_bytes_free) ? ; state . serialize_field (sd_prisma :: prisma :: statistics :: preview_media_bytes :: NAME , & self . preview_media_bytes) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , date_captured , total_object_count , library_db_size , total_bytes_used , total_bytes_capacity , total_unique_bytes , total_bytes_free , preview_media_bytes } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: statistics :: $ field :: NAME) , + , sd_prisma :: prisma :: statistics :: id :: NAME , sd_prisma :: prisma :: statistics :: date_captured :: NAME , sd_prisma :: prisma :: statistics :: total_object_count :: NAME , sd_prisma :: prisma :: statistics :: library_db_size :: NAME , sd_prisma :: prisma :: statistics :: total_bytes_used :: NAME , sd_prisma :: prisma :: statistics :: total_bytes_capacity :: NAME , sd_prisma :: prisma :: statistics :: total_unique_bytes :: NAME , sd_prisma :: prisma :: statistics :: total_bytes_free :: NAME , sd_prisma :: prisma :: statistics :: preview_media_bytes :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: statistics :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: statistics :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: statistics :: date_captured :: NAME => Ok (Field :: date_captured) , sd_prisma :: prisma :: statistics :: total_object_count :: NAME => Ok (Field :: total_object_count) , sd_prisma :: prisma :: statistics :: library_db_size :: NAME => Ok (Field :: library_db_size) , sd_prisma :: prisma :: statistics :: total_bytes_used :: NAME => Ok (Field :: total_bytes_used) , sd_prisma :: prisma :: statistics :: total_bytes_capacity :: NAME => Ok (Field :: total_bytes_capacity) , sd_prisma :: prisma :: statistics :: total_unique_bytes :: NAME => Ok (Field :: total_unique_bytes) , sd_prisma :: prisma :: statistics :: total_bytes_free :: NAME => Ok (Field :: total_bytes_free) , sd_prisma :: prisma :: statistics :: preview_media_bytes :: NAME => Ok (Field :: preview_media_bytes) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut date_captured = None ; let mut total_object_count = None ; let mut library_db_size = None ; let mut total_bytes_used = None ; let mut total_bytes_capacity = None ; let mut total_unique_bytes = None ; let mut total_bytes_free = None ; let mut preview_media_bytes = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: date_captured => { if date_captured . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: date_captured :: NAME)) ; } date_captured = Some (map . next_value () ?) ; } Field :: total_object_count => { if total_object_count . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: total_object_count :: NAME)) ; } total_object_count = Some (map . next_value () ?) ; } Field :: library_db_size => { if library_db_size . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: library_db_size :: NAME)) ; } library_db_size = Some (map . next_value () ?) ; } Field :: total_bytes_used => { if total_bytes_used . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: total_bytes_used :: NAME)) ; } total_bytes_used = Some (map . next_value () ?) ; } Field :: total_bytes_capacity => { if total_bytes_capacity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: total_bytes_capacity :: NAME)) ; } total_bytes_capacity = Some (map . next_value () ?) ; } Field :: total_unique_bytes => { if total_unique_bytes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: total_unique_bytes :: NAME)) ; } total_unique_bytes = Some (map . next_value () ?) ; } Field :: total_bytes_free => { if total_bytes_free . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: total_bytes_free :: NAME)) ; } total_bytes_free = Some (map . next_value () ?) ; } Field :: preview_media_bytes => { if preview_media_bytes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: preview_media_bytes :: NAME)) ; } preview_media_bytes = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: statistics :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: id :: NAME)) ? ; let date_captured = date_captured . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: date_captured :: NAME)) ? ; let total_object_count = total_object_count . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: total_object_count :: NAME)) ? ; let library_db_size = library_db_size . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: library_db_size :: NAME)) ? ; let total_bytes_used = total_bytes_used . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: total_bytes_used :: NAME)) ? ; let total_bytes_capacity = total_bytes_capacity . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: total_bytes_capacity :: NAME)) ? ; let total_unique_bytes = total_unique_bytes . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: total_unique_bytes :: NAME)) ? ; let total_bytes_free = total_bytes_free . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: total_bytes_free :: NAME)) ? ; let preview_media_bytes = preview_media_bytes . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: statistics :: preview_media_bytes :: NAME)) ? ; Ok (Data { id , date_captured , total_object_count , library_db_size , total_bytes_used , total_bytes_capacity , total_unique_bytes , total_bytes_free , preview_media_bytes , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "date_captured" , "total_object_count" , "library_db_size" , "total_bytes_used" , "total_bytes_capacity" , "total_unique_bytes" , "total_bytes_free" , "preview_media_bytes"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: statistics :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: statistics :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Statistics" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: statistics :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; date_captured) => { "date_captured" } ; (@ field_serde_name ; total_object_count) => { "total_object_count" } ; (@ field_serde_name ; library_db_size) => { "library_db_size" } ; (@ field_serde_name ; total_bytes_used) => { "total_bytes_used" } ; (@ field_serde_name ; total_bytes_capacity) => { "total_bytes_capacity" } ; (@ field_serde_name ; total_unique_bytes) => { "total_unique_bytes" } ; (@ field_serde_name ; total_bytes_free) => { "total_bytes_free" } ; (@ field_serde_name ; preview_media_bytes) => { "preview_media_bytes" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_statistics as include;
	pub enum IncludeParam {
		Id(id::Include),
		DateCaptured(date_captured::Include),
		TotalObjectCount(total_object_count::Include),
		LibraryDbSize(library_db_size::Include),
		TotalBytesUsed(total_bytes_used::Include),
		TotalBytesCapacity(total_bytes_capacity::Include),
		TotalUniqueBytes(total_unique_bytes::Include),
		TotalBytesFree(total_bytes_free::Include),
		PreviewMediaBytes(preview_media_bytes::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::DateCaptured(data) => data.to_selection(),
				Self::TotalObjectCount(data) => data.to_selection(),
				Self::LibraryDbSize(data) => data.to_selection(),
				Self::TotalBytesUsed(data) => data.to_selection(),
				Self::TotalBytesCapacity(data) => data.to_selection(),
				Self::TotalUniqueBytes(data) => data.to_selection(),
				Self::TotalBytesFree(data) => data.to_selection(),
				Self::PreviewMediaBytes(data) => data.to_selection(),
			}
		}
	}
	pub mod date_captured {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_captured";
		pub type Type =
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCaptured(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCaptured,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCaptured(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCaptured(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCaptured(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCaptured(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCaptured(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCaptured(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCaptured(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod library_db_size {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "library_db_size";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::LibraryDbSize(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			LibraryDbSize,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LibraryDbSize(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LibraryDbSize(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::LibraryDbSize(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LibraryDbSize(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LibraryDbSize(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LibraryDbSize(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LibraryDbSize(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod preview_media_bytes {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "preview_media_bytes";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::PreviewMediaBytes(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			PreviewMediaBytes,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PreviewMediaBytes(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PreviewMediaBytes(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PreviewMediaBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PreviewMediaBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PreviewMediaBytes(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PreviewMediaBytes(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PreviewMediaBytes(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_capacity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_capacity";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesCapacity(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesCapacity,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesCapacity(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesCapacity(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesCapacity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesCapacity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_free {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_free";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesFree(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesFree,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesFree(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesFree(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesFree(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesFree(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesFree(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesFree(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesFree(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_used {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_used";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesUsed(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesUsed,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesUsed(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesUsed(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesUsed(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesUsed(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesUsed(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesUsed(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesUsed(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_object_count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_object_count";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::TotalObjectCount(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			TotalObjectCount,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalObjectCount(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalObjectCount(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalObjectCount(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalObjectCount(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalObjectCount(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalObjectCount(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalObjectCount(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_unique_bytes {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_unique_bytes";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalUniqueBytes(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalUniqueBytes,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalUniqueBytes(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalUniqueBytes(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalUniqueBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalUniqueBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalUniqueBytes(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalUniqueBytes(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalUniqueBytes(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.statistics().create(self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([]);
			self._params
		}
	}
	pub fn create(_params: Vec<SetParam>) -> Create {
		Create { _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.statistics().create_unchecked(self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([]);
			self._params
		}
	}
	pub fn create_unchecked(_params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(date_captured::NAME),
				::prisma_client_rust::sel(total_object_count::NAME),
				::prisma_client_rust::sel(library_db_size::NAME),
				::prisma_client_rust::sel(total_bytes_used::NAME),
				::prisma_client_rust::sel(total_bytes_capacity::NAME),
				::prisma_client_rust::sel(total_unique_bytes::NAME),
				::prisma_client_rust::sel(total_bytes_free::NAME),
				::prisma_client_rust::sel(preview_media_bytes::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Statistics", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "date_captured")]
		pub date_captured: date_captured::Type,
		#[serde(rename = "total_object_count")]
		pub total_object_count: total_object_count::Type,
		#[serde(rename = "library_db_size")]
		pub library_db_size: library_db_size::Type,
		#[serde(rename = "total_bytes_used")]
		pub total_bytes_used: total_bytes_used::Type,
		#[serde(rename = "total_bytes_capacity")]
		pub total_bytes_capacity: total_bytes_capacity::Type,
		#[serde(rename = "total_unique_bytes")]
		pub total_unique_bytes: total_unique_bytes::Type,
		#[serde(rename = "total_bytes_free")]
		pub total_bytes_free: total_bytes_free::Type,
		#[serde(rename = "preview_media_bytes")]
		pub preview_media_bytes: preview_media_bytes::Type,
	}
	impl Data {}
	#[macro_export]
	macro_rules ! _partial_unchecked_statistics { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: statistics struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "date_captured")] pub date_captured : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "total_object_count")] pub total_object_count : i32 , # [serde (rename = "library_db_size")] pub library_db_size : String , # [serde (rename = "total_bytes_used")] pub total_bytes_used : String , # [serde (rename = "total_bytes_capacity")] pub total_bytes_capacity : String , # [serde (rename = "total_unique_bytes")] pub total_unique_bytes : String , # [serde (rename = "total_bytes_free")] pub total_bytes_free : String , # [serde (rename = "preview_media_bytes")] pub preview_media_bytes : String } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_statistics as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod volume {
	use super::_prisma::*;
	pub const NAME: &str = "Volume";
	pub fn mount_point_name<T: From<UniqueWhereParam>>(mount_point: String, name: String) -> T {
		UniqueWhereParam::MountPointNameEquals(mount_point, name).into()
	}
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		MountPointNameEquals(String, String),
		Id(super::_prisma::read_filters::IntFilter),
		Name(super::_prisma::read_filters::StringFilter),
		MountPoint(super::_prisma::read_filters::StringFilter),
		TotalBytesCapacity(super::_prisma::read_filters::StringFilter),
		TotalBytesAvailable(super::_prisma::read_filters::StringFilter),
		DiskType(super::_prisma::read_filters::StringNullableFilter),
		Filesystem(super::_prisma::read_filters::StringNullableFilter),
		IsSystem(super::_prisma::read_filters::BooleanFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::MountPointNameEquals(mount_point, name) => (
					"mount_point_name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							mount_point::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(mount_point),
						),
						(
							name::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(name),
						),
					]),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::MountPoint(value) => (mount_point::NAME, value.into()),
				Self::TotalBytesCapacity(value) => (total_bytes_capacity::NAME, value.into()),
				Self::TotalBytesAvailable(value) => (total_bytes_available::NAME, value.into()),
				Self::DiskType(value) => (disk_type::NAME, value.into()),
				Self::Filesystem(value) => (filesystem::NAME, value.into()),
				Self::IsSystem(value) => (is_system::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		MountPointNameEquals(String, String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::MountPointNameEquals(mount_point, name) => {
					Self::MountPointNameEquals(mount_point, name)
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		Name(super::SortOrder),
		MountPoint(super::SortOrder),
		TotalBytesCapacity(super::SortOrder),
		TotalBytesAvailable(super::SortOrder),
		DiskType(super::SortOrder),
		Filesystem(super::SortOrder),
		IsSystem(super::SortOrder),
		DateModified(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::MountPoint(param) => ("mount_point", param.into()),
				Self::TotalBytesCapacity(param) => ("total_bytes_capacity", param.into()),
				Self::TotalBytesAvailable(param) => ("total_bytes_available", param.into()),
				Self::DiskType(param) => ("disk_type", param.into()),
				Self::Filesystem(param) => ("filesystem", param.into()),
				Self::IsSystem(param) => ("is_system", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		Name(super::_prisma::write_params::StringParam),
		MountPoint(super::_prisma::write_params::StringParam),
		TotalBytesCapacity(super::_prisma::write_params::StringParam),
		TotalBytesAvailable(super::_prisma::write_params::StringParam),
		DiskType(super::_prisma::write_params::StringNullableParam),
		Filesystem(super::_prisma::write_params::StringNullableParam),
		IsSystem(super::_prisma::write_params::BooleanParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::MountPoint(value) => (mount_point::NAME, value.into()),
				Self::TotalBytesCapacity(value) => (total_bytes_capacity::NAME, value.into()),
				Self::TotalBytesAvailable(value) => (total_bytes_available::NAME, value.into()),
				Self::DiskType(value) => (disk_type::NAME, value.into()),
				Self::Filesystem(value) => (filesystem::NAME, value.into()),
				Self::IsSystem(value) => (is_system::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		Name(super::_prisma::write_params::StringParam),
		MountPoint(super::_prisma::write_params::StringParam),
		TotalBytesCapacity(super::_prisma::write_params::StringParam),
		TotalBytesAvailable(super::_prisma::write_params::StringParam),
		DiskType(super::_prisma::write_params::StringNullableParam),
		Filesystem(super::_prisma::write_params::StringNullableParam),
		IsSystem(super::_prisma::write_params::BooleanParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::MountPoint(value) => ("mount_point", value.into()),
				Self::TotalBytesCapacity(value) => ("total_bytes_capacity", value.into()),
				Self::TotalBytesAvailable(value) => ("total_bytes_available", value.into()),
				Self::DiskType(value) => ("disk_type", value.into()),
				Self::Filesystem(value) => ("filesystem", value.into()),
				Self::IsSystem(value) => ("is_system", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_volume { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: volume :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: volume :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: volume :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: volume :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: volume :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: volume :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , mount_point , total_bytes_capacity , total_bytes_available , disk_type , filesystem , is_system , date_modified } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: volume :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: volume :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: volume :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: volume :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: volume :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: volume :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "mount_point" , "total_bytes_capacity" , "total_bytes_available" , "disk_type" , "filesystem" , "is_system" , "date_modified"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: volume :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: volume :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Volume" , available relations are "id, name, mount_point, total_bytes_capacity, total_bytes_available, disk_type, filesystem, is_system, date_modified")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: volume :: SelectParam > :: into (sd_prisma :: prisma :: volume :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < sd_prisma :: prisma :: volume :: SelectParam > :: into (sd_prisma :: prisma :: volume :: name :: Select) } ; (@ selection_field_to_selection_param ; mount_point) => { Into :: < sd_prisma :: prisma :: volume :: SelectParam > :: into (sd_prisma :: prisma :: volume :: mount_point :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_capacity) => { Into :: < sd_prisma :: prisma :: volume :: SelectParam > :: into (sd_prisma :: prisma :: volume :: total_bytes_capacity :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_available) => { Into :: < sd_prisma :: prisma :: volume :: SelectParam > :: into (sd_prisma :: prisma :: volume :: total_bytes_available :: Select) } ; (@ selection_field_to_selection_param ; disk_type) => { Into :: < sd_prisma :: prisma :: volume :: SelectParam > :: into (sd_prisma :: prisma :: volume :: disk_type :: Select) } ; (@ selection_field_to_selection_param ; filesystem) => { Into :: < sd_prisma :: prisma :: volume :: SelectParam > :: into (sd_prisma :: prisma :: volume :: filesystem :: Select) } ; (@ selection_field_to_selection_param ; is_system) => { Into :: < sd_prisma :: prisma :: volume :: SelectParam > :: into (sd_prisma :: prisma :: volume :: is_system :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < sd_prisma :: prisma :: volume :: SelectParam > :: into (sd_prisma :: prisma :: volume :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: volume :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; mount_point) => { "mount_point" } ; (@ field_serde_name ; total_bytes_capacity) => { "total_bytes_capacity" } ; (@ field_serde_name ; total_bytes_available) => { "total_bytes_available" } ; (@ field_serde_name ; disk_type) => { "disk_type" } ; (@ field_serde_name ; filesystem) => { "filesystem" } ; (@ field_serde_name ; is_system) => { "is_system" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_volume as select;
	pub enum SelectParam {
		Id(id::Select),
		Name(name::Select),
		MountPoint(mount_point::Select),
		TotalBytesCapacity(total_bytes_capacity::Select),
		TotalBytesAvailable(total_bytes_available::Select),
		DiskType(disk_type::Select),
		Filesystem(filesystem::Select),
		IsSystem(is_system::Select),
		DateModified(date_modified::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::MountPoint(data) => data.to_selection(),
				Self::TotalBytesCapacity(data) => data.to_selection(),
				Self::TotalBytesAvailable(data) => data.to_selection(),
				Self::DiskType(data) => data.to_selection(),
				Self::Filesystem(data) => data.to_selection(),
				Self::IsSystem(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_volume { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: volume :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: volume :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: volume :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: volume :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: volume :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: volume :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: volume :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: volume :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: volume :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: volume :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: volume :: name :: NAME)] pub name : String , # [specta (rename_from_path = sd_prisma :: prisma :: volume :: mount_point :: NAME)] pub mount_point : String , # [specta (rename_from_path = sd_prisma :: prisma :: volume :: total_bytes_capacity :: NAME)] pub total_bytes_capacity : String , # [specta (rename_from_path = sd_prisma :: prisma :: volume :: total_bytes_available :: NAME)] pub total_bytes_available : String , # [specta (rename_from_path = sd_prisma :: prisma :: volume :: disk_type :: NAME)] pub disk_type : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: volume :: filesystem :: NAME)] pub filesystem : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: volume :: is_system :: NAME)] pub is_system : bool , # [specta (rename_from_path = sd_prisma :: prisma :: volume :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: volume :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: volume :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (mount_point) , stringify ! (total_bytes_capacity) , stringify ! (total_bytes_available) , stringify ! (disk_type) , stringify ! (filesystem) , stringify ! (is_system) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: volume :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: volume :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: volume :: name :: NAME , & self . name) ? ; state . serialize_field (sd_prisma :: prisma :: volume :: mount_point :: NAME , & self . mount_point) ? ; state . serialize_field (sd_prisma :: prisma :: volume :: total_bytes_capacity :: NAME , & self . total_bytes_capacity) ? ; state . serialize_field (sd_prisma :: prisma :: volume :: total_bytes_available :: NAME , & self . total_bytes_available) ? ; state . serialize_field (sd_prisma :: prisma :: volume :: disk_type :: NAME , & self . disk_type) ? ; state . serialize_field (sd_prisma :: prisma :: volume :: filesystem :: NAME , & self . filesystem) ? ; state . serialize_field (sd_prisma :: prisma :: volume :: is_system :: NAME , & self . is_system) ? ; state . serialize_field (sd_prisma :: prisma :: volume :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , mount_point , total_bytes_capacity , total_bytes_available , disk_type , filesystem , is_system , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: volume :: $ field :: NAME) , + , sd_prisma :: prisma :: volume :: id :: NAME , sd_prisma :: prisma :: volume :: name :: NAME , sd_prisma :: prisma :: volume :: mount_point :: NAME , sd_prisma :: prisma :: volume :: total_bytes_capacity :: NAME , sd_prisma :: prisma :: volume :: total_bytes_available :: NAME , sd_prisma :: prisma :: volume :: disk_type :: NAME , sd_prisma :: prisma :: volume :: filesystem :: NAME , sd_prisma :: prisma :: volume :: is_system :: NAME , sd_prisma :: prisma :: volume :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: volume :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: volume :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: volume :: name :: NAME => Ok (Field :: name) , sd_prisma :: prisma :: volume :: mount_point :: NAME => Ok (Field :: mount_point) , sd_prisma :: prisma :: volume :: total_bytes_capacity :: NAME => Ok (Field :: total_bytes_capacity) , sd_prisma :: prisma :: volume :: total_bytes_available :: NAME => Ok (Field :: total_bytes_available) , sd_prisma :: prisma :: volume :: disk_type :: NAME => Ok (Field :: disk_type) , sd_prisma :: prisma :: volume :: filesystem :: NAME => Ok (Field :: filesystem) , sd_prisma :: prisma :: volume :: is_system :: NAME => Ok (Field :: is_system) , sd_prisma :: prisma :: volume :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut mount_point = None ; let mut total_bytes_capacity = None ; let mut total_bytes_available = None ; let mut disk_type = None ; let mut filesystem = None ; let mut is_system = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: mount_point => { if mount_point . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: mount_point :: NAME)) ; } mount_point = Some (map . next_value () ?) ; } Field :: total_bytes_capacity => { if total_bytes_capacity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: total_bytes_capacity :: NAME)) ; } total_bytes_capacity = Some (map . next_value () ?) ; } Field :: total_bytes_available => { if total_bytes_available . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: total_bytes_available :: NAME)) ; } total_bytes_available = Some (map . next_value () ?) ; } Field :: disk_type => { if disk_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: disk_type :: NAME)) ; } disk_type = Some (map . next_value () ?) ; } Field :: filesystem => { if filesystem . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: filesystem :: NAME)) ; } filesystem = Some (map . next_value () ?) ; } Field :: is_system => { if is_system . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: is_system :: NAME)) ; } is_system = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: volume :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: name :: NAME)) ? ; let mount_point = mount_point . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: mount_point :: NAME)) ? ; let total_bytes_capacity = total_bytes_capacity . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: total_bytes_capacity :: NAME)) ? ; let total_bytes_available = total_bytes_available . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: total_bytes_available :: NAME)) ? ; let disk_type = disk_type . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: disk_type :: NAME)) ? ; let filesystem = filesystem . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: filesystem :: NAME)) ? ; let is_system = is_system . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: is_system :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: volume :: date_modified :: NAME)) ? ; Ok (Data { id , name , mount_point , total_bytes_capacity , total_bytes_available , disk_type , filesystem , is_system , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "mount_point" , "total_bytes_capacity" , "total_bytes_available" , "disk_type" , "filesystem" , "is_system" , "date_modified"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: volume :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: volume :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Volume" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: volume :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; mount_point) => { "mount_point" } ; (@ field_serde_name ; total_bytes_capacity) => { "total_bytes_capacity" } ; (@ field_serde_name ; total_bytes_available) => { "total_bytes_available" } ; (@ field_serde_name ; disk_type) => { "disk_type" } ; (@ field_serde_name ; filesystem) => { "filesystem" } ; (@ field_serde_name ; is_system) => { "is_system" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_volume as include;
	pub enum IncludeParam {
		Id(id::Include),
		Name(name::Include),
		MountPoint(mount_point::Include),
		TotalBytesCapacity(total_bytes_capacity::Include),
		TotalBytesAvailable(total_bytes_available::Include),
		DiskType(disk_type::Include),
		Filesystem(filesystem::Include),
		IsSystem(is_system::Include),
		DateModified(date_modified::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::MountPoint(data) => data.to_selection(),
				Self::TotalBytesCapacity(data) => data.to_selection(),
				Self::TotalBytesAvailable(data) => data.to_selection(),
				Self::DiskType(data) => data.to_selection(),
				Self::Filesystem(data) => data.to_selection(),
				Self::IsSystem(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub type Type =
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod disk_type {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "disk_type";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::DiskType(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			DiskType,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DiskType(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DiskType(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DiskType(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DiskType(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DiskType(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DiskType(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DiskType(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod filesystem {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "filesystem";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Filesystem(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Filesystem,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Filesystem(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Filesystem(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Filesystem(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Filesystem(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Filesystem(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Filesystem(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Filesystem(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod is_system {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "is_system";
		pub type Type = bool;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::IsSystem(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			IsSystem,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IsSystem(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsSystem(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsSystem(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsSystem(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsSystem(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsSystem(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsSystem(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod mount_point {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "mount_point";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::MountPoint(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			MountPoint,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::MountPoint(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MountPoint(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::MountPoint(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::MountPoint(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MountPoint(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::MountPoint(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::MountPoint(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_available {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_available";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesAvailable(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesAvailable,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesAvailable(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesAvailable(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesAvailable(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesAvailable(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesAvailable(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesAvailable(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesAvailable(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_capacity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_capacity";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesCapacity(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesCapacity,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesCapacity(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesCapacity(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesCapacity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesCapacity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub name: String,
		pub mount_point: String,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.volume()
				.create(self.name, self.mount_point, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([name::set(self.name), mount_point::set(self.mount_point)]);
			self._params
		}
	}
	pub fn create(name: String, mount_point: String, _params: Vec<SetParam>) -> Create {
		Create {
			name,
			mount_point,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub name: String,
		pub mount_point: String,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.volume()
				.create_unchecked(self.name, self.mount_point, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([name::set(self.name), mount_point::set(self.mount_point)]);
			self._params
		}
	}
	pub fn create_unchecked(
		name: String,
		mount_point: String,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			name,
			mount_point,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(mount_point::NAME),
				::prisma_client_rust::sel(total_bytes_capacity::NAME),
				::prisma_client_rust::sel(total_bytes_available::NAME),
				::prisma_client_rust::sel(disk_type::NAME),
				::prisma_client_rust::sel(filesystem::NAME),
				::prisma_client_rust::sel(is_system::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Volume", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "name")]
		pub name: name::Type,
		#[serde(rename = "mount_point")]
		pub mount_point: mount_point::Type,
		#[serde(rename = "total_bytes_capacity")]
		pub total_bytes_capacity: total_bytes_capacity::Type,
		#[serde(rename = "total_bytes_available")]
		pub total_bytes_available: total_bytes_available::Type,
		#[serde(rename = "disk_type")]
		pub disk_type: disk_type::Type,
		#[serde(rename = "filesystem")]
		pub filesystem: filesystem::Type,
		#[serde(rename = "is_system")]
		pub is_system: is_system::Type,
		#[serde(rename = "date_modified")]
		pub date_modified: date_modified::Type,
	}
	impl Data {}
	#[macro_export]
	macro_rules ! _partial_unchecked_volume { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: volume struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "name")] pub name : String , # [serde (rename = "mount_point")] pub mount_point : String , # [serde (rename = "total_bytes_capacity")] pub total_bytes_capacity : String , # [serde (rename = "total_bytes_available")] pub total_bytes_available : String , # [serde (rename = "disk_type")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub disk_type : Option < String > , # [serde (rename = "filesystem")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub filesystem : Option < String > , # [serde (rename = "is_system")] pub is_system : bool , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_volume as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			name: String,
			mount_point: String,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([name::set(name), mount_point::set(mount_point)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			name: String,
			mount_point: String,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([name::set(name), mount_point::set(mount_point)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod location {
	use super::_prisma::*;
	pub const NAME: &str = "Location";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		Path(super::_prisma::read_filters::StringNullableFilter),
		TotalCapacity(super::_prisma::read_filters::IntNullableFilter),
		AvailableCapacity(super::_prisma::read_filters::IntNullableFilter),
		IsArchived(super::_prisma::read_filters::BooleanNullableFilter),
		GeneratePreviewMedia(super::_prisma::read_filters::BooleanNullableFilter),
		SyncPreviewMedia(super::_prisma::read_filters::BooleanNullableFilter),
		Hidden(super::_prisma::read_filters::BooleanNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
		InstanceId(super::_prisma::read_filters::IntNullableFilter),
		FilePathsSome(Vec<super::file_path::WhereParam>),
		FilePathsEvery(Vec<super::file_path::WhereParam>),
		FilePathsNone(Vec<super::file_path::WhereParam>),
		IndexerRulesSome(Vec<super::indexer_rules_in_location::WhereParam>),
		IndexerRulesEvery(Vec<super::indexer_rules_in_location::WhereParam>),
		IndexerRulesNone(Vec<super::indexer_rules_in_location::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Path(value) => (path::NAME, value.into()),
				Self::TotalCapacity(value) => (total_capacity::NAME, value.into()),
				Self::AvailableCapacity(value) => (available_capacity::NAME, value.into()),
				Self::IsArchived(value) => (is_archived::NAME, value.into()),
				Self::GeneratePreviewMedia(value) => (generate_preview_media::NAME, value.into()),
				Self::SyncPreviewMedia(value) => (sync_preview_media::NAME, value.into()),
				Self::Hidden(value) => (hidden::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::InstanceId(value) => (instance_id::NAME, value.into()),
				Self::FilePathsSome(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsEvery(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsNone(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRulesSome(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRulesEvery(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRulesNone(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		Path(super::SortOrder),
		TotalCapacity(super::SortOrder),
		AvailableCapacity(super::SortOrder),
		IsArchived(super::SortOrder),
		GeneratePreviewMedia(super::SortOrder),
		SyncPreviewMedia(super::SortOrder),
		Hidden(super::SortOrder),
		DateCreated(super::SortOrder),
		InstanceId(super::SortOrder),
		FilePaths(Vec<super::file_path::OrderByRelationAggregateParam>),
		IndexerRules(Vec<super::indexer_rules_in_location::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Path(param) => ("path", param.into()),
				Self::TotalCapacity(param) => ("total_capacity", param.into()),
				Self::AvailableCapacity(param) => ("available_capacity", param.into()),
				Self::IsArchived(param) => ("is_archived", param.into()),
				Self::GeneratePreviewMedia(param) => ("generate_preview_media", param.into()),
				Self::SyncPreviewMedia(param) => ("sync_preview_media", param.into()),
				Self::Hidden(param) => ("hidden", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::InstanceId(param) => ("instance_id", param.into()),
				Self::FilePaths(param) => (
					"file_paths",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::IndexerRules(param) => (
					"indexer_rules",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		FilePaths(super::file_path::ManyArgs),
		IndexerRules(super::indexer_rules_in_location::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::FilePaths(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						file_paths::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::IndexerRules(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						indexer_rules::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Path(super::_prisma::write_params::StringNullableParam),
		TotalCapacity(super::_prisma::write_params::IntNullableParam),
		AvailableCapacity(super::_prisma::write_params::IntNullableParam),
		IsArchived(super::_prisma::write_params::BooleanNullableParam),
		GeneratePreviewMedia(super::_prisma::write_params::BooleanNullableParam),
		SyncPreviewMedia(super::_prisma::write_params::BooleanNullableParam),
		Hidden(super::_prisma::write_params::BooleanNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		InstanceId(super::_prisma::write_params::IntNullableParam),
		ConnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		DisconnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		SetFilePaths(Vec<super::file_path::UniqueWhereParam>),
		ConnectIndexerRules(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
		DisconnectIndexerRules(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
		SetIndexerRules(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Path(value) => (path::NAME, value.into()),
				Self::TotalCapacity(value) => (total_capacity::NAME, value.into()),
				Self::AvailableCapacity(value) => (available_capacity::NAME, value.into()),
				Self::IsArchived(value) => (is_archived::NAME, value.into()),
				Self::GeneratePreviewMedia(value) => (generate_preview_media::NAME, value.into()),
				Self::SyncPreviewMedia(value) => (sync_preview_media::NAME, value.into()),
				Self::Hidden(value) => (hidden::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::InstanceId(value) => (instance_id::NAME, value.into()),
				Self::ConnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectIndexerRules(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectIndexerRules(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetIndexerRules(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Path(super::_prisma::write_params::StringNullableParam),
		TotalCapacity(super::_prisma::write_params::IntNullableParam),
		AvailableCapacity(super::_prisma::write_params::IntNullableParam),
		IsArchived(super::_prisma::write_params::BooleanNullableParam),
		GeneratePreviewMedia(super::_prisma::write_params::BooleanNullableParam),
		SyncPreviewMedia(super::_prisma::write_params::BooleanNullableParam),
		Hidden(super::_prisma::write_params::BooleanNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		InstanceId(super::_prisma::write_params::IntNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Path(value) => ("path", value.into()),
				Self::TotalCapacity(value) => ("total_capacity", value.into()),
				Self::AvailableCapacity(value) => ("available_capacity", value.into()),
				Self::IsArchived(value) => ("is_archived", value.into()),
				Self::GeneratePreviewMedia(value) => ("generate_preview_media", value.into()),
				Self::SyncPreviewMedia(value) => ("sync_preview_media", value.into()),
				Self::Hidden(value) => ("hidden", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::InstanceId(value) => ("instance_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: location :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: location :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , path , total_capacity , available_capacity , is_archived , generate_preview_media , sync_preview_media , hidden , date_created , instance_id , file_paths , indexer_rules } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: location :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: location :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: location :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: location :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: location :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: location :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "path" , "total_capacity" , "available_capacity" , "is_archived" , "generate_preview_media" , "sync_preview_media" , "hidden" , "date_created" , "instance_id" , "file_paths" , "indexer_rules"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; indexer_rules : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < indexer_rules :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: location :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Location" , available relations are "id, pub_id, name, path, total_capacity, available_capacity, is_archived, generate_preview_media, sync_preview_media, hidden, date_created, instance_id, file_paths, indexer_rules")) } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: file_path :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; indexer_rules : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: name :: Select) } ; (@ selection_field_to_selection_param ; path) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: path :: Select) } ; (@ selection_field_to_selection_param ; total_capacity) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: total_capacity :: Select) } ; (@ selection_field_to_selection_param ; available_capacity) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: available_capacity :: Select) } ; (@ selection_field_to_selection_param ; is_archived) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: is_archived :: Select) } ; (@ selection_field_to_selection_param ; generate_preview_media) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: generate_preview_media :: Select) } ; (@ selection_field_to_selection_param ; sync_preview_media) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: sync_preview_media :: Select) } ; (@ selection_field_to_selection_param ; hidden) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: hidden :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: date_created :: Select) } ; (@ selection_field_to_selection_param ; instance_id) => { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: instance_id :: Select) } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: file_paths :: Select :: $ selection_mode (sd_prisma :: prisma :: file_path :: ManyArgs :: new (sd_prisma :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: file_paths :: Select :: Fetch (sd_prisma :: prisma :: file_path :: ManyArgs :: new (sd_prisma :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; indexer_rules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: indexer_rules :: Select :: $ selection_mode (sd_prisma :: prisma :: indexer_rules_in_location :: ManyArgs :: new (sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; indexer_rules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: location :: SelectParam > :: into (sd_prisma :: prisma :: location :: indexer_rules :: Select :: Fetch (sd_prisma :: prisma :: indexer_rules_in_location :: ManyArgs :: new (sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; total_capacity) => { "total_capacity" } ; (@ field_serde_name ; available_capacity) => { "available_capacity" } ; (@ field_serde_name ; is_archived) => { "is_archived" } ; (@ field_serde_name ; generate_preview_media) => { "generate_preview_media" } ; (@ field_serde_name ; sync_preview_media) => { "sync_preview_media" } ; (@ field_serde_name ; hidden) => { "hidden" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; instance_id) => { "instance_id" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ field_serde_name ; indexer_rules) => { "indexer_rules" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_location as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		Path(path::Select),
		TotalCapacity(total_capacity::Select),
		AvailableCapacity(available_capacity::Select),
		IsArchived(is_archived::Select),
		GeneratePreviewMedia(generate_preview_media::Select),
		SyncPreviewMedia(sync_preview_media::Select),
		Hidden(hidden::Select),
		DateCreated(date_created::Select),
		InstanceId(instance_id::Select),
		FilePaths(file_paths::Select),
		IndexerRules(indexer_rules::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Path(data) => data.to_selection(),
				Self::TotalCapacity(data) => data.to_selection(),
				Self::AvailableCapacity(data) => data.to_selection(),
				Self::IsArchived(data) => data.to_selection(),
				Self::GeneratePreviewMedia(data) => data.to_selection(),
				Self::SyncPreviewMedia(data) => data.to_selection(),
				Self::Hidden(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::InstanceId(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
				Self::IndexerRules(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: location :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: location :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { file_paths , indexer_rules } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: location :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: location :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: location :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: path :: NAME)] pub path : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: total_capacity :: NAME)] pub total_capacity : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: available_capacity :: NAME)] pub available_capacity : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: is_archived :: NAME)] pub is_archived : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: generate_preview_media :: NAME)] pub generate_preview_media : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: sync_preview_media :: NAME)] pub sync_preview_media : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: hidden :: NAME)] pub hidden : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: date_created :: NAME)] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: location :: instance_id :: NAME)] pub instance_id : Option < i32 > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: location :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: location :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (path) , stringify ! (total_capacity) , stringify ! (available_capacity) , stringify ! (is_archived) , stringify ! (generate_preview_media) , stringify ! (sync_preview_media) , stringify ! (hidden) , stringify ! (date_created) , stringify ! (instance_id)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: location :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: location :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: location :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (sd_prisma :: prisma :: location :: name :: NAME , & self . name) ? ; state . serialize_field (sd_prisma :: prisma :: location :: path :: NAME , & self . path) ? ; state . serialize_field (sd_prisma :: prisma :: location :: total_capacity :: NAME , & self . total_capacity) ? ; state . serialize_field (sd_prisma :: prisma :: location :: available_capacity :: NAME , & self . available_capacity) ? ; state . serialize_field (sd_prisma :: prisma :: location :: is_archived :: NAME , & self . is_archived) ? ; state . serialize_field (sd_prisma :: prisma :: location :: generate_preview_media :: NAME , & self . generate_preview_media) ? ; state . serialize_field (sd_prisma :: prisma :: location :: sync_preview_media :: NAME , & self . sync_preview_media) ? ; state . serialize_field (sd_prisma :: prisma :: location :: hidden :: NAME , & self . hidden) ? ; state . serialize_field (sd_prisma :: prisma :: location :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: location :: instance_id :: NAME , & self . instance_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , path , total_capacity , available_capacity , is_archived , generate_preview_media , sync_preview_media , hidden , date_created , instance_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: location :: $ field :: NAME) , + , sd_prisma :: prisma :: location :: id :: NAME , sd_prisma :: prisma :: location :: pub_id :: NAME , sd_prisma :: prisma :: location :: name :: NAME , sd_prisma :: prisma :: location :: path :: NAME , sd_prisma :: prisma :: location :: total_capacity :: NAME , sd_prisma :: prisma :: location :: available_capacity :: NAME , sd_prisma :: prisma :: location :: is_archived :: NAME , sd_prisma :: prisma :: location :: generate_preview_media :: NAME , sd_prisma :: prisma :: location :: sync_preview_media :: NAME , sd_prisma :: prisma :: location :: hidden :: NAME , sd_prisma :: prisma :: location :: date_created :: NAME , sd_prisma :: prisma :: location :: instance_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: location :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: location :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: location :: pub_id :: NAME => Ok (Field :: pub_id) , sd_prisma :: prisma :: location :: name :: NAME => Ok (Field :: name) , sd_prisma :: prisma :: location :: path :: NAME => Ok (Field :: path) , sd_prisma :: prisma :: location :: total_capacity :: NAME => Ok (Field :: total_capacity) , sd_prisma :: prisma :: location :: available_capacity :: NAME => Ok (Field :: available_capacity) , sd_prisma :: prisma :: location :: is_archived :: NAME => Ok (Field :: is_archived) , sd_prisma :: prisma :: location :: generate_preview_media :: NAME => Ok (Field :: generate_preview_media) , sd_prisma :: prisma :: location :: sync_preview_media :: NAME => Ok (Field :: sync_preview_media) , sd_prisma :: prisma :: location :: hidden :: NAME => Ok (Field :: hidden) , sd_prisma :: prisma :: location :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: location :: instance_id :: NAME => Ok (Field :: instance_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut path = None ; let mut total_capacity = None ; let mut available_capacity = None ; let mut is_archived = None ; let mut generate_preview_media = None ; let mut sync_preview_media = None ; let mut hidden = None ; let mut date_created = None ; let mut instance_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: path => { if path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: path :: NAME)) ; } path = Some (map . next_value () ?) ; } Field :: total_capacity => { if total_capacity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: total_capacity :: NAME)) ; } total_capacity = Some (map . next_value () ?) ; } Field :: available_capacity => { if available_capacity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: available_capacity :: NAME)) ; } available_capacity = Some (map . next_value () ?) ; } Field :: is_archived => { if is_archived . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: is_archived :: NAME)) ; } is_archived = Some (map . next_value () ?) ; } Field :: generate_preview_media => { if generate_preview_media . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: generate_preview_media :: NAME)) ; } generate_preview_media = Some (map . next_value () ?) ; } Field :: sync_preview_media => { if sync_preview_media . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: sync_preview_media :: NAME)) ; } sync_preview_media = Some (map . next_value () ?) ; } Field :: hidden => { if hidden . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: hidden :: NAME)) ; } hidden = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: instance_id => { if instance_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: instance_id :: NAME)) ; } instance_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: name :: NAME)) ? ; let path = path . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: path :: NAME)) ? ; let total_capacity = total_capacity . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: total_capacity :: NAME)) ? ; let available_capacity = available_capacity . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: available_capacity :: NAME)) ? ; let is_archived = is_archived . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: is_archived :: NAME)) ? ; let generate_preview_media = generate_preview_media . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: generate_preview_media :: NAME)) ? ; let sync_preview_media = sync_preview_media . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: sync_preview_media :: NAME)) ? ; let hidden = hidden . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: hidden :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: date_created :: NAME)) ? ; let instance_id = instance_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: location :: instance_id :: NAME)) ? ; Ok (Data { id , pub_id , name , path , total_capacity , available_capacity , is_archived , generate_preview_media , sync_preview_media , hidden , date_created , instance_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "path" , "total_capacity" , "available_capacity" , "is_archived" , "generate_preview_media" , "sync_preview_media" , "hidden" , "date_created" , "instance_id" , "file_paths" , "indexer_rules"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; indexer_rules : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < indexer_rules :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: location :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Location" , available relations are "file_paths, indexer_rules")) } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: file_path :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; indexer_rules : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: location :: IncludeParam > :: into (sd_prisma :: prisma :: location :: file_paths :: Include :: $ selection_mode (sd_prisma :: prisma :: file_path :: ManyArgs :: new (sd_prisma :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: location :: IncludeParam > :: into (sd_prisma :: prisma :: location :: file_paths :: Include :: Fetch (sd_prisma :: prisma :: file_path :: ManyArgs :: new (sd_prisma :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; indexer_rules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: location :: IncludeParam > :: into (sd_prisma :: prisma :: location :: indexer_rules :: Include :: $ selection_mode (sd_prisma :: prisma :: indexer_rules_in_location :: ManyArgs :: new (sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; indexer_rules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: location :: IncludeParam > :: into (sd_prisma :: prisma :: location :: indexer_rules :: Include :: Fetch (sd_prisma :: prisma :: indexer_rules_in_location :: ManyArgs :: new (sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; total_capacity) => { "total_capacity" } ; (@ field_serde_name ; available_capacity) => { "available_capacity" } ; (@ field_serde_name ; is_archived) => { "is_archived" } ; (@ field_serde_name ; generate_preview_media) => { "generate_preview_media" } ; (@ field_serde_name ; sync_preview_media) => { "sync_preview_media" } ; (@ field_serde_name ; hidden) => { "hidden" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; instance_id) => { "instance_id" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ field_serde_name ; indexer_rules) => { "indexer_rules" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_location as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		Path(path::Include),
		TotalCapacity(total_capacity::Include),
		AvailableCapacity(available_capacity::Include),
		IsArchived(is_archived::Include),
		GeneratePreviewMedia(generate_preview_media::Include),
		SyncPreviewMedia(sync_preview_media::Include),
		Hidden(hidden::Include),
		DateCreated(date_created::Include),
		InstanceId(instance_id::Include),
		FilePaths(file_paths::Include),
		IndexerRules(indexer_rules::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Path(data) => data.to_selection(),
				Self::TotalCapacity(data) => data.to_selection(),
				Self::AvailableCapacity(data) => data.to_selection(),
				Self::IsArchived(data) => data.to_selection(),
				Self::GeneratePreviewMedia(data) => data.to_selection(),
				Self::SyncPreviewMedia(data) => data.to_selection(),
				Self::Hidden(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::InstanceId(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
				Self::IndexerRules(data) => data.to_selection(),
			}
		}
	}
	pub mod available_capacity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "available_capacity";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::AvailableCapacity(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			AvailableCapacity,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::AvailableCapacity(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::AvailableCapacity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::AvailableCapacity(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::AvailableCapacity(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::AvailableCapacity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::AvailableCapacity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::AvailableCapacity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod file_paths {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "file_paths";
		pub type Type = Vec<file_path::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsSome(value)
		}
		pub fn every(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsEvery(value)
		}
		pub fn none(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsNone(value)
		}
		pub struct Order(Vec<file_path::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<file_path::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::FilePaths(v)
			}
		}
		pub struct Fetch(pub file_path::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: file_path::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: file_path::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::FilePaths(v)
			}
		}
		pub fn fetch(params: Vec<file_path::WhereParam>) -> Fetch {
			Fetch(file_path::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<file_path::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectFilePaths(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<file_path::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectFilePaths(params)
		}
		pub fn set(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::SetFilePaths(params)
		}
		pub enum Select {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::FilePaths(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::FilePaths(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = < file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod generate_preview_media {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "generate_preview_media";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::GeneratePreviewMedia(_prisma::read_filters::BooleanNullableFilter::Equals(
				value,
			))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			GeneratePreviewMedia,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::GeneratePreviewMedia(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::GeneratePreviewMedia(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::GeneratePreviewMedia(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::GeneratePreviewMedia(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::GeneratePreviewMedia(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::GeneratePreviewMedia(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::GeneratePreviewMedia(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod hidden {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "hidden";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::Hidden(_prisma::read_filters::BooleanNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			Hidden,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Hidden(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Hidden(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Hidden(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Hidden(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Hidden(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Hidden(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Hidden(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod indexer_rules {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "indexer_rules";
		pub type Type = Vec<indexer_rules_in_location::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::IndexerRulesSome(value)
		}
		pub fn every(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::IndexerRulesEvery(value)
		}
		pub fn none(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::IndexerRulesNone(value)
		}
		pub struct Order(Vec<indexer_rules_in_location::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(
			v: Vec<indexer_rules_in_location::OrderByRelationAggregateParam>,
		) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IndexerRules(v)
			}
		}
		pub struct Fetch(pub indexer_rules_in_location::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<indexer_rules_in_location::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(
				mut self,
				param: indexer_rules_in_location::OrderByWithRelationParam,
			) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: indexer_rules_in_location::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::IndexerRules(v)
			}
		}
		pub fn fetch(params: Vec<indexer_rules_in_location::WhereParam>) -> Fetch {
			Fetch(indexer_rules_in_location::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<indexer_rules_in_location::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectIndexerRules(v)
			}
		}
		pub fn connect<T: From<Connect>>(
			params: Vec<indexer_rules_in_location::UniqueWhereParam>,
		) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectIndexerRules(params)
		}
		pub fn set(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
			SetParam::SetIndexerRules(params)
		}
		pub enum Select {
			Select(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::SelectParam>,
			),
			Include(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::IncludeParam>,
			),
			Fetch(indexer_rules_in_location::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IndexerRules(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::SelectParam>,
			),
			Include(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::IncludeParam>,
			),
			Fetch(indexer_rules_in_location::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IndexerRules(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod instance_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "instance_id";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::InstanceId(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			InstanceId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::InstanceId(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::InstanceId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::InstanceId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::InstanceId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::InstanceId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::InstanceId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::InstanceId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod is_archived {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "is_archived";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::IsArchived(_prisma::read_filters::BooleanNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			IsArchived,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IsArchived(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsArchived(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsArchived(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsArchived(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsArchived(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsArchived(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsArchived(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod path {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "path";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Path,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Path(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Path(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Path(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Path(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Path(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Path(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Path(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod sync_preview_media {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "sync_preview_media";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::SyncPreviewMedia(_prisma::read_filters::BooleanNullableFilter::Equals(
				value,
			))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			SyncPreviewMedia,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::SyncPreviewMedia(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SyncPreviewMedia(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::SyncPreviewMedia(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::SyncPreviewMedia(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SyncPreviewMedia(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SyncPreviewMedia(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SyncPreviewMedia(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_capacity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_capacity";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::TotalCapacity(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			TotalCapacity,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalCapacity(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalCapacity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalCapacity(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalCapacity(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalCapacity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalCapacity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalCapacity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.location().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.location()
				.create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(path::NAME),
				::prisma_client_rust::sel(total_capacity::NAME),
				::prisma_client_rust::sel(available_capacity::NAME),
				::prisma_client_rust::sel(is_archived::NAME),
				::prisma_client_rust::sel(generate_preview_media::NAME),
				::prisma_client_rust::sel(sync_preview_media::NAME),
				::prisma_client_rust::sel(hidden::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(instance_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Location", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: pub_id::Type,
		#[serde(rename = "name")]
		pub name: name::Type,
		#[serde(rename = "path")]
		pub path: path::Type,
		#[serde(rename = "total_capacity")]
		pub total_capacity: total_capacity::Type,
		#[serde(rename = "available_capacity")]
		pub available_capacity: available_capacity::Type,
		#[serde(rename = "is_archived")]
		pub is_archived: is_archived::Type,
		#[serde(rename = "generate_preview_media")]
		pub generate_preview_media: generate_preview_media::Type,
		#[serde(rename = "sync_preview_media")]
		pub sync_preview_media: sync_preview_media::Type,
		#[serde(rename = "hidden")]
		pub hidden: hidden::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "instance_id")]
		pub instance_id: instance_id::Type,
		#[serde(rename = "file_paths")]
		#[specta(skip)]
		pub file_paths: Option<file_paths::RecursiveSafeType>,
		#[serde(rename = "indexer_rules")]
		#[specta(skip)]
		pub indexer_rules: Option<indexer_rules::RecursiveSafeType>,
	}
	impl Data {
		pub fn file_paths(
			&self,
		) -> Result<&file_paths::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.file_paths
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(file_paths),
				))
		}
		pub fn indexer_rules(
			&self,
		) -> Result<&indexer_rules::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.indexer_rules
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(indexer_rules),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_location { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: location struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "path")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub path : Option < String > , # [serde (rename = "total_capacity")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub total_capacity : Option < i32 > , # [serde (rename = "available_capacity")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub available_capacity : Option < i32 > , # [serde (rename = "is_archived")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub is_archived : Option < bool > , # [serde (rename = "generate_preview_media")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub generate_preview_media : Option < bool > , # [serde (rename = "sync_preview_media")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub sync_preview_media : Option < bool > , # [serde (rename = "hidden")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub hidden : Option < bool > , # [serde (rename = "date_created")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "instance_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub instance_id : Option < i32 > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_location as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod file_path {
	use super::_prisma::*;
	pub const NAME: &str = "FilePath";
	pub fn location_id_materialized_path_name_extension<T: From<UniqueWhereParam>>(
		location_id: i32,
		materialized_path: String,
		name: String,
		extension: String,
	) -> T {
		UniqueWhereParam::LocationIdMaterializedPathNameExtensionEquals(
			location_id,
			materialized_path,
			name,
			extension,
		)
		.into()
	}
	pub fn location_id_inode_device<T: From<UniqueWhereParam>>(
		location_id: i32,
		inode: Vec<u8>,
		device: Vec<u8>,
	) -> T {
		UniqueWhereParam::LocationIdInodeDeviceEquals(location_id, inode, device).into()
	}
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LocationIdMaterializedPathNameExtensionEquals(i32, String, String, String),
		LocationIdInodeDeviceEquals(i32, Vec<u8>, Vec<u8>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		IsDir(super::_prisma::read_filters::BooleanNullableFilter),
		CasId(super::_prisma::read_filters::StringNullableFilter),
		IntegrityChecksum(super::_prisma::read_filters::StringNullableFilter),
		LocationId(super::_prisma::read_filters::IntNullableFilter),
		LocationIsNull,
		LocationIs(Vec<super::location::WhereParam>),
		LocationIsNot(Vec<super::location::WhereParam>),
		MaterializedPath(super::_prisma::read_filters::StringNullableFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		Extension(super::_prisma::read_filters::StringNullableFilter),
		SizeInBytes(super::_prisma::read_filters::StringNullableFilter),
		SizeInBytesBytes(super::_prisma::read_filters::BytesNullableFilter),
		Inode(super::_prisma::read_filters::BytesNullableFilter),
		Device(super::_prisma::read_filters::BytesNullableFilter),
		ObjectId(super::_prisma::read_filters::IntNullableFilter),
		ObjectIsNull,
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
		KeyId(super::_prisma::read_filters::IntNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
		DateModified(super::_prisma::read_filters::DateTimeNullableFilter),
		DateIndexed(super::_prisma::read_filters::DateTimeNullableFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::LocationIdMaterializedPathNameExtensionEquals(
					location_id,
					materialized_path,
					name,
					extension,
				) => (
					"location_id_materialized_path_name_extension",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							location_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(location_id as i64),
						),
						(
							materialized_path::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(materialized_path),
						),
						(
							name::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(name),
						),
						(
							extension::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(extension),
						),
					]),
				),
				Self::LocationIdInodeDeviceEquals(location_id, inode, device) => (
					"location_id_inode_device",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							location_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(location_id as i64),
						),
						(
							inode::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Bytes(inode),
						),
						(
							device::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Bytes(device),
						),
					]),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::IsDir(value) => (is_dir::NAME, value.into()),
				Self::CasId(value) => (cas_id::NAME, value.into()),
				Self::IntegrityChecksum(value) => (integrity_checksum::NAME, value.into()),
				Self::LocationId(value) => (location_id::NAME, value.into()),
				Self::LocationIsNull => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::LocationIs(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationIsNot(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::MaterializedPath(value) => (materialized_path::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Extension(value) => (extension::NAME, value.into()),
				Self::SizeInBytes(value) => (size_in_bytes::NAME, value.into()),
				Self::SizeInBytesBytes(value) => (size_in_bytes_bytes::NAME, value.into()),
				Self::Inode(value) => (inode::NAME, value.into()),
				Self::Device(value) => (device::NAME, value.into()),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIsNull => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::KeyId(value) => (key_id::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::DateIndexed(value) => (date_indexed::NAME, value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		LocationIdMaterializedPathNameExtensionEquals(i32, String, String, String),
		LocationIdInodeDeviceEquals(i32, Vec<u8>, Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::LocationIdMaterializedPathNameExtensionEquals(
					location_id,
					materialized_path,
					name,
					extension,
				) => Self::LocationIdMaterializedPathNameExtensionEquals(
					location_id,
					materialized_path,
					name,
					extension,
				),
				UniqueWhereParam::LocationIdInodeDeviceEquals(location_id, inode, device) => {
					Self::LocationIdInodeDeviceEquals(location_id, inode, device)
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		IsDir(super::SortOrder),
		CasId(super::SortOrder),
		IntegrityChecksum(super::SortOrder),
		LocationId(super::SortOrder),
		MaterializedPath(super::SortOrder),
		Name(super::SortOrder),
		Extension(super::SortOrder),
		SizeInBytes(super::SortOrder),
		SizeInBytesBytes(super::SortOrder),
		Inode(super::SortOrder),
		Device(super::SortOrder),
		ObjectId(super::SortOrder),
		KeyId(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		DateIndexed(super::SortOrder),
		Location(Vec<super::location::OrderByWithRelationParam>),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::IsDir(param) => ("is_dir", param.into()),
				Self::CasId(param) => ("cas_id", param.into()),
				Self::IntegrityChecksum(param) => ("integrity_checksum", param.into()),
				Self::LocationId(param) => ("location_id", param.into()),
				Self::MaterializedPath(param) => ("materialized_path", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Extension(param) => ("extension", param.into()),
				Self::SizeInBytes(param) => ("size_in_bytes", param.into()),
				Self::SizeInBytesBytes(param) => ("size_in_bytes_bytes", param.into()),
				Self::Inode(param) => ("inode", param.into()),
				Self::Device(param) => ("device", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::KeyId(param) => ("key_id", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::DateIndexed(param) => ("date_indexed", param.into()),
				Self::Location(param) => (
					"location",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Location(super::location::UniqueArgs),
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Location(args) => {
					let mut selections = < super :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(location::NAME, None, [], selections)
				}
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		IsDir(super::_prisma::write_params::BooleanNullableParam),
		CasId(super::_prisma::write_params::StringNullableParam),
		IntegrityChecksum(super::_prisma::write_params::StringNullableParam),
		LocationId(super::_prisma::write_params::IntNullableParam),
		ConnectLocation(super::location::UniqueWhereParam),
		DisconnectLocation,
		MaterializedPath(super::_prisma::write_params::StringNullableParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Extension(super::_prisma::write_params::StringNullableParam),
		SizeInBytes(super::_prisma::write_params::StringNullableParam),
		SizeInBytesBytes(super::_prisma::write_params::BytesNullableParam),
		Inode(super::_prisma::write_params::BytesNullableParam),
		Device(super::_prisma::write_params::BytesNullableParam),
		ObjectId(super::_prisma::write_params::IntNullableParam),
		ConnectObject(super::object::UniqueWhereParam),
		DisconnectObject,
		KeyId(super::_prisma::write_params::IntNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateModified(super::_prisma::write_params::DateTimeNullableParam),
		DateIndexed(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::IsDir(value) => (is_dir::NAME, value.into()),
				Self::CasId(value) => (cas_id::NAME, value.into()),
				Self::IntegrityChecksum(value) => (integrity_checksum::NAME, value.into()),
				Self::LocationId(value) => (location_id::NAME, value.into()),
				Self::ConnectLocation(where_param) => (
					location::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectLocation => (
					location::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
				Self::MaterializedPath(value) => (materialized_path::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Extension(value) => (extension::NAME, value.into()),
				Self::SizeInBytes(value) => (size_in_bytes::NAME, value.into()),
				Self::SizeInBytesBytes(value) => (size_in_bytes_bytes::NAME, value.into()),
				Self::Inode(value) => (inode::NAME, value.into()),
				Self::Device(value) => (device::NAME, value.into()),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectObject => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
				Self::KeyId(value) => (key_id::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::DateIndexed(value) => (date_indexed::NAME, value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		IsDir(super::_prisma::write_params::BooleanNullableParam),
		CasId(super::_prisma::write_params::StringNullableParam),
		IntegrityChecksum(super::_prisma::write_params::StringNullableParam),
		LocationId(super::_prisma::write_params::IntNullableParam),
		MaterializedPath(super::_prisma::write_params::StringNullableParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Extension(super::_prisma::write_params::StringNullableParam),
		SizeInBytes(super::_prisma::write_params::StringNullableParam),
		SizeInBytesBytes(super::_prisma::write_params::BytesNullableParam),
		Inode(super::_prisma::write_params::BytesNullableParam),
		Device(super::_prisma::write_params::BytesNullableParam),
		ObjectId(super::_prisma::write_params::IntNullableParam),
		KeyId(super::_prisma::write_params::IntNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateModified(super::_prisma::write_params::DateTimeNullableParam),
		DateIndexed(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::IsDir(value) => ("is_dir", value.into()),
				Self::CasId(value) => ("cas_id", value.into()),
				Self::IntegrityChecksum(value) => ("integrity_checksum", value.into()),
				Self::LocationId(value) => ("location_id", value.into()),
				Self::MaterializedPath(value) => ("materialized_path", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Extension(value) => ("extension", value.into()),
				Self::SizeInBytes(value) => ("size_in_bytes", value.into()),
				Self::SizeInBytesBytes(value) => ("size_in_bytes_bytes", value.into()),
				Self::Inode(value) => ("inode", value.into()),
				Self::Device(value) => ("device", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
				Self::KeyId(value) => ("key_id", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
				Self::DateIndexed(value) => ("date_indexed", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_file_path { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: file_path :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: file_path :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: file_path :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: file_path :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , is_dir , cas_id , integrity_checksum , location_id , location , materialized_path , name , extension , size_in_bytes , size_in_bytes_bytes , inode , device , object_id , object , key_id , date_created , date_modified , date_indexed } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: file_path :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: file_path :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: file_path :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: file_path :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: file_path :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: file_path :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "is_dir" , "cas_id" , "integrity_checksum" , "location_id" , "location" , "materialized_path" , "name" , "extension" , "size_in_bytes" , "size_in_bytes_bytes" , "inode" , "device" , "object_id" , "object" , "key_id" , "date_created" , "date_modified" , "date_indexed"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: file_path :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < location :: Data > } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: file_path :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FilePath" , available relations are "id, pub_id, is_dir, cas_id, integrity_checksum, location_id, location, materialized_path, name, extension, size_in_bytes, size_in_bytes_bytes, inode, device, object_id, object, key_id, date_created, date_modified, date_indexed")) } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; is_dir) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: is_dir :: Select) } ; (@ selection_field_to_selection_param ; cas_id) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: cas_id :: Select) } ; (@ selection_field_to_selection_param ; integrity_checksum) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: integrity_checksum :: Select) } ; (@ selection_field_to_selection_param ; location_id) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: location_id :: Select) } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: location :: Select :: $ selection_mode (sd_prisma :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: location :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; materialized_path) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: materialized_path :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: name :: Select) } ; (@ selection_field_to_selection_param ; extension) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: extension :: Select) } ; (@ selection_field_to_selection_param ; size_in_bytes) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: size_in_bytes :: Select) } ; (@ selection_field_to_selection_param ; size_in_bytes_bytes) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: size_in_bytes_bytes :: Select) } ; (@ selection_field_to_selection_param ; inode) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: inode :: Select) } ; (@ selection_field_to_selection_param ; device) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: device :: Select) } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: object :: Select :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; key_id) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: key_id :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; date_indexed) => { Into :: < sd_prisma :: prisma :: file_path :: SelectParam > :: into (sd_prisma :: prisma :: file_path :: date_indexed :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: file_path :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; is_dir) => { "is_dir" } ; (@ field_serde_name ; cas_id) => { "cas_id" } ; (@ field_serde_name ; integrity_checksum) => { "integrity_checksum" } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; location) => { "location" } ; (@ field_serde_name ; materialized_path) => { "materialized_path" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; extension) => { "extension" } ; (@ field_serde_name ; size_in_bytes) => { "size_in_bytes" } ; (@ field_serde_name ; size_in_bytes_bytes) => { "size_in_bytes_bytes" } ; (@ field_serde_name ; inode) => { "inode" } ; (@ field_serde_name ; device) => { "device" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ field_serde_name ; key_id) => { "key_id" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; date_indexed) => { "date_indexed" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_file_path as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		IsDir(is_dir::Select),
		CasId(cas_id::Select),
		IntegrityChecksum(integrity_checksum::Select),
		LocationId(location_id::Select),
		Location(location::Select),
		MaterializedPath(materialized_path::Select),
		Name(name::Select),
		Extension(extension::Select),
		SizeInBytes(size_in_bytes::Select),
		SizeInBytesBytes(size_in_bytes_bytes::Select),
		Inode(inode::Select),
		Device(device::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
		KeyId(key_id::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		DateIndexed(date_indexed::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::IsDir(data) => data.to_selection(),
				Self::CasId(data) => data.to_selection(),
				Self::IntegrityChecksum(data) => data.to_selection(),
				Self::LocationId(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::MaterializedPath(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Extension(data) => data.to_selection(),
				Self::SizeInBytes(data) => data.to_selection(),
				Self::SizeInBytesBytes(data) => data.to_selection(),
				Self::Inode(data) => data.to_selection(),
				Self::Device(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
				Self::KeyId(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::DateIndexed(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_file_path { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: file_path :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: file_path :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: file_path :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: file_path :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { location , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: file_path :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: is_dir :: NAME)] pub is_dir : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: cas_id :: NAME)] pub cas_id : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: integrity_checksum :: NAME)] pub integrity_checksum : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: location_id :: NAME)] pub location_id : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: materialized_path :: NAME)] pub materialized_path : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: extension :: NAME)] pub extension : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: size_in_bytes :: NAME)] pub size_in_bytes : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: size_in_bytes_bytes :: NAME)] pub size_in_bytes_bytes : Option < Vec < u8 > > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: inode :: NAME)] pub inode : Option < Vec < u8 > > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: device :: NAME)] pub device : Option < Vec < u8 > > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: object_id :: NAME)] pub object_id : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: key_id :: NAME)] pub key_id : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: date_created :: NAME)] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: date_modified :: NAME)] pub date_modified : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: file_path :: date_indexed :: NAME)] pub date_indexed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: file_path :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: file_path :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (is_dir) , stringify ! (cas_id) , stringify ! (integrity_checksum) , stringify ! (location_id) , stringify ! (materialized_path) , stringify ! (name) , stringify ! (extension) , stringify ! (size_in_bytes) , stringify ! (size_in_bytes_bytes) , stringify ! (inode) , stringify ! (device) , stringify ! (object_id) , stringify ! (key_id) , stringify ! (date_created) , stringify ! (date_modified) , stringify ! (date_indexed)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: file_path :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: file_path :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: is_dir :: NAME , & self . is_dir) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: cas_id :: NAME , & self . cas_id) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: integrity_checksum :: NAME , & self . integrity_checksum) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: location_id :: NAME , & self . location_id) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: materialized_path :: NAME , & self . materialized_path) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: name :: NAME , & self . name) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: extension :: NAME , & self . extension) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: size_in_bytes :: NAME , & self . size_in_bytes) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: size_in_bytes_bytes :: NAME , & self . size_in_bytes_bytes) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: inode :: NAME , & self . inode) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: device :: NAME , & self . device) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: object_id :: NAME , & self . object_id) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: key_id :: NAME , & self . key_id) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: date_modified :: NAME , & self . date_modified) ? ; state . serialize_field (sd_prisma :: prisma :: file_path :: date_indexed :: NAME , & self . date_indexed) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , is_dir , cas_id , integrity_checksum , location_id , materialized_path , name , extension , size_in_bytes , size_in_bytes_bytes , inode , device , object_id , key_id , date_created , date_modified , date_indexed } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: file_path :: $ field :: NAME) , + , sd_prisma :: prisma :: file_path :: id :: NAME , sd_prisma :: prisma :: file_path :: pub_id :: NAME , sd_prisma :: prisma :: file_path :: is_dir :: NAME , sd_prisma :: prisma :: file_path :: cas_id :: NAME , sd_prisma :: prisma :: file_path :: integrity_checksum :: NAME , sd_prisma :: prisma :: file_path :: location_id :: NAME , sd_prisma :: prisma :: file_path :: materialized_path :: NAME , sd_prisma :: prisma :: file_path :: name :: NAME , sd_prisma :: prisma :: file_path :: extension :: NAME , sd_prisma :: prisma :: file_path :: size_in_bytes :: NAME , sd_prisma :: prisma :: file_path :: size_in_bytes_bytes :: NAME , sd_prisma :: prisma :: file_path :: inode :: NAME , sd_prisma :: prisma :: file_path :: device :: NAME , sd_prisma :: prisma :: file_path :: object_id :: NAME , sd_prisma :: prisma :: file_path :: key_id :: NAME , sd_prisma :: prisma :: file_path :: date_created :: NAME , sd_prisma :: prisma :: file_path :: date_modified :: NAME , sd_prisma :: prisma :: file_path :: date_indexed :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: file_path :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: file_path :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: file_path :: pub_id :: NAME => Ok (Field :: pub_id) , sd_prisma :: prisma :: file_path :: is_dir :: NAME => Ok (Field :: is_dir) , sd_prisma :: prisma :: file_path :: cas_id :: NAME => Ok (Field :: cas_id) , sd_prisma :: prisma :: file_path :: integrity_checksum :: NAME => Ok (Field :: integrity_checksum) , sd_prisma :: prisma :: file_path :: location_id :: NAME => Ok (Field :: location_id) , sd_prisma :: prisma :: file_path :: materialized_path :: NAME => Ok (Field :: materialized_path) , sd_prisma :: prisma :: file_path :: name :: NAME => Ok (Field :: name) , sd_prisma :: prisma :: file_path :: extension :: NAME => Ok (Field :: extension) , sd_prisma :: prisma :: file_path :: size_in_bytes :: NAME => Ok (Field :: size_in_bytes) , sd_prisma :: prisma :: file_path :: size_in_bytes_bytes :: NAME => Ok (Field :: size_in_bytes_bytes) , sd_prisma :: prisma :: file_path :: inode :: NAME => Ok (Field :: inode) , sd_prisma :: prisma :: file_path :: device :: NAME => Ok (Field :: device) , sd_prisma :: prisma :: file_path :: object_id :: NAME => Ok (Field :: object_id) , sd_prisma :: prisma :: file_path :: key_id :: NAME => Ok (Field :: key_id) , sd_prisma :: prisma :: file_path :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: file_path :: date_modified :: NAME => Ok (Field :: date_modified) , sd_prisma :: prisma :: file_path :: date_indexed :: NAME => Ok (Field :: date_indexed) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut is_dir = None ; let mut cas_id = None ; let mut integrity_checksum = None ; let mut location_id = None ; let mut materialized_path = None ; let mut name = None ; let mut extension = None ; let mut size_in_bytes = None ; let mut size_in_bytes_bytes = None ; let mut inode = None ; let mut device = None ; let mut object_id = None ; let mut key_id = None ; let mut date_created = None ; let mut date_modified = None ; let mut date_indexed = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: is_dir => { if is_dir . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: is_dir :: NAME)) ; } is_dir = Some (map . next_value () ?) ; } Field :: cas_id => { if cas_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: cas_id :: NAME)) ; } cas_id = Some (map . next_value () ?) ; } Field :: integrity_checksum => { if integrity_checksum . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: integrity_checksum :: NAME)) ; } integrity_checksum = Some (map . next_value () ?) ; } Field :: location_id => { if location_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: location_id :: NAME)) ; } location_id = Some (map . next_value () ?) ; } Field :: materialized_path => { if materialized_path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: materialized_path :: NAME)) ; } materialized_path = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: extension => { if extension . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: extension :: NAME)) ; } extension = Some (map . next_value () ?) ; } Field :: size_in_bytes => { if size_in_bytes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: size_in_bytes :: NAME)) ; } size_in_bytes = Some (map . next_value () ?) ; } Field :: size_in_bytes_bytes => { if size_in_bytes_bytes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: size_in_bytes_bytes :: NAME)) ; } size_in_bytes_bytes = Some (map . next_value () ?) ; } Field :: inode => { if inode . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: inode :: NAME)) ; } inode = Some (map . next_value () ?) ; } Field :: device => { if device . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: device :: NAME)) ; } device = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } Field :: key_id => { if key_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: key_id :: NAME)) ; } key_id = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } Field :: date_indexed => { if date_indexed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: date_indexed :: NAME)) ; } date_indexed = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: file_path :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: pub_id :: NAME)) ? ; let is_dir = is_dir . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: is_dir :: NAME)) ? ; let cas_id = cas_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: cas_id :: NAME)) ? ; let integrity_checksum = integrity_checksum . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: integrity_checksum :: NAME)) ? ; let location_id = location_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: location_id :: NAME)) ? ; let materialized_path = materialized_path . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: materialized_path :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: name :: NAME)) ? ; let extension = extension . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: extension :: NAME)) ? ; let size_in_bytes = size_in_bytes . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: size_in_bytes :: NAME)) ? ; let size_in_bytes_bytes = size_in_bytes_bytes . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: size_in_bytes_bytes :: NAME)) ? ; let inode = inode . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: inode :: NAME)) ? ; let device = device . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: device :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: object_id :: NAME)) ? ; let key_id = key_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: key_id :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: date_modified :: NAME)) ? ; let date_indexed = date_indexed . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: file_path :: date_indexed :: NAME)) ? ; Ok (Data { id , pub_id , is_dir , cas_id , integrity_checksum , location_id , materialized_path , name , extension , size_in_bytes , size_in_bytes_bytes , inode , device , object_id , key_id , date_created , date_modified , date_indexed , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "is_dir" , "cas_id" , "integrity_checksum" , "location_id" , "location" , "materialized_path" , "name" , "extension" , "size_in_bytes" , "size_in_bytes_bytes" , "inode" , "device" , "object_id" , "object" , "key_id" , "date_created" , "date_modified" , "date_indexed"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: file_path :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < location :: Data > } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: file_path :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FilePath" , available relations are "location, object")) } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: file_path :: IncludeParam > :: into (sd_prisma :: prisma :: file_path :: location :: Include :: $ selection_mode (sd_prisma :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: file_path :: IncludeParam > :: into (sd_prisma :: prisma :: file_path :: location :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: file_path :: IncludeParam > :: into (sd_prisma :: prisma :: file_path :: object :: Include :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: file_path :: IncludeParam > :: into (sd_prisma :: prisma :: file_path :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: file_path :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; is_dir) => { "is_dir" } ; (@ field_serde_name ; cas_id) => { "cas_id" } ; (@ field_serde_name ; integrity_checksum) => { "integrity_checksum" } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; location) => { "location" } ; (@ field_serde_name ; materialized_path) => { "materialized_path" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; extension) => { "extension" } ; (@ field_serde_name ; size_in_bytes) => { "size_in_bytes" } ; (@ field_serde_name ; size_in_bytes_bytes) => { "size_in_bytes_bytes" } ; (@ field_serde_name ; inode) => { "inode" } ; (@ field_serde_name ; device) => { "device" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ field_serde_name ; key_id) => { "key_id" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; date_indexed) => { "date_indexed" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_file_path as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		IsDir(is_dir::Include),
		CasId(cas_id::Include),
		IntegrityChecksum(integrity_checksum::Include),
		LocationId(location_id::Include),
		Location(location::Include),
		MaterializedPath(materialized_path::Include),
		Name(name::Include),
		Extension(extension::Include),
		SizeInBytes(size_in_bytes::Include),
		SizeInBytesBytes(size_in_bytes_bytes::Include),
		Inode(inode::Include),
		Device(device::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
		KeyId(key_id::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		DateIndexed(date_indexed::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::IsDir(data) => data.to_selection(),
				Self::CasId(data) => data.to_selection(),
				Self::IntegrityChecksum(data) => data.to_selection(),
				Self::LocationId(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::MaterializedPath(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Extension(data) => data.to_selection(),
				Self::SizeInBytes(data) => data.to_selection(),
				Self::SizeInBytesBytes(data) => data.to_selection(),
				Self::Inode(data) => data.to_selection(),
				Self::Device(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
				Self::KeyId(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::DateIndexed(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod cas_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "cas_id";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::CasId(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			CasId,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::CasId(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CasId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::CasId(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::CasId(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CasId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CasId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CasId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_indexed {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_indexed";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateIndexed(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateIndexed,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateIndexed(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateIndexed(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateIndexed(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateIndexed(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateIndexed(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateIndexed(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateIndexed(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod device {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "device";
		pub type Type = Option<Vec<u8>>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::Device(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			Device,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Device(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Device(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Device(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Device(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Device(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Device(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Device(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod extension {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "extension";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Extension(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Extension,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Extension(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Extension(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Extension(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Extension(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Extension(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Extension(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Extension(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod inode {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "inode";
		pub type Type = Option<Vec<u8>>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::Inode(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			Inode,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Inode(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Inode(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Inode(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Inode(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Inode(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Inode(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Inode(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod integrity_checksum {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "integrity_checksum";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::IntegrityChecksum(_prisma::read_filters::StringNullableFilter::Equals(
				value,
			))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			IntegrityChecksum,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IntegrityChecksum(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IntegrityChecksum(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IntegrityChecksum(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IntegrityChecksum(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IntegrityChecksum(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IntegrityChecksum(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IntegrityChecksum(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod is_dir {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "is_dir";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::IsDir(_prisma::read_filters::BooleanNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			IsDir,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IsDir(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsDir(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsDir(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsDir(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsDir(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsDir(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsDir(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod key_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key_id";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::KeyId(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			KeyId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::KeyId(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::KeyId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::KeyId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod location {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "location";
		pub type Type = Option<location::Data>;
		pub type RecursiveSafeType = Option<Box<location::Data>>;
		pub fn is(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIs(value)
		}
		pub fn is_not(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIsNot(value)
		}
		pub struct Order(Vec<location::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<location::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Location(v)
			}
		}
		pub struct Fetch(pub location::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<location::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Location(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(location::UniqueArgs::new())
		}
		pub struct Connect(location::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLocation(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: location::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectLocation
		}
		pub fn is_null() -> WhereParam {
			WhereParam::LocationIsNull
		}
		pub enum Select {
			Select(Vec<location::SelectParam>),
			Include(Vec<location::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Location(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("location", None, [], selections)
			}
			pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<location::SelectParam>),
			Include(Vec<location::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Location(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = < location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("location", None, [], selections)
			}
			pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod location_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "location_id";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::LocationId(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			LocationId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LocationId(v)
			}
		}
		pub struct Set(pub Option<i32>);
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LocationId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LocationId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LocationId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LocationId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod materialized_path {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "materialized_path";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::MaterializedPath(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			MaterializedPath,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::MaterializedPath(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MaterializedPath(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::MaterializedPath(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::MaterializedPath(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MaterializedPath(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::MaterializedPath(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::MaterializedPath(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub type Type = Option<object::Data>;
		pub type RecursiveSafeType = Option<Box<object::Data>>;
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectObject
		}
		pub fn is_null() -> WhereParam {
			WhereParam::ObjectIsNull
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub Option<i32>);
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod size_in_bytes {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "size_in_bytes";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::SizeInBytes(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			SizeInBytes,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::SizeInBytes(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SizeInBytes(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::SizeInBytes(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::SizeInBytes(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SizeInBytes(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SizeInBytes(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SizeInBytes(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod size_in_bytes_bytes {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "size_in_bytes_bytes";
		pub type Type = Option<Vec<u8>>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::SizeInBytesBytes(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			SizeInBytesBytes,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::SizeInBytesBytes(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SizeInBytesBytes(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::SizeInBytesBytes(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::SizeInBytesBytes(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SizeInBytesBytes(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SizeInBytesBytes(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SizeInBytesBytes(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.file_path().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.file_path()
				.create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(is_dir::NAME),
				::prisma_client_rust::sel(cas_id::NAME),
				::prisma_client_rust::sel(integrity_checksum::NAME),
				::prisma_client_rust::sel(location_id::NAME),
				::prisma_client_rust::sel(materialized_path::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(extension::NAME),
				::prisma_client_rust::sel(size_in_bytes::NAME),
				::prisma_client_rust::sel(size_in_bytes_bytes::NAME),
				::prisma_client_rust::sel(inode::NAME),
				::prisma_client_rust::sel(device::NAME),
				::prisma_client_rust::sel(object_id::NAME),
				::prisma_client_rust::sel(key_id::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
				::prisma_client_rust::sel(date_indexed::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "FilePath", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: pub_id::Type,
		#[serde(rename = "is_dir")]
		pub is_dir: is_dir::Type,
		#[serde(rename = "cas_id")]
		pub cas_id: cas_id::Type,
		#[serde(rename = "integrity_checksum")]
		pub integrity_checksum: integrity_checksum::Type,
		#[serde(rename = "location_id")]
		pub location_id: location_id::Type,
		#[serde(
			rename = "location",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub location: Option<location::RecursiveSafeType>,
		#[serde(rename = "materialized_path")]
		pub materialized_path: materialized_path::Type,
		#[serde(rename = "name")]
		pub name: name::Type,
		#[serde(rename = "extension")]
		pub extension: extension::Type,
		#[serde(rename = "size_in_bytes")]
		pub size_in_bytes: size_in_bytes::Type,
		#[serde(rename = "size_in_bytes_bytes")]
		pub size_in_bytes_bytes: size_in_bytes_bytes::Type,
		#[serde(rename = "inode")]
		pub inode: inode::Type,
		#[serde(rename = "device")]
		pub device: device::Type,
		#[serde(rename = "object_id")]
		pub object_id: object_id::Type,
		#[serde(
			rename = "object",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub object: Option<object::RecursiveSafeType>,
		#[serde(rename = "key_id")]
		pub key_id: key_id::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "date_modified")]
		pub date_modified: date_modified::Type,
		#[serde(rename = "date_indexed")]
		pub date_indexed: date_indexed::Type,
	}
	impl Data {
		pub fn location(
			&self,
		) -> Result<Option<&super::location::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.location
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(location),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
		pub fn object(
			&self,
		) -> Result<Option<&super::object::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_file_path { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: file_path struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "is_dir")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub is_dir : Option < bool > , # [serde (rename = "cas_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub cas_id : Option < String > , # [serde (rename = "integrity_checksum")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub integrity_checksum : Option < String > , # [serde (rename = "location_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub location_id : Option < i32 > , # [serde (rename = "materialized_path")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub materialized_path : Option < String > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "extension")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub extension : Option < String > , # [serde (rename = "size_in_bytes")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub size_in_bytes : Option < String > , # [serde (rename = "size_in_bytes_bytes")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub size_in_bytes_bytes : Option < Vec < u8 > > , # [serde (rename = "inode")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub inode : Option < Vec < u8 > > , # [serde (rename = "device")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub device : Option < Vec < u8 > > , # [serde (rename = "object_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub object_id : Option < i32 > , # [serde (rename = "key_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub key_id : Option < i32 > , # [serde (rename = "date_created")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_modified")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_modified : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_indexed")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_indexed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_file_path as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod object {
	use super::_prisma::*;
	pub const NAME: &str = "Object";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Kind(super::_prisma::read_filters::IntNullableFilter),
		KeyId(super::_prisma::read_filters::IntNullableFilter),
		Hidden(super::_prisma::read_filters::BooleanNullableFilter),
		Favorite(super::_prisma::read_filters::BooleanNullableFilter),
		Important(super::_prisma::read_filters::BooleanNullableFilter),
		Note(super::_prisma::read_filters::StringNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
		DateAccessed(super::_prisma::read_filters::DateTimeNullableFilter),
		TagsSome(Vec<super::tag_on_object::WhereParam>),
		TagsEvery(Vec<super::tag_on_object::WhereParam>),
		TagsNone(Vec<super::tag_on_object::WhereParam>),
		LabelsSome(Vec<super::label_on_object::WhereParam>),
		LabelsEvery(Vec<super::label_on_object::WhereParam>),
		LabelsNone(Vec<super::label_on_object::WhereParam>),
		SpacesSome(Vec<super::object_in_space::WhereParam>),
		SpacesEvery(Vec<super::object_in_space::WhereParam>),
		SpacesNone(Vec<super::object_in_space::WhereParam>),
		FilePathsSome(Vec<super::file_path::WhereParam>),
		FilePathsEvery(Vec<super::file_path::WhereParam>),
		FilePathsNone(Vec<super::file_path::WhereParam>),
		MediaDataIsNull,
		MediaDataIs(Vec<super::media_data::WhereParam>),
		MediaDataIsNot(Vec<super::media_data::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Kind(value) => (kind::NAME, value.into()),
				Self::KeyId(value) => (key_id::NAME, value.into()),
				Self::Hidden(value) => (hidden::NAME, value.into()),
				Self::Favorite(value) => (favorite::NAME, value.into()),
				Self::Important(value) => (important::NAME, value.into()),
				Self::Note(value) => (note::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateAccessed(value) => (date_accessed::NAME, value.into()),
				Self::TagsSome(where_params) => (
					tags::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagsEvery(where_params) => (
					tags::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagsNone(where_params) => (
					tags::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelsSome(where_params) => (
					labels::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelsEvery(where_params) => (
					labels::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelsNone(where_params) => (
					labels::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SpacesSome(where_params) => (
					spaces::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SpacesEvery(where_params) => (
					spaces::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SpacesNone(where_params) => (
					spaces::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsSome(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsEvery(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsNone(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::MediaDataIsNull => (
					media_data::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::MediaDataIs(where_params) => (
					media_data::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::MediaDataIsNot(where_params) => (
					media_data::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Kind(super::SortOrder),
		KeyId(super::SortOrder),
		Hidden(super::SortOrder),
		Favorite(super::SortOrder),
		Important(super::SortOrder),
		Note(super::SortOrder),
		DateCreated(super::SortOrder),
		DateAccessed(super::SortOrder),
		Tags(Vec<super::tag_on_object::OrderByRelationAggregateParam>),
		Labels(Vec<super::label_on_object::OrderByRelationAggregateParam>),
		Spaces(Vec<super::object_in_space::OrderByRelationAggregateParam>),
		FilePaths(Vec<super::file_path::OrderByRelationAggregateParam>),
		MediaData(Vec<super::media_data::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Kind(param) => ("kind", param.into()),
				Self::KeyId(param) => ("key_id", param.into()),
				Self::Hidden(param) => ("hidden", param.into()),
				Self::Favorite(param) => ("favorite", param.into()),
				Self::Important(param) => ("important", param.into()),
				Self::Note(param) => ("note", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateAccessed(param) => ("date_accessed", param.into()),
				Self::Tags(param) => (
					"tags",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Labels(param) => (
					"labels",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Spaces(param) => (
					"spaces",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::FilePaths(param) => (
					"file_paths",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::MediaData(param) => (
					"media_data",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Tags(super::tag_on_object::ManyArgs),
		Labels(super::label_on_object::ManyArgs),
		Spaces(super::object_in_space::ManyArgs),
		FilePaths(super::file_path::ManyArgs),
		MediaData(super::media_data::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Tags(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						tags::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::Labels(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						labels::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::Spaces(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						spaces::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::FilePaths(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						file_paths::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::MediaData(args) => {
					let mut selections = < super :: media_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(media_data::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Kind(super::_prisma::write_params::IntNullableParam),
		KeyId(super::_prisma::write_params::IntNullableParam),
		Hidden(super::_prisma::write_params::BooleanNullableParam),
		Favorite(super::_prisma::write_params::BooleanNullableParam),
		Important(super::_prisma::write_params::BooleanNullableParam),
		Note(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateAccessed(super::_prisma::write_params::DateTimeNullableParam),
		ConnectTags(Vec<super::tag_on_object::UniqueWhereParam>),
		DisconnectTags(Vec<super::tag_on_object::UniqueWhereParam>),
		SetTags(Vec<super::tag_on_object::UniqueWhereParam>),
		ConnectLabels(Vec<super::label_on_object::UniqueWhereParam>),
		DisconnectLabels(Vec<super::label_on_object::UniqueWhereParam>),
		SetLabels(Vec<super::label_on_object::UniqueWhereParam>),
		ConnectSpaces(Vec<super::object_in_space::UniqueWhereParam>),
		DisconnectSpaces(Vec<super::object_in_space::UniqueWhereParam>),
		SetSpaces(Vec<super::object_in_space::UniqueWhereParam>),
		ConnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		DisconnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		SetFilePaths(Vec<super::file_path::UniqueWhereParam>),
		ConnectMediaData(super::media_data::UniqueWhereParam),
		DisconnectMediaData,
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Kind(value) => (kind::NAME, value.into()),
				Self::KeyId(value) => (key_id::NAME, value.into()),
				Self::Hidden(value) => (hidden::NAME, value.into()),
				Self::Favorite(value) => (favorite::NAME, value.into()),
				Self::Important(value) => (important::NAME, value.into()),
				Self::Note(value) => (note::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateAccessed(value) => (date_accessed::NAME, value.into()),
				Self::ConnectTags(where_params) => (
					tags::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectTags(where_params) => (
					tags::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetTags(where_params) => (
					tags::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectLabels(where_params) => (
					labels::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectLabels(where_params) => (
					labels::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetLabels(where_params) => (
					labels::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectSpaces(where_params) => (
					spaces::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectSpaces(where_params) => (
					spaces::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetSpaces(where_params) => (
					spaces::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectMediaData(where_param) => (
					media_data::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::media_data::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectMediaData => (
					media_data::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Kind(super::_prisma::write_params::IntNullableParam),
		KeyId(super::_prisma::write_params::IntNullableParam),
		Hidden(super::_prisma::write_params::BooleanNullableParam),
		Favorite(super::_prisma::write_params::BooleanNullableParam),
		Important(super::_prisma::write_params::BooleanNullableParam),
		Note(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateAccessed(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Kind(value) => ("kind", value.into()),
				Self::KeyId(value) => ("key_id", value.into()),
				Self::Hidden(value) => ("hidden", value.into()),
				Self::Favorite(value) => ("favorite", value.into()),
				Self::Important(value) => ("important", value.into()),
				Self::Note(value) => ("note", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateAccessed(value) => ("date_accessed", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: object :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: object :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , kind , key_id , hidden , favorite , important , note , date_created , date_accessed , tags , labels , spaces , file_paths , media_data } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: object :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: object :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: object :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: object :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: object :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: object :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "kind" , "key_id" , "hidden" , "favorite" , "important" , "note" , "date_created" , "date_accessed" , "tags" , "labels" , "spaces" , "file_paths" , "media_data"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tags :: Data > } ; (@ field_type ; labels : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < labels :: Data > } ; (@ field_type ; spaces : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < spaces :: Data > } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; media_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < media_data :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: object :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Object" , available relations are "id, pub_id, kind, key_id, hidden, favorite, important, note, date_created, date_accessed, tags, labels, spaces, file_paths, media_data")) } ; (@ field_module ; tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: tag_on_object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; labels : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: label_on_object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; spaces : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object_in_space :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: file_path :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; media_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: media_data :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; kind) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: kind :: Select) } ; (@ selection_field_to_selection_param ; key_id) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: key_id :: Select) } ; (@ selection_field_to_selection_param ; hidden) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: hidden :: Select) } ; (@ selection_field_to_selection_param ; favorite) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: favorite :: Select) } ; (@ selection_field_to_selection_param ; important) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: important :: Select) } ; (@ selection_field_to_selection_param ; note) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: note :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_accessed) => { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: date_accessed :: Select) } ; (@ selection_field_to_selection_param ; tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: tags :: Select :: $ selection_mode (sd_prisma :: prisma :: tag_on_object :: ManyArgs :: new (sd_prisma :: prisma :: tag_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: tags :: Select :: Fetch (sd_prisma :: prisma :: tag_on_object :: ManyArgs :: new (sd_prisma :: prisma :: tag_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; labels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: labels :: Select :: $ selection_mode (sd_prisma :: prisma :: label_on_object :: ManyArgs :: new (sd_prisma :: prisma :: label_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: label_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; labels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: labels :: Select :: Fetch (sd_prisma :: prisma :: label_on_object :: ManyArgs :: new (sd_prisma :: prisma :: label_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; spaces $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: spaces :: Select :: $ selection_mode (sd_prisma :: prisma :: object_in_space :: ManyArgs :: new (sd_prisma :: prisma :: object_in_space :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: object_in_space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; spaces $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: spaces :: Select :: Fetch (sd_prisma :: prisma :: object_in_space :: ManyArgs :: new (sd_prisma :: prisma :: object_in_space :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: file_paths :: Select :: $ selection_mode (sd_prisma :: prisma :: file_path :: ManyArgs :: new (sd_prisma :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: file_paths :: Select :: Fetch (sd_prisma :: prisma :: file_path :: ManyArgs :: new (sd_prisma :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; media_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: media_data :: Select :: $ selection_mode (sd_prisma :: prisma :: media_data :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; media_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: SelectParam > :: into (sd_prisma :: prisma :: object :: media_data :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; key_id) => { "key_id" } ; (@ field_serde_name ; hidden) => { "hidden" } ; (@ field_serde_name ; favorite) => { "favorite" } ; (@ field_serde_name ; important) => { "important" } ; (@ field_serde_name ; note) => { "note" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_accessed) => { "date_accessed" } ; (@ field_serde_name ; tags) => { "tags" } ; (@ field_serde_name ; labels) => { "labels" } ; (@ field_serde_name ; spaces) => { "spaces" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ field_serde_name ; media_data) => { "media_data" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_object as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Kind(kind::Select),
		KeyId(key_id::Select),
		Hidden(hidden::Select),
		Favorite(favorite::Select),
		Important(important::Select),
		Note(note::Select),
		DateCreated(date_created::Select),
		DateAccessed(date_accessed::Select),
		Tags(tags::Select),
		Labels(labels::Select),
		Spaces(spaces::Select),
		FilePaths(file_paths::Select),
		MediaData(media_data::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Kind(data) => data.to_selection(),
				Self::KeyId(data) => data.to_selection(),
				Self::Hidden(data) => data.to_selection(),
				Self::Favorite(data) => data.to_selection(),
				Self::Important(data) => data.to_selection(),
				Self::Note(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateAccessed(data) => data.to_selection(),
				Self::Tags(data) => data.to_selection(),
				Self::Labels(data) => data.to_selection(),
				Self::Spaces(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
				Self::MediaData(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: object :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: object :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { tags , labels , spaces , file_paths , media_data } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: object :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: object :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: object :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: object :: kind :: NAME)] pub kind : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: object :: key_id :: NAME)] pub key_id : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: object :: hidden :: NAME)] pub hidden : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: object :: favorite :: NAME)] pub favorite : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: object :: important :: NAME)] pub important : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: object :: note :: NAME)] pub note : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: object :: date_created :: NAME)] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: object :: date_accessed :: NAME)] pub date_accessed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: object :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: object :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (kind) , stringify ! (key_id) , stringify ! (hidden) , stringify ! (favorite) , stringify ! (important) , stringify ! (note) , stringify ! (date_created) , stringify ! (date_accessed)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: object :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: object :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: object :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (sd_prisma :: prisma :: object :: kind :: NAME , & self . kind) ? ; state . serialize_field (sd_prisma :: prisma :: object :: key_id :: NAME , & self . key_id) ? ; state . serialize_field (sd_prisma :: prisma :: object :: hidden :: NAME , & self . hidden) ? ; state . serialize_field (sd_prisma :: prisma :: object :: favorite :: NAME , & self . favorite) ? ; state . serialize_field (sd_prisma :: prisma :: object :: important :: NAME , & self . important) ? ; state . serialize_field (sd_prisma :: prisma :: object :: note :: NAME , & self . note) ? ; state . serialize_field (sd_prisma :: prisma :: object :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: object :: date_accessed :: NAME , & self . date_accessed) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , kind , key_id , hidden , favorite , important , note , date_created , date_accessed } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: object :: $ field :: NAME) , + , sd_prisma :: prisma :: object :: id :: NAME , sd_prisma :: prisma :: object :: pub_id :: NAME , sd_prisma :: prisma :: object :: kind :: NAME , sd_prisma :: prisma :: object :: key_id :: NAME , sd_prisma :: prisma :: object :: hidden :: NAME , sd_prisma :: prisma :: object :: favorite :: NAME , sd_prisma :: prisma :: object :: important :: NAME , sd_prisma :: prisma :: object :: note :: NAME , sd_prisma :: prisma :: object :: date_created :: NAME , sd_prisma :: prisma :: object :: date_accessed :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: object :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: object :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: object :: pub_id :: NAME => Ok (Field :: pub_id) , sd_prisma :: prisma :: object :: kind :: NAME => Ok (Field :: kind) , sd_prisma :: prisma :: object :: key_id :: NAME => Ok (Field :: key_id) , sd_prisma :: prisma :: object :: hidden :: NAME => Ok (Field :: hidden) , sd_prisma :: prisma :: object :: favorite :: NAME => Ok (Field :: favorite) , sd_prisma :: prisma :: object :: important :: NAME => Ok (Field :: important) , sd_prisma :: prisma :: object :: note :: NAME => Ok (Field :: note) , sd_prisma :: prisma :: object :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: object :: date_accessed :: NAME => Ok (Field :: date_accessed) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut kind = None ; let mut key_id = None ; let mut hidden = None ; let mut favorite = None ; let mut important = None ; let mut note = None ; let mut date_created = None ; let mut date_accessed = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: kind => { if kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: kind :: NAME)) ; } kind = Some (map . next_value () ?) ; } Field :: key_id => { if key_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: key_id :: NAME)) ; } key_id = Some (map . next_value () ?) ; } Field :: hidden => { if hidden . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: hidden :: NAME)) ; } hidden = Some (map . next_value () ?) ; } Field :: favorite => { if favorite . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: favorite :: NAME)) ; } favorite = Some (map . next_value () ?) ; } Field :: important => { if important . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: important :: NAME)) ; } important = Some (map . next_value () ?) ; } Field :: note => { if note . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: note :: NAME)) ; } note = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_accessed => { if date_accessed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: date_accessed :: NAME)) ; } date_accessed = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: pub_id :: NAME)) ? ; let kind = kind . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: kind :: NAME)) ? ; let key_id = key_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: key_id :: NAME)) ? ; let hidden = hidden . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: hidden :: NAME)) ? ; let favorite = favorite . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: favorite :: NAME)) ? ; let important = important . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: important :: NAME)) ? ; let note = note . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: note :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: date_created :: NAME)) ? ; let date_accessed = date_accessed . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object :: date_accessed :: NAME)) ? ; Ok (Data { id , pub_id , kind , key_id , hidden , favorite , important , note , date_created , date_accessed , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "kind" , "key_id" , "hidden" , "favorite" , "important" , "note" , "date_created" , "date_accessed" , "tags" , "labels" , "spaces" , "file_paths" , "media_data"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tags :: Data > } ; (@ field_type ; labels : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < labels :: Data > } ; (@ field_type ; spaces : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < spaces :: Data > } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; media_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < media_data :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: object :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Object" , available relations are "tags, labels, spaces, file_paths, media_data")) } ; (@ field_module ; tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: tag_on_object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; labels : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: label_on_object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; spaces : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object_in_space :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: file_path :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; media_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: media_data :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: tags :: Include :: $ selection_mode (sd_prisma :: prisma :: tag_on_object :: ManyArgs :: new (sd_prisma :: prisma :: tag_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: tags :: Include :: Fetch (sd_prisma :: prisma :: tag_on_object :: ManyArgs :: new (sd_prisma :: prisma :: tag_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; labels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: labels :: Include :: $ selection_mode (sd_prisma :: prisma :: label_on_object :: ManyArgs :: new (sd_prisma :: prisma :: label_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: label_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; labels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: labels :: Include :: Fetch (sd_prisma :: prisma :: label_on_object :: ManyArgs :: new (sd_prisma :: prisma :: label_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; spaces $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: spaces :: Include :: $ selection_mode (sd_prisma :: prisma :: object_in_space :: ManyArgs :: new (sd_prisma :: prisma :: object_in_space :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: object_in_space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; spaces $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: spaces :: Include :: Fetch (sd_prisma :: prisma :: object_in_space :: ManyArgs :: new (sd_prisma :: prisma :: object_in_space :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: file_paths :: Include :: $ selection_mode (sd_prisma :: prisma :: file_path :: ManyArgs :: new (sd_prisma :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: file_paths :: Include :: Fetch (sd_prisma :: prisma :: file_path :: ManyArgs :: new (sd_prisma :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; media_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: media_data :: Include :: $ selection_mode (sd_prisma :: prisma :: media_data :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; media_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object :: IncludeParam > :: into (sd_prisma :: prisma :: object :: media_data :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; key_id) => { "key_id" } ; (@ field_serde_name ; hidden) => { "hidden" } ; (@ field_serde_name ; favorite) => { "favorite" } ; (@ field_serde_name ; important) => { "important" } ; (@ field_serde_name ; note) => { "note" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_accessed) => { "date_accessed" } ; (@ field_serde_name ; tags) => { "tags" } ; (@ field_serde_name ; labels) => { "labels" } ; (@ field_serde_name ; spaces) => { "spaces" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ field_serde_name ; media_data) => { "media_data" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_object as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Kind(kind::Include),
		KeyId(key_id::Include),
		Hidden(hidden::Include),
		Favorite(favorite::Include),
		Important(important::Include),
		Note(note::Include),
		DateCreated(date_created::Include),
		DateAccessed(date_accessed::Include),
		Tags(tags::Include),
		Labels(labels::Include),
		Spaces(spaces::Include),
		FilePaths(file_paths::Include),
		MediaData(media_data::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Kind(data) => data.to_selection(),
				Self::KeyId(data) => data.to_selection(),
				Self::Hidden(data) => data.to_selection(),
				Self::Favorite(data) => data.to_selection(),
				Self::Important(data) => data.to_selection(),
				Self::Note(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateAccessed(data) => data.to_selection(),
				Self::Tags(data) => data.to_selection(),
				Self::Labels(data) => data.to_selection(),
				Self::Spaces(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
				Self::MediaData(data) => data.to_selection(),
			}
		}
	}
	pub mod date_accessed {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_accessed";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateAccessed(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateAccessed,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateAccessed(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateAccessed(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateAccessed(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateAccessed(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateAccessed(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateAccessed(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateAccessed(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod favorite {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "favorite";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::Favorite(_prisma::read_filters::BooleanNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			Favorite,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Favorite(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Favorite(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Favorite(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Favorite(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Favorite(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Favorite(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Favorite(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod file_paths {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "file_paths";
		pub type Type = Vec<file_path::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsSome(value)
		}
		pub fn every(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsEvery(value)
		}
		pub fn none(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsNone(value)
		}
		pub struct Order(Vec<file_path::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<file_path::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::FilePaths(v)
			}
		}
		pub struct Fetch(pub file_path::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: file_path::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: file_path::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::FilePaths(v)
			}
		}
		pub fn fetch(params: Vec<file_path::WhereParam>) -> Fetch {
			Fetch(file_path::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<file_path::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectFilePaths(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<file_path::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectFilePaths(params)
		}
		pub fn set(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::SetFilePaths(params)
		}
		pub enum Select {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::FilePaths(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::FilePaths(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = < file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod hidden {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "hidden";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::Hidden(_prisma::read_filters::BooleanNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			Hidden,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Hidden(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Hidden(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Hidden(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Hidden(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Hidden(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Hidden(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Hidden(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod important {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "important";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::Important(_prisma::read_filters::BooleanNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			Important,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Important(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Important(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Important(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Important(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Important(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Important(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Important(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod key_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key_id";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::KeyId(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			KeyId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::KeyId(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::KeyId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::KeyId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod kind {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "kind";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::Kind(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			Kind,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Kind(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Kind(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Kind(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Kind(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Kind(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Kind(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Kind(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod labels {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "labels";
		pub type Type = Vec<label_on_object::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelsSome(value)
		}
		pub fn every(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelsEvery(value)
		}
		pub fn none(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelsNone(value)
		}
		pub struct Order(Vec<label_on_object::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<label_on_object::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Labels(v)
			}
		}
		pub struct Fetch(pub label_on_object::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<label_on_object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: label_on_object::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: label_on_object::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Labels(v)
			}
		}
		pub fn fetch(params: Vec<label_on_object::WhereParam>) -> Fetch {
			Fetch(label_on_object::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<label_on_object::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLabels(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<label_on_object::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<label_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectLabels(params)
		}
		pub fn set(params: Vec<label_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::SetLabels(params)
		}
		pub enum Select {
			Select(label_on_object::ManyArgs, Vec<label_on_object::SelectParam>),
			Include(
				label_on_object::ManyArgs,
				Vec<label_on_object::IncludeParam>,
			),
			Fetch(label_on_object::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Labels(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(label_on_object::ManyArgs, Vec<label_on_object::SelectParam>),
			Include(
				label_on_object::ManyArgs,
				Vec<label_on_object::IncludeParam>,
			),
			Fetch(label_on_object::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Labels(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod media_data {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "media_data";
		pub type Type = Option<media_data::Data>;
		pub type RecursiveSafeType = Option<Box<media_data::Data>>;
		pub fn is(value: Vec<media_data::WhereParam>) -> WhereParam {
			WhereParam::MediaDataIs(value)
		}
		pub fn is_not(value: Vec<media_data::WhereParam>) -> WhereParam {
			WhereParam::MediaDataIsNot(value)
		}
		pub struct Order(Vec<media_data::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<media_data::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::MediaData(v)
			}
		}
		pub struct Fetch(pub media_data::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<media_data::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::MediaData(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(media_data::UniqueArgs::new())
		}
		pub struct Connect(media_data::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectMediaData(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: media_data::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectMediaData
		}
		pub fn is_null() -> WhereParam {
			WhereParam::MediaDataIsNull
		}
		pub enum Select {
			Select(Vec<media_data::SelectParam>),
			Include(Vec<media_data::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::MediaData(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<media_data::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("media_data", None, [], selections)
			}
			pub fn select(nested_selections: Vec<media_data::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<media_data::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<media_data::SelectParam>),
			Include(Vec<media_data::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::MediaData(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = < media_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<media_data::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("media_data", None, [], selections)
			}
			pub fn select(nested_selections: Vec<media_data::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<media_data::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod note {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "note";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Note(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Note,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Note(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Note(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Note(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Note(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Note(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Note(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Note(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod spaces {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "spaces";
		pub type Type = Vec<object_in_space::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::SpacesSome(value)
		}
		pub fn every(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::SpacesEvery(value)
		}
		pub fn none(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::SpacesNone(value)
		}
		pub struct Order(Vec<object_in_space::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<object_in_space::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Spaces(v)
			}
		}
		pub struct Fetch(pub object_in_space::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object_in_space::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: object_in_space::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: object_in_space::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Spaces(v)
			}
		}
		pub fn fetch(params: Vec<object_in_space::WhereParam>) -> Fetch {
			Fetch(object_in_space::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<object_in_space::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectSpaces(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<object_in_space::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<object_in_space::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectSpaces(params)
		}
		pub fn set(params: Vec<object_in_space::UniqueWhereParam>) -> SetParam {
			SetParam::SetSpaces(params)
		}
		pub enum Select {
			Select(object_in_space::ManyArgs, Vec<object_in_space::SelectParam>),
			Include(
				object_in_space::ManyArgs,
				Vec<object_in_space::IncludeParam>,
			),
			Fetch(object_in_space::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Spaces(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(object_in_space::ManyArgs, Vec<object_in_space::SelectParam>),
			Include(
				object_in_space::ManyArgs,
				Vec<object_in_space::IncludeParam>,
			),
			Fetch(object_in_space::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Spaces(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod tags {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "tags";
		pub type Type = Vec<tag_on_object::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagsSome(value)
		}
		pub fn every(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagsEvery(value)
		}
		pub fn none(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagsNone(value)
		}
		pub struct Order(Vec<tag_on_object::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<tag_on_object::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Tags(v)
			}
		}
		pub struct Fetch(pub tag_on_object::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<tag_on_object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: tag_on_object::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: tag_on_object::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Tags(v)
			}
		}
		pub fn fetch(params: Vec<tag_on_object::WhereParam>) -> Fetch {
			Fetch(tag_on_object::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<tag_on_object::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectTags(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<tag_on_object::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<tag_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectTags(params)
		}
		pub fn set(params: Vec<tag_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::SetTags(params)
		}
		pub enum Select {
			Select(tag_on_object::ManyArgs, Vec<tag_on_object::SelectParam>),
			Include(tag_on_object::ManyArgs, Vec<tag_on_object::IncludeParam>),
			Fetch(tag_on_object::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Tags(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(tag_on_object::ManyArgs, Vec<tag_on_object::SelectParam>),
			Include(tag_on_object::ManyArgs, Vec<tag_on_object::IncludeParam>),
			Fetch(tag_on_object::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Tags(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.object().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.object().create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(kind::NAME),
				::prisma_client_rust::sel(key_id::NAME),
				::prisma_client_rust::sel(hidden::NAME),
				::prisma_client_rust::sel(favorite::NAME),
				::prisma_client_rust::sel(important::NAME),
				::prisma_client_rust::sel(note::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_accessed::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Object", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: pub_id::Type,
		#[serde(rename = "kind")]
		pub kind: kind::Type,
		#[serde(rename = "key_id")]
		pub key_id: key_id::Type,
		#[serde(rename = "hidden")]
		pub hidden: hidden::Type,
		#[serde(rename = "favorite")]
		pub favorite: favorite::Type,
		#[serde(rename = "important")]
		pub important: important::Type,
		#[serde(rename = "note")]
		pub note: note::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "date_accessed")]
		pub date_accessed: date_accessed::Type,
		#[serde(rename = "tags")]
		#[specta(skip)]
		pub tags: Option<tags::RecursiveSafeType>,
		#[serde(rename = "labels")]
		#[specta(skip)]
		pub labels: Option<labels::RecursiveSafeType>,
		#[serde(rename = "spaces")]
		#[specta(skip)]
		pub spaces: Option<spaces::RecursiveSafeType>,
		#[serde(rename = "file_paths")]
		#[specta(skip)]
		pub file_paths: Option<file_paths::RecursiveSafeType>,
		#[serde(
			rename = "media_data",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub media_data: Option<media_data::RecursiveSafeType>,
	}
	impl Data {
		pub fn tags(&self) -> Result<&tags::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.tags
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(tags),
				))
		}
		pub fn labels(
			&self,
		) -> Result<&labels::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.labels
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(labels),
				))
		}
		pub fn spaces(
			&self,
		) -> Result<&spaces::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.spaces
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(spaces),
				))
		}
		pub fn file_paths(
			&self,
		) -> Result<&file_paths::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.file_paths
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(file_paths),
				))
		}
		pub fn media_data(
			&self,
		) -> Result<Option<&super::media_data::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.media_data
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(media_data),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_object { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: object struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "kind")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub kind : Option < i32 > , # [serde (rename = "key_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub key_id : Option < i32 > , # [serde (rename = "hidden")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub hidden : Option < bool > , # [serde (rename = "favorite")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub favorite : Option < bool > , # [serde (rename = "important")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub important : Option < bool > , # [serde (rename = "note")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub note : Option < String > , # [serde (rename = "date_created")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_accessed")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_accessed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_object as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod media_data {
	use super::_prisma::*;
	pub const NAME: &str = "MediaData";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
		DateTaken(super::_prisma::read_filters::DateTimeNullableFilter),
		PixelWidth(super::_prisma::read_filters::IntNullableFilter),
		PixelHeight(super::_prisma::read_filters::IntNullableFilter),
		ColorSpace(super::_prisma::read_filters::StringNullableFilter),
		Longitude(super::_prisma::read_filters::FloatNullableFilter),
		Latitude(super::_prisma::read_filters::FloatNullableFilter),
		Codecs(super::_prisma::read_filters::StringNullableFilter),
		DeviceMake(super::_prisma::read_filters::StringNullableFilter),
		DeviceModel(super::_prisma::read_filters::StringNullableFilter),
		DeviceSoftware(super::_prisma::read_filters::StringNullableFilter),
		FocalLength(super::_prisma::read_filters::FloatNullableFilter),
		ShutterSpeed(super::_prisma::read_filters::FloatNullableFilter),
		Orientation(super::_prisma::read_filters::StringNullableFilter),
		Copyright(super::_prisma::read_filters::StringNullableFilter),
		Flash(super::_prisma::read_filters::BooleanNullableFilter),
		Artist(super::_prisma::read_filters::StringNullableFilter),
		Duration(super::_prisma::read_filters::IntNullableFilter),
		Fps(super::_prisma::read_filters::IntNullableFilter),
		Streams(super::_prisma::read_filters::IntNullableFilter),
		ObjectIsNull,
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateTaken(value) => (date_taken::NAME, value.into()),
				Self::PixelWidth(value) => (pixel_width::NAME, value.into()),
				Self::PixelHeight(value) => (pixel_height::NAME, value.into()),
				Self::ColorSpace(value) => (color_space::NAME, value.into()),
				Self::Longitude(value) => (longitude::NAME, value.into()),
				Self::Latitude(value) => (latitude::NAME, value.into()),
				Self::Codecs(value) => (codecs::NAME, value.into()),
				Self::DeviceMake(value) => (device_make::NAME, value.into()),
				Self::DeviceModel(value) => (device_model::NAME, value.into()),
				Self::DeviceSoftware(value) => (device_software::NAME, value.into()),
				Self::FocalLength(value) => (focal_length::NAME, value.into()),
				Self::ShutterSpeed(value) => (shutter_speed::NAME, value.into()),
				Self::Orientation(value) => (orientation::NAME, value.into()),
				Self::Copyright(value) => (copyright::NAME, value.into()),
				Self::Flash(value) => (flash::NAME, value.into()),
				Self::Artist(value) => (artist::NAME, value.into()),
				Self::Duration(value) => (duration::NAME, value.into()),
				Self::Fps(value) => (fps::NAME, value.into()),
				Self::Streams(value) => (streams::NAME, value.into()),
				Self::ObjectIsNull => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		DateCreated(super::SortOrder),
		DateTaken(super::SortOrder),
		PixelWidth(super::SortOrder),
		PixelHeight(super::SortOrder),
		ColorSpace(super::SortOrder),
		Longitude(super::SortOrder),
		Latitude(super::SortOrder),
		Codecs(super::SortOrder),
		DeviceMake(super::SortOrder),
		DeviceModel(super::SortOrder),
		DeviceSoftware(super::SortOrder),
		FocalLength(super::SortOrder),
		ShutterSpeed(super::SortOrder),
		Orientation(super::SortOrder),
		Copyright(super::SortOrder),
		Flash(super::SortOrder),
		Artist(super::SortOrder),
		Duration(super::SortOrder),
		Fps(super::SortOrder),
		Streams(super::SortOrder),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateTaken(param) => ("date_taken", param.into()),
				Self::PixelWidth(param) => ("pixel_width", param.into()),
				Self::PixelHeight(param) => ("pixel_height", param.into()),
				Self::ColorSpace(param) => ("color_space", param.into()),
				Self::Longitude(param) => ("longitude", param.into()),
				Self::Latitude(param) => ("latitude", param.into()),
				Self::Codecs(param) => ("codecs", param.into()),
				Self::DeviceMake(param) => ("device_make", param.into()),
				Self::DeviceModel(param) => ("device_model", param.into()),
				Self::DeviceSoftware(param) => ("device_software", param.into()),
				Self::FocalLength(param) => ("focal_length", param.into()),
				Self::ShutterSpeed(param) => ("shutter_speed", param.into()),
				Self::Orientation(param) => ("orientation", param.into()),
				Self::Copyright(param) => ("copyright", param.into()),
				Self::Flash(param) => ("flash", param.into()),
				Self::Artist(param) => ("artist", param.into()),
				Self::Duration(param) => ("duration", param.into()),
				Self::Fps(param) => ("fps", param.into()),
				Self::Streams(param) => ("streams", param.into()),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateTaken(super::_prisma::write_params::DateTimeNullableParam),
		PixelWidth(super::_prisma::write_params::IntNullableParam),
		PixelHeight(super::_prisma::write_params::IntNullableParam),
		ColorSpace(super::_prisma::write_params::StringNullableParam),
		Longitude(super::_prisma::write_params::FloatNullableParam),
		Latitude(super::_prisma::write_params::FloatNullableParam),
		Codecs(super::_prisma::write_params::StringNullableParam),
		DeviceMake(super::_prisma::write_params::StringNullableParam),
		DeviceModel(super::_prisma::write_params::StringNullableParam),
		DeviceSoftware(super::_prisma::write_params::StringNullableParam),
		FocalLength(super::_prisma::write_params::FloatNullableParam),
		ShutterSpeed(super::_prisma::write_params::FloatNullableParam),
		Orientation(super::_prisma::write_params::StringNullableParam),
		Copyright(super::_prisma::write_params::StringNullableParam),
		Flash(super::_prisma::write_params::BooleanNullableParam),
		Artist(super::_prisma::write_params::StringNullableParam),
		Duration(super::_prisma::write_params::IntNullableParam),
		Fps(super::_prisma::write_params::IntNullableParam),
		Streams(super::_prisma::write_params::IntNullableParam),
		ConnectObject(super::object::UniqueWhereParam),
		DisconnectObject,
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateTaken(value) => (date_taken::NAME, value.into()),
				Self::PixelWidth(value) => (pixel_width::NAME, value.into()),
				Self::PixelHeight(value) => (pixel_height::NAME, value.into()),
				Self::ColorSpace(value) => (color_space::NAME, value.into()),
				Self::Longitude(value) => (longitude::NAME, value.into()),
				Self::Latitude(value) => (latitude::NAME, value.into()),
				Self::Codecs(value) => (codecs::NAME, value.into()),
				Self::DeviceMake(value) => (device_make::NAME, value.into()),
				Self::DeviceModel(value) => (device_model::NAME, value.into()),
				Self::DeviceSoftware(value) => (device_software::NAME, value.into()),
				Self::FocalLength(value) => (focal_length::NAME, value.into()),
				Self::ShutterSpeed(value) => (shutter_speed::NAME, value.into()),
				Self::Orientation(value) => (orientation::NAME, value.into()),
				Self::Copyright(value) => (copyright::NAME, value.into()),
				Self::Flash(value) => (flash::NAME, value.into()),
				Self::Artist(value) => (artist::NAME, value.into()),
				Self::Duration(value) => (duration::NAME, value.into()),
				Self::Fps(value) => (fps::NAME, value.into()),
				Self::Streams(value) => (streams::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectObject => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateTaken(super::_prisma::write_params::DateTimeNullableParam),
		PixelWidth(super::_prisma::write_params::IntNullableParam),
		PixelHeight(super::_prisma::write_params::IntNullableParam),
		ColorSpace(super::_prisma::write_params::StringNullableParam),
		Longitude(super::_prisma::write_params::FloatNullableParam),
		Latitude(super::_prisma::write_params::FloatNullableParam),
		Codecs(super::_prisma::write_params::StringNullableParam),
		DeviceMake(super::_prisma::write_params::StringNullableParam),
		DeviceModel(super::_prisma::write_params::StringNullableParam),
		DeviceSoftware(super::_prisma::write_params::StringNullableParam),
		FocalLength(super::_prisma::write_params::FloatNullableParam),
		ShutterSpeed(super::_prisma::write_params::FloatNullableParam),
		Orientation(super::_prisma::write_params::StringNullableParam),
		Copyright(super::_prisma::write_params::StringNullableParam),
		Flash(super::_prisma::write_params::BooleanNullableParam),
		Artist(super::_prisma::write_params::StringNullableParam),
		Duration(super::_prisma::write_params::IntNullableParam),
		Fps(super::_prisma::write_params::IntNullableParam),
		Streams(super::_prisma::write_params::IntNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateTaken(value) => ("date_taken", value.into()),
				Self::PixelWidth(value) => ("pixel_width", value.into()),
				Self::PixelHeight(value) => ("pixel_height", value.into()),
				Self::ColorSpace(value) => ("color_space", value.into()),
				Self::Longitude(value) => ("longitude", value.into()),
				Self::Latitude(value) => ("latitude", value.into()),
				Self::Codecs(value) => ("codecs", value.into()),
				Self::DeviceMake(value) => ("device_make", value.into()),
				Self::DeviceModel(value) => ("device_model", value.into()),
				Self::DeviceSoftware(value) => ("device_software", value.into()),
				Self::FocalLength(value) => ("focal_length", value.into()),
				Self::ShutterSpeed(value) => ("shutter_speed", value.into()),
				Self::Orientation(value) => ("orientation", value.into()),
				Self::Copyright(value) => ("copyright", value.into()),
				Self::Flash(value) => ("flash", value.into()),
				Self::Artist(value) => ("artist", value.into()),
				Self::Duration(value) => ("duration", value.into()),
				Self::Fps(value) => ("fps", value.into()),
				Self::Streams(value) => ("streams", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_media_data { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: media_data :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: media_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: media_data :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: media_data :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: media_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: media_data :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , date_created , date_taken , pixel_width , pixel_height , color_space , longitude , latitude , codecs , device_make , device_model , device_software , focal_length , shutter_speed , orientation , copyright , flash , artist , duration , fps , streams , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: media_data :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: media_data :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: media_data :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: media_data :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: media_data :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: media_data :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "date_created" , "date_taken" , "pixel_width" , "pixel_height" , "color_space" , "longitude" , "latitude" , "codecs" , "device_make" , "device_model" , "device_software" , "focal_length" , "shutter_speed" , "orientation" , "copyright" , "flash" , "artist" , "duration" , "fps" , "streams" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: media_data :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: media_data :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "MediaData" , available relations are "id, date_created, date_taken, pixel_width, pixel_height, color_space, longitude, latitude, codecs, device_make, device_model, device_software, focal_length, shutter_speed, orientation, copyright, flash, artist, duration, fps, streams, object")) } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: id :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_taken) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: date_taken :: Select) } ; (@ selection_field_to_selection_param ; pixel_width) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: pixel_width :: Select) } ; (@ selection_field_to_selection_param ; pixel_height) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: pixel_height :: Select) } ; (@ selection_field_to_selection_param ; color_space) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: color_space :: Select) } ; (@ selection_field_to_selection_param ; longitude) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: longitude :: Select) } ; (@ selection_field_to_selection_param ; latitude) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: latitude :: Select) } ; (@ selection_field_to_selection_param ; codecs) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: codecs :: Select) } ; (@ selection_field_to_selection_param ; device_make) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: device_make :: Select) } ; (@ selection_field_to_selection_param ; device_model) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: device_model :: Select) } ; (@ selection_field_to_selection_param ; device_software) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: device_software :: Select) } ; (@ selection_field_to_selection_param ; focal_length) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: focal_length :: Select) } ; (@ selection_field_to_selection_param ; shutter_speed) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: shutter_speed :: Select) } ; (@ selection_field_to_selection_param ; orientation) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: orientation :: Select) } ; (@ selection_field_to_selection_param ; copyright) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: copyright :: Select) } ; (@ selection_field_to_selection_param ; flash) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: flash :: Select) } ; (@ selection_field_to_selection_param ; artist) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: artist :: Select) } ; (@ selection_field_to_selection_param ; duration) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: duration :: Select) } ; (@ selection_field_to_selection_param ; fps) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: fps :: Select) } ; (@ selection_field_to_selection_param ; streams) => { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: streams :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: object :: Select :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: media_data :: SelectParam > :: into (sd_prisma :: prisma :: media_data :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: media_data :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_taken) => { "date_taken" } ; (@ field_serde_name ; pixel_width) => { "pixel_width" } ; (@ field_serde_name ; pixel_height) => { "pixel_height" } ; (@ field_serde_name ; color_space) => { "color_space" } ; (@ field_serde_name ; longitude) => { "longitude" } ; (@ field_serde_name ; latitude) => { "latitude" } ; (@ field_serde_name ; codecs) => { "codecs" } ; (@ field_serde_name ; device_make) => { "device_make" } ; (@ field_serde_name ; device_model) => { "device_model" } ; (@ field_serde_name ; device_software) => { "device_software" } ; (@ field_serde_name ; focal_length) => { "focal_length" } ; (@ field_serde_name ; shutter_speed) => { "shutter_speed" } ; (@ field_serde_name ; orientation) => { "orientation" } ; (@ field_serde_name ; copyright) => { "copyright" } ; (@ field_serde_name ; flash) => { "flash" } ; (@ field_serde_name ; artist) => { "artist" } ; (@ field_serde_name ; duration) => { "duration" } ; (@ field_serde_name ; fps) => { "fps" } ; (@ field_serde_name ; streams) => { "streams" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_media_data as select;
	pub enum SelectParam {
		Id(id::Select),
		DateCreated(date_created::Select),
		DateTaken(date_taken::Select),
		PixelWidth(pixel_width::Select),
		PixelHeight(pixel_height::Select),
		ColorSpace(color_space::Select),
		Longitude(longitude::Select),
		Latitude(latitude::Select),
		Codecs(codecs::Select),
		DeviceMake(device_make::Select),
		DeviceModel(device_model::Select),
		DeviceSoftware(device_software::Select),
		FocalLength(focal_length::Select),
		ShutterSpeed(shutter_speed::Select),
		Orientation(orientation::Select),
		Copyright(copyright::Select),
		Flash(flash::Select),
		Artist(artist::Select),
		Duration(duration::Select),
		Fps(fps::Select),
		Streams(streams::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateTaken(data) => data.to_selection(),
				Self::PixelWidth(data) => data.to_selection(),
				Self::PixelHeight(data) => data.to_selection(),
				Self::ColorSpace(data) => data.to_selection(),
				Self::Longitude(data) => data.to_selection(),
				Self::Latitude(data) => data.to_selection(),
				Self::Codecs(data) => data.to_selection(),
				Self::DeviceMake(data) => data.to_selection(),
				Self::DeviceModel(data) => data.to_selection(),
				Self::DeviceSoftware(data) => data.to_selection(),
				Self::FocalLength(data) => data.to_selection(),
				Self::ShutterSpeed(data) => data.to_selection(),
				Self::Orientation(data) => data.to_selection(),
				Self::Copyright(data) => data.to_selection(),
				Self::Flash(data) => data.to_selection(),
				Self::Artist(data) => data.to_selection(),
				Self::Duration(data) => data.to_selection(),
				Self::Fps(data) => data.to_selection(),
				Self::Streams(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_media_data { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: media_data :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: media_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: media_data :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: media_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: media_data :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: media_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: media_data :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: media_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: media_data :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: date_created :: NAME)] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: date_taken :: NAME)] pub date_taken : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: pixel_width :: NAME)] pub pixel_width : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: pixel_height :: NAME)] pub pixel_height : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: color_space :: NAME)] pub color_space : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: longitude :: NAME)] pub longitude : Option < f64 > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: latitude :: NAME)] pub latitude : Option < f64 > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: codecs :: NAME)] pub codecs : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: device_make :: NAME)] pub device_make : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: device_model :: NAME)] pub device_model : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: device_software :: NAME)] pub device_software : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: focal_length :: NAME)] pub focal_length : Option < f64 > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: shutter_speed :: NAME)] pub shutter_speed : Option < f64 > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: orientation :: NAME)] pub orientation : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: copyright :: NAME)] pub copyright : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: flash :: NAME)] pub flash : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: artist :: NAME)] pub artist : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: duration :: NAME)] pub duration : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: fps :: NAME)] pub fps : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: media_data :: streams :: NAME)] pub streams : Option < i32 > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: media_data :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: media_data :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (date_created) , stringify ! (date_taken) , stringify ! (pixel_width) , stringify ! (pixel_height) , stringify ! (color_space) , stringify ! (longitude) , stringify ! (latitude) , stringify ! (codecs) , stringify ! (device_make) , stringify ! (device_model) , stringify ! (device_software) , stringify ! (focal_length) , stringify ! (shutter_speed) , stringify ! (orientation) , stringify ! (copyright) , stringify ! (flash) , stringify ! (artist) , stringify ! (duration) , stringify ! (fps) , stringify ! (streams)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: media_data :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: media_data :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: date_taken :: NAME , & self . date_taken) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: pixel_width :: NAME , & self . pixel_width) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: pixel_height :: NAME , & self . pixel_height) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: color_space :: NAME , & self . color_space) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: longitude :: NAME , & self . longitude) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: latitude :: NAME , & self . latitude) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: codecs :: NAME , & self . codecs) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: device_make :: NAME , & self . device_make) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: device_model :: NAME , & self . device_model) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: device_software :: NAME , & self . device_software) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: focal_length :: NAME , & self . focal_length) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: shutter_speed :: NAME , & self . shutter_speed) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: orientation :: NAME , & self . orientation) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: copyright :: NAME , & self . copyright) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: flash :: NAME , & self . flash) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: artist :: NAME , & self . artist) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: duration :: NAME , & self . duration) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: fps :: NAME , & self . fps) ? ; state . serialize_field (sd_prisma :: prisma :: media_data :: streams :: NAME , & self . streams) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , date_created , date_taken , pixel_width , pixel_height , color_space , longitude , latitude , codecs , device_make , device_model , device_software , focal_length , shutter_speed , orientation , copyright , flash , artist , duration , fps , streams } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: media_data :: $ field :: NAME) , + , sd_prisma :: prisma :: media_data :: id :: NAME , sd_prisma :: prisma :: media_data :: date_created :: NAME , sd_prisma :: prisma :: media_data :: date_taken :: NAME , sd_prisma :: prisma :: media_data :: pixel_width :: NAME , sd_prisma :: prisma :: media_data :: pixel_height :: NAME , sd_prisma :: prisma :: media_data :: color_space :: NAME , sd_prisma :: prisma :: media_data :: longitude :: NAME , sd_prisma :: prisma :: media_data :: latitude :: NAME , sd_prisma :: prisma :: media_data :: codecs :: NAME , sd_prisma :: prisma :: media_data :: device_make :: NAME , sd_prisma :: prisma :: media_data :: device_model :: NAME , sd_prisma :: prisma :: media_data :: device_software :: NAME , sd_prisma :: prisma :: media_data :: focal_length :: NAME , sd_prisma :: prisma :: media_data :: shutter_speed :: NAME , sd_prisma :: prisma :: media_data :: orientation :: NAME , sd_prisma :: prisma :: media_data :: copyright :: NAME , sd_prisma :: prisma :: media_data :: flash :: NAME , sd_prisma :: prisma :: media_data :: artist :: NAME , sd_prisma :: prisma :: media_data :: duration :: NAME , sd_prisma :: prisma :: media_data :: fps :: NAME , sd_prisma :: prisma :: media_data :: streams :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: media_data :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: media_data :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: media_data :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: media_data :: date_taken :: NAME => Ok (Field :: date_taken) , sd_prisma :: prisma :: media_data :: pixel_width :: NAME => Ok (Field :: pixel_width) , sd_prisma :: prisma :: media_data :: pixel_height :: NAME => Ok (Field :: pixel_height) , sd_prisma :: prisma :: media_data :: color_space :: NAME => Ok (Field :: color_space) , sd_prisma :: prisma :: media_data :: longitude :: NAME => Ok (Field :: longitude) , sd_prisma :: prisma :: media_data :: latitude :: NAME => Ok (Field :: latitude) , sd_prisma :: prisma :: media_data :: codecs :: NAME => Ok (Field :: codecs) , sd_prisma :: prisma :: media_data :: device_make :: NAME => Ok (Field :: device_make) , sd_prisma :: prisma :: media_data :: device_model :: NAME => Ok (Field :: device_model) , sd_prisma :: prisma :: media_data :: device_software :: NAME => Ok (Field :: device_software) , sd_prisma :: prisma :: media_data :: focal_length :: NAME => Ok (Field :: focal_length) , sd_prisma :: prisma :: media_data :: shutter_speed :: NAME => Ok (Field :: shutter_speed) , sd_prisma :: prisma :: media_data :: orientation :: NAME => Ok (Field :: orientation) , sd_prisma :: prisma :: media_data :: copyright :: NAME => Ok (Field :: copyright) , sd_prisma :: prisma :: media_data :: flash :: NAME => Ok (Field :: flash) , sd_prisma :: prisma :: media_data :: artist :: NAME => Ok (Field :: artist) , sd_prisma :: prisma :: media_data :: duration :: NAME => Ok (Field :: duration) , sd_prisma :: prisma :: media_data :: fps :: NAME => Ok (Field :: fps) , sd_prisma :: prisma :: media_data :: streams :: NAME => Ok (Field :: streams) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut date_created = None ; let mut date_taken = None ; let mut pixel_width = None ; let mut pixel_height = None ; let mut color_space = None ; let mut longitude = None ; let mut latitude = None ; let mut codecs = None ; let mut device_make = None ; let mut device_model = None ; let mut device_software = None ; let mut focal_length = None ; let mut shutter_speed = None ; let mut orientation = None ; let mut copyright = None ; let mut flash = None ; let mut artist = None ; let mut duration = None ; let mut fps = None ; let mut streams = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_taken => { if date_taken . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: date_taken :: NAME)) ; } date_taken = Some (map . next_value () ?) ; } Field :: pixel_width => { if pixel_width . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: pixel_width :: NAME)) ; } pixel_width = Some (map . next_value () ?) ; } Field :: pixel_height => { if pixel_height . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: pixel_height :: NAME)) ; } pixel_height = Some (map . next_value () ?) ; } Field :: color_space => { if color_space . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: color_space :: NAME)) ; } color_space = Some (map . next_value () ?) ; } Field :: longitude => { if longitude . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: longitude :: NAME)) ; } longitude = Some (map . next_value () ?) ; } Field :: latitude => { if latitude . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: latitude :: NAME)) ; } latitude = Some (map . next_value () ?) ; } Field :: codecs => { if codecs . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: codecs :: NAME)) ; } codecs = Some (map . next_value () ?) ; } Field :: device_make => { if device_make . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: device_make :: NAME)) ; } device_make = Some (map . next_value () ?) ; } Field :: device_model => { if device_model . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: device_model :: NAME)) ; } device_model = Some (map . next_value () ?) ; } Field :: device_software => { if device_software . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: device_software :: NAME)) ; } device_software = Some (map . next_value () ?) ; } Field :: focal_length => { if focal_length . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: focal_length :: NAME)) ; } focal_length = Some (map . next_value () ?) ; } Field :: shutter_speed => { if shutter_speed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: shutter_speed :: NAME)) ; } shutter_speed = Some (map . next_value () ?) ; } Field :: orientation => { if orientation . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: orientation :: NAME)) ; } orientation = Some (map . next_value () ?) ; } Field :: copyright => { if copyright . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: copyright :: NAME)) ; } copyright = Some (map . next_value () ?) ; } Field :: flash => { if flash . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: flash :: NAME)) ; } flash = Some (map . next_value () ?) ; } Field :: artist => { if artist . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: artist :: NAME)) ; } artist = Some (map . next_value () ?) ; } Field :: duration => { if duration . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: duration :: NAME)) ; } duration = Some (map . next_value () ?) ; } Field :: fps => { if fps . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: fps :: NAME)) ; } fps = Some (map . next_value () ?) ; } Field :: streams => { if streams . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: streams :: NAME)) ; } streams = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: media_data :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: id :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: date_created :: NAME)) ? ; let date_taken = date_taken . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: date_taken :: NAME)) ? ; let pixel_width = pixel_width . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: pixel_width :: NAME)) ? ; let pixel_height = pixel_height . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: pixel_height :: NAME)) ? ; let color_space = color_space . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: color_space :: NAME)) ? ; let longitude = longitude . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: longitude :: NAME)) ? ; let latitude = latitude . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: latitude :: NAME)) ? ; let codecs = codecs . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: codecs :: NAME)) ? ; let device_make = device_make . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: device_make :: NAME)) ? ; let device_model = device_model . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: device_model :: NAME)) ? ; let device_software = device_software . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: device_software :: NAME)) ? ; let focal_length = focal_length . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: focal_length :: NAME)) ? ; let shutter_speed = shutter_speed . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: shutter_speed :: NAME)) ? ; let orientation = orientation . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: orientation :: NAME)) ? ; let copyright = copyright . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: copyright :: NAME)) ? ; let flash = flash . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: flash :: NAME)) ? ; let artist = artist . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: artist :: NAME)) ? ; let duration = duration . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: duration :: NAME)) ? ; let fps = fps . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: fps :: NAME)) ? ; let streams = streams . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: media_data :: streams :: NAME)) ? ; Ok (Data { id , date_created , date_taken , pixel_width , pixel_height , color_space , longitude , latitude , codecs , device_make , device_model , device_software , focal_length , shutter_speed , orientation , copyright , flash , artist , duration , fps , streams , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "date_created" , "date_taken" , "pixel_width" , "pixel_height" , "color_space" , "longitude" , "latitude" , "codecs" , "device_make" , "device_model" , "device_software" , "focal_length" , "shutter_speed" , "orientation" , "copyright" , "flash" , "artist" , "duration" , "fps" , "streams" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: media_data :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: media_data :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "MediaData" , available relations are "object")) } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: media_data :: IncludeParam > :: into (sd_prisma :: prisma :: media_data :: object :: Include :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: media_data :: IncludeParam > :: into (sd_prisma :: prisma :: media_data :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: media_data :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_taken) => { "date_taken" } ; (@ field_serde_name ; pixel_width) => { "pixel_width" } ; (@ field_serde_name ; pixel_height) => { "pixel_height" } ; (@ field_serde_name ; color_space) => { "color_space" } ; (@ field_serde_name ; longitude) => { "longitude" } ; (@ field_serde_name ; latitude) => { "latitude" } ; (@ field_serde_name ; codecs) => { "codecs" } ; (@ field_serde_name ; device_make) => { "device_make" } ; (@ field_serde_name ; device_model) => { "device_model" } ; (@ field_serde_name ; device_software) => { "device_software" } ; (@ field_serde_name ; focal_length) => { "focal_length" } ; (@ field_serde_name ; shutter_speed) => { "shutter_speed" } ; (@ field_serde_name ; orientation) => { "orientation" } ; (@ field_serde_name ; copyright) => { "copyright" } ; (@ field_serde_name ; flash) => { "flash" } ; (@ field_serde_name ; artist) => { "artist" } ; (@ field_serde_name ; duration) => { "duration" } ; (@ field_serde_name ; fps) => { "fps" } ; (@ field_serde_name ; streams) => { "streams" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_media_data as include;
	pub enum IncludeParam {
		Id(id::Include),
		DateCreated(date_created::Include),
		DateTaken(date_taken::Include),
		PixelWidth(pixel_width::Include),
		PixelHeight(pixel_height::Include),
		ColorSpace(color_space::Include),
		Longitude(longitude::Include),
		Latitude(latitude::Include),
		Codecs(codecs::Include),
		DeviceMake(device_make::Include),
		DeviceModel(device_model::Include),
		DeviceSoftware(device_software::Include),
		FocalLength(focal_length::Include),
		ShutterSpeed(shutter_speed::Include),
		Orientation(orientation::Include),
		Copyright(copyright::Include),
		Flash(flash::Include),
		Artist(artist::Include),
		Duration(duration::Include),
		Fps(fps::Include),
		Streams(streams::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateTaken(data) => data.to_selection(),
				Self::PixelWidth(data) => data.to_selection(),
				Self::PixelHeight(data) => data.to_selection(),
				Self::ColorSpace(data) => data.to_selection(),
				Self::Longitude(data) => data.to_selection(),
				Self::Latitude(data) => data.to_selection(),
				Self::Codecs(data) => data.to_selection(),
				Self::DeviceMake(data) => data.to_selection(),
				Self::DeviceModel(data) => data.to_selection(),
				Self::DeviceSoftware(data) => data.to_selection(),
				Self::FocalLength(data) => data.to_selection(),
				Self::ShutterSpeed(data) => data.to_selection(),
				Self::Orientation(data) => data.to_selection(),
				Self::Copyright(data) => data.to_selection(),
				Self::Flash(data) => data.to_selection(),
				Self::Artist(data) => data.to_selection(),
				Self::Duration(data) => data.to_selection(),
				Self::Fps(data) => data.to_selection(),
				Self::Streams(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod artist {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "artist";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Artist(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Artist,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Artist(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Artist(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Artist(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Artist(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Artist(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Artist(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Artist(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod codecs {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "codecs";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Codecs(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Codecs,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Codecs(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Codecs(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Codecs(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Codecs(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Codecs(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Codecs(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Codecs(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod color_space {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "color_space";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::ColorSpace(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			ColorSpace,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ColorSpace(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ColorSpace(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::ColorSpace(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ColorSpace(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ColorSpace(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ColorSpace(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ColorSpace(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod copyright {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "copyright";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Copyright(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Copyright,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Copyright(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Copyright(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Copyright(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Copyright(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Copyright(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Copyright(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Copyright(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_taken {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_taken";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateTaken(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateTaken,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateTaken(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateTaken(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateTaken(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateTaken(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateTaken(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateTaken(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateTaken(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod device_make {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "device_make";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::DeviceMake(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			DeviceMake,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DeviceMake(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DeviceMake(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DeviceMake(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DeviceMake(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DeviceMake(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DeviceMake(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DeviceMake(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod device_model {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "device_model";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::DeviceModel(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			DeviceModel,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DeviceModel(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DeviceModel(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DeviceModel(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DeviceModel(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DeviceModel(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DeviceModel(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DeviceModel(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod device_software {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "device_software";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::DeviceSoftware(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			DeviceSoftware,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DeviceSoftware(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DeviceSoftware(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DeviceSoftware(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DeviceSoftware(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DeviceSoftware(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DeviceSoftware(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DeviceSoftware(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod duration {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "duration";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::Duration(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			Duration,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Duration(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Duration(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Duration(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Duration(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Duration(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Duration(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Duration(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod flash {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "flash";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::Flash(_prisma::read_filters::BooleanNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			Flash,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Flash(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Flash(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Flash(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Flash(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Flash(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Flash(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Flash(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod focal_length {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "focal_length";
		pub type Type = Option<f64>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<f64>) -> WhereParam {
			WhereParam::FocalLength(_prisma::read_filters::FloatNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::FloatNullableFilter,
			FocalLength,
			{
				fn in_vec(_: Vec<f64>) -> InVec;
				fn not_in_vec(_: Vec<f64>) -> NotInVec;
				fn lt(_: f64) -> Lt;
				fn lte(_: f64) -> Lte;
				fn gt(_: f64) -> Gt;
				fn gte(_: f64) -> Gte;
				fn not(_: Option<f64>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::FocalLength(v)
			}
		}
		pub struct Set(pub Option<f64>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::FocalLength(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::FocalLength(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<f64>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::FloatNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::FocalLength(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::FocalLength(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::FocalLength(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::FocalLength(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod fps {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "fps";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::Fps(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			Fps,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Fps(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Fps(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Fps(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Fps(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Fps(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Fps(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Fps(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod latitude {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "latitude";
		pub type Type = Option<f64>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<f64>) -> WhereParam {
			WhereParam::Latitude(_prisma::read_filters::FloatNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::FloatNullableFilter,
			Latitude,
			{
				fn in_vec(_: Vec<f64>) -> InVec;
				fn not_in_vec(_: Vec<f64>) -> NotInVec;
				fn lt(_: f64) -> Lt;
				fn lte(_: f64) -> Lte;
				fn gt(_: f64) -> Gt;
				fn gte(_: f64) -> Gte;
				fn not(_: Option<f64>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Latitude(v)
			}
		}
		pub struct Set(pub Option<f64>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Latitude(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Latitude(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<f64>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::FloatNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Latitude(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Latitude(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Latitude(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Latitude(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod longitude {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "longitude";
		pub type Type = Option<f64>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<f64>) -> WhereParam {
			WhereParam::Longitude(_prisma::read_filters::FloatNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::FloatNullableFilter,
			Longitude,
			{
				fn in_vec(_: Vec<f64>) -> InVec;
				fn not_in_vec(_: Vec<f64>) -> NotInVec;
				fn lt(_: f64) -> Lt;
				fn lte(_: f64) -> Lte;
				fn gt(_: f64) -> Gt;
				fn gte(_: f64) -> Gte;
				fn not(_: Option<f64>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Longitude(v)
			}
		}
		pub struct Set(pub Option<f64>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Longitude(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Longitude(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<f64>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::FloatNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Longitude(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Longitude(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Longitude(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Longitude(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub type Type = Option<object::Data>;
		pub type RecursiveSafeType = Option<Box<object::Data>>;
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectObject
		}
		pub fn is_null() -> WhereParam {
			WhereParam::ObjectIsNull
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod orientation {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "orientation";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Orientation(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Orientation,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Orientation(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Orientation(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Orientation(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Orientation(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Orientation(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Orientation(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Orientation(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pixel_height {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pixel_height";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::PixelHeight(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			PixelHeight,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PixelHeight(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PixelHeight(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PixelHeight(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PixelHeight(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PixelHeight(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PixelHeight(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PixelHeight(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pixel_width {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pixel_width";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::PixelWidth(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			PixelWidth,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PixelWidth(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PixelWidth(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PixelWidth(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PixelWidth(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PixelWidth(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PixelWidth(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PixelWidth(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod shutter_speed {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "shutter_speed";
		pub type Type = Option<f64>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<f64>) -> WhereParam {
			WhereParam::ShutterSpeed(_prisma::read_filters::FloatNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::FloatNullableFilter,
			ShutterSpeed,
			{
				fn in_vec(_: Vec<f64>) -> InVec;
				fn not_in_vec(_: Vec<f64>) -> NotInVec;
				fn lt(_: f64) -> Lt;
				fn lte(_: f64) -> Lte;
				fn gt(_: f64) -> Gt;
				fn gte(_: f64) -> Gte;
				fn not(_: Option<f64>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ShutterSpeed(v)
			}
		}
		pub struct Set(pub Option<f64>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ShutterSpeed(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::ShutterSpeed(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<f64>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::FloatNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ShutterSpeed(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ShutterSpeed(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ShutterSpeed(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ShutterSpeed(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod streams {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "streams";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::Streams(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			Streams,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Streams(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Streams(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Streams(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Streams(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Streams(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Streams(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Streams(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.media_data().create(self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([]);
			self._params
		}
	}
	pub fn create(_params: Vec<SetParam>) -> Create {
		Create { _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.media_data().create_unchecked(self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([]);
			self._params
		}
	}
	pub fn create_unchecked(_params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_taken::NAME),
				::prisma_client_rust::sel(pixel_width::NAME),
				::prisma_client_rust::sel(pixel_height::NAME),
				::prisma_client_rust::sel(color_space::NAME),
				::prisma_client_rust::sel(longitude::NAME),
				::prisma_client_rust::sel(latitude::NAME),
				::prisma_client_rust::sel(codecs::NAME),
				::prisma_client_rust::sel(device_make::NAME),
				::prisma_client_rust::sel(device_model::NAME),
				::prisma_client_rust::sel(device_software::NAME),
				::prisma_client_rust::sel(focal_length::NAME),
				::prisma_client_rust::sel(shutter_speed::NAME),
				::prisma_client_rust::sel(orientation::NAME),
				::prisma_client_rust::sel(copyright::NAME),
				::prisma_client_rust::sel(flash::NAME),
				::prisma_client_rust::sel(artist::NAME),
				::prisma_client_rust::sel(duration::NAME),
				::prisma_client_rust::sel(fps::NAME),
				::prisma_client_rust::sel(streams::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "MediaData", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "date_taken")]
		pub date_taken: date_taken::Type,
		#[serde(rename = "pixel_width")]
		pub pixel_width: pixel_width::Type,
		#[serde(rename = "pixel_height")]
		pub pixel_height: pixel_height::Type,
		#[serde(rename = "color_space")]
		pub color_space: color_space::Type,
		#[serde(rename = "longitude")]
		pub longitude: longitude::Type,
		#[serde(rename = "latitude")]
		pub latitude: latitude::Type,
		#[serde(rename = "codecs")]
		pub codecs: codecs::Type,
		#[serde(rename = "device_make")]
		pub device_make: device_make::Type,
		#[serde(rename = "device_model")]
		pub device_model: device_model::Type,
		#[serde(rename = "device_software")]
		pub device_software: device_software::Type,
		#[serde(rename = "focal_length")]
		pub focal_length: focal_length::Type,
		#[serde(rename = "shutter_speed")]
		pub shutter_speed: shutter_speed::Type,
		#[serde(rename = "orientation")]
		pub orientation: orientation::Type,
		#[serde(rename = "copyright")]
		pub copyright: copyright::Type,
		#[serde(rename = "flash")]
		pub flash: flash::Type,
		#[serde(rename = "artist")]
		pub artist: artist::Type,
		#[serde(rename = "duration")]
		pub duration: duration::Type,
		#[serde(rename = "fps")]
		pub fps: fps::Type,
		#[serde(rename = "streams")]
		pub streams: streams::Type,
		#[serde(
			rename = "object",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub object: Option<object::RecursiveSafeType>,
	}
	impl Data {
		pub fn object(
			&self,
		) -> Result<Option<&super::object::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_media_data { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: media_data struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "date_created")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_taken")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_taken : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "pixel_width")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub pixel_width : Option < i32 > , # [serde (rename = "pixel_height")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub pixel_height : Option < i32 > , # [serde (rename = "color_space")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub color_space : Option < String > , # [serde (rename = "longitude")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub longitude : Option < f64 > , # [serde (rename = "latitude")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub latitude : Option < f64 > , # [serde (rename = "codecs")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub codecs : Option < String > , # [serde (rename = "device_make")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub device_make : Option < String > , # [serde (rename = "device_model")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub device_model : Option < String > , # [serde (rename = "device_software")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub device_software : Option < String > , # [serde (rename = "focal_length")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub focal_length : Option < f64 > , # [serde (rename = "shutter_speed")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub shutter_speed : Option < f64 > , # [serde (rename = "orientation")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub orientation : Option < String > , # [serde (rename = "copyright")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub copyright : Option < String > , # [serde (rename = "flash")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub flash : Option < bool > , # [serde (rename = "artist")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub artist : Option < String > , # [serde (rename = "duration")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub duration : Option < i32 > , # [serde (rename = "fps")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub fps : Option < i32 > , # [serde (rename = "streams")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub streams : Option < i32 > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_media_data as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod tag {
	use super::_prisma::*;
	pub const NAME: &str = "Tag";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		Color(super::_prisma::read_filters::StringNullableFilter),
		RedundancyGoal(super::_prisma::read_filters::IntNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
		DateModified(super::_prisma::read_filters::DateTimeNullableFilter),
		TagObjectsSome(Vec<super::tag_on_object::WhereParam>),
		TagObjectsEvery(Vec<super::tag_on_object::WhereParam>),
		TagObjectsNone(Vec<super::tag_on_object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Color(value) => (color::NAME, value.into()),
				Self::RedundancyGoal(value) => (redundancy_goal::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::TagObjectsSome(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagObjectsEvery(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagObjectsNone(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		Color(super::SortOrder),
		RedundancyGoal(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		TagObjects(Vec<super::tag_on_object::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Color(param) => ("color", param.into()),
				Self::RedundancyGoal(param) => ("redundancy_goal", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::TagObjects(param) => (
					"tag_objects",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		TagObjects(super::tag_on_object::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::TagObjects(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						tag_objects::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Color(super::_prisma::write_params::StringNullableParam),
		RedundancyGoal(super::_prisma::write_params::IntNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateModified(super::_prisma::write_params::DateTimeNullableParam),
		ConnectTagObjects(Vec<super::tag_on_object::UniqueWhereParam>),
		DisconnectTagObjects(Vec<super::tag_on_object::UniqueWhereParam>),
		SetTagObjects(Vec<super::tag_on_object::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Color(value) => (color::NAME, value.into()),
				Self::RedundancyGoal(value) => (redundancy_goal::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ConnectTagObjects(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectTagObjects(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetTagObjects(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Color(super::_prisma::write_params::StringNullableParam),
		RedundancyGoal(super::_prisma::write_params::IntNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateModified(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Color(value) => ("color", value.into()),
				Self::RedundancyGoal(value) => ("redundancy_goal", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_tag { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: tag :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: tag :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: tag :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: tag :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: tag :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: tag :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , color , redundancy_goal , date_created , date_modified , tag_objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: tag :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: tag :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: tag :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: tag :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: tag :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: tag :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "color" , "redundancy_goal" , "date_created" , "date_modified" , "tag_objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: tag :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; tag_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tag_objects :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: tag :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Tag" , available relations are "id, pub_id, name, color, redundancy_goal, date_created, date_modified, tag_objects")) } ; (@ field_module ; tag_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: tag_on_object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: tag :: SelectParam > :: into (sd_prisma :: prisma :: tag :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < sd_prisma :: prisma :: tag :: SelectParam > :: into (sd_prisma :: prisma :: tag :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < sd_prisma :: prisma :: tag :: SelectParam > :: into (sd_prisma :: prisma :: tag :: name :: Select) } ; (@ selection_field_to_selection_param ; color) => { Into :: < sd_prisma :: prisma :: tag :: SelectParam > :: into (sd_prisma :: prisma :: tag :: color :: Select) } ; (@ selection_field_to_selection_param ; redundancy_goal) => { Into :: < sd_prisma :: prisma :: tag :: SelectParam > :: into (sd_prisma :: prisma :: tag :: redundancy_goal :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: tag :: SelectParam > :: into (sd_prisma :: prisma :: tag :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < sd_prisma :: prisma :: tag :: SelectParam > :: into (sd_prisma :: prisma :: tag :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; tag_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: tag :: SelectParam > :: into (sd_prisma :: prisma :: tag :: tag_objects :: Select :: $ selection_mode (sd_prisma :: prisma :: tag_on_object :: ManyArgs :: new (sd_prisma :: prisma :: tag_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tag_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: tag :: SelectParam > :: into (sd_prisma :: prisma :: tag :: tag_objects :: Select :: Fetch (sd_prisma :: prisma :: tag_on_object :: ManyArgs :: new (sd_prisma :: prisma :: tag_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: tag :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; color) => { "color" } ; (@ field_serde_name ; redundancy_goal) => { "redundancy_goal" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; tag_objects) => { "tag_objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_tag as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		Color(color::Select),
		RedundancyGoal(redundancy_goal::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		TagObjects(tag_objects::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Color(data) => data.to_selection(),
				Self::RedundancyGoal(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::TagObjects(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_tag { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: tag :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: tag :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: tag :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: tag :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: tag :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: tag :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: tag :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: tag :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { tag_objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: tag :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: tag :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: tag :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: tag :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: tag :: color :: NAME)] pub color : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: tag :: redundancy_goal :: NAME)] pub redundancy_goal : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: tag :: date_created :: NAME)] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: tag :: date_modified :: NAME)] pub date_modified : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: tag :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: tag :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (color) , stringify ! (redundancy_goal) , stringify ! (date_created) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: tag :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: tag :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: tag :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (sd_prisma :: prisma :: tag :: name :: NAME , & self . name) ? ; state . serialize_field (sd_prisma :: prisma :: tag :: color :: NAME , & self . color) ? ; state . serialize_field (sd_prisma :: prisma :: tag :: redundancy_goal :: NAME , & self . redundancy_goal) ? ; state . serialize_field (sd_prisma :: prisma :: tag :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: tag :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , color , redundancy_goal , date_created , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: tag :: $ field :: NAME) , + , sd_prisma :: prisma :: tag :: id :: NAME , sd_prisma :: prisma :: tag :: pub_id :: NAME , sd_prisma :: prisma :: tag :: name :: NAME , sd_prisma :: prisma :: tag :: color :: NAME , sd_prisma :: prisma :: tag :: redundancy_goal :: NAME , sd_prisma :: prisma :: tag :: date_created :: NAME , sd_prisma :: prisma :: tag :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: tag :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: tag :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: tag :: pub_id :: NAME => Ok (Field :: pub_id) , sd_prisma :: prisma :: tag :: name :: NAME => Ok (Field :: name) , sd_prisma :: prisma :: tag :: color :: NAME => Ok (Field :: color) , sd_prisma :: prisma :: tag :: redundancy_goal :: NAME => Ok (Field :: redundancy_goal) , sd_prisma :: prisma :: tag :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: tag :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut color = None ; let mut redundancy_goal = None ; let mut date_created = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: color => { if color . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag :: color :: NAME)) ; } color = Some (map . next_value () ?) ; } Field :: redundancy_goal => { if redundancy_goal . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag :: redundancy_goal :: NAME)) ; } redundancy_goal = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag :: name :: NAME)) ? ; let color = color . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag :: color :: NAME)) ? ; let redundancy_goal = redundancy_goal . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag :: redundancy_goal :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag :: date_modified :: NAME)) ? ; Ok (Data { id , pub_id , name , color , redundancy_goal , date_created , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "color" , "redundancy_goal" , "date_created" , "date_modified" , "tag_objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: tag :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; tag_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tag_objects :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: tag :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Tag" , available relations are "tag_objects")) } ; (@ field_module ; tag_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: tag_on_object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; tag_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: tag :: IncludeParam > :: into (sd_prisma :: prisma :: tag :: tag_objects :: Include :: $ selection_mode (sd_prisma :: prisma :: tag_on_object :: ManyArgs :: new (sd_prisma :: prisma :: tag_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tag_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: tag :: IncludeParam > :: into (sd_prisma :: prisma :: tag :: tag_objects :: Include :: Fetch (sd_prisma :: prisma :: tag_on_object :: ManyArgs :: new (sd_prisma :: prisma :: tag_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: tag :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; color) => { "color" } ; (@ field_serde_name ; redundancy_goal) => { "redundancy_goal" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; tag_objects) => { "tag_objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_tag as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		Color(color::Include),
		RedundancyGoal(redundancy_goal::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		TagObjects(tag_objects::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Color(data) => data.to_selection(),
				Self::RedundancyGoal(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::TagObjects(data) => data.to_selection(),
			}
		}
	}
	pub mod color {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "color";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Color(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Color,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Color(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Color(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Color(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Color(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Color(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Color(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Color(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod redundancy_goal {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "redundancy_goal";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::RedundancyGoal(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			RedundancyGoal,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::RedundancyGoal(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RedundancyGoal(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::RedundancyGoal(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::RedundancyGoal(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RedundancyGoal(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::RedundancyGoal(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::RedundancyGoal(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod tag_objects {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "tag_objects";
		pub type Type = Vec<tag_on_object::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagObjectsSome(value)
		}
		pub fn every(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagObjectsEvery(value)
		}
		pub fn none(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagObjectsNone(value)
		}
		pub struct Order(Vec<tag_on_object::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<tag_on_object::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TagObjects(v)
			}
		}
		pub struct Fetch(pub tag_on_object::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<tag_on_object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: tag_on_object::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: tag_on_object::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::TagObjects(v)
			}
		}
		pub fn fetch(params: Vec<tag_on_object::WhereParam>) -> Fetch {
			Fetch(tag_on_object::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<tag_on_object::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectTagObjects(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<tag_on_object::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<tag_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectTagObjects(params)
		}
		pub fn set(params: Vec<tag_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::SetTagObjects(params)
		}
		pub enum Select {
			Select(tag_on_object::ManyArgs, Vec<tag_on_object::SelectParam>),
			Include(tag_on_object::ManyArgs, Vec<tag_on_object::IncludeParam>),
			Fetch(tag_on_object::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TagObjects(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(tag_on_object::ManyArgs, Vec<tag_on_object::SelectParam>),
			Include(tag_on_object::ManyArgs, Vec<tag_on_object::IncludeParam>),
			Fetch(tag_on_object::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TagObjects(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.tag().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.tag().create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(color::NAME),
				::prisma_client_rust::sel(redundancy_goal::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Tag", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: pub_id::Type,
		#[serde(rename = "name")]
		pub name: name::Type,
		#[serde(rename = "color")]
		pub color: color::Type,
		#[serde(rename = "redundancy_goal")]
		pub redundancy_goal: redundancy_goal::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "date_modified")]
		pub date_modified: date_modified::Type,
		#[serde(rename = "tag_objects")]
		#[specta(skip)]
		pub tag_objects: Option<tag_objects::RecursiveSafeType>,
	}
	impl Data {
		pub fn tag_objects(
			&self,
		) -> Result<&tag_objects::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.tag_objects
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(tag_objects),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_tag { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: tag struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "color")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub color : Option < String > , # [serde (rename = "redundancy_goal")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub redundancy_goal : Option < i32 > , # [serde (rename = "date_created")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_modified")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_modified : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_tag as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod tag_on_object {
	use super::_prisma::*;
	pub const NAME: &str = "TagOnObject";
	pub fn tag_id_object_id<T: From<UniqueWhereParam>>(tag_id: i32, object_id: i32) -> T {
		UniqueWhereParam::TagIdObjectIdEquals(tag_id, object_id).into()
	}
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		TagIdObjectIdEquals(i32, i32),
		TagId(super::_prisma::read_filters::IntFilter),
		TagIs(Vec<super::tag::WhereParam>),
		TagIsNot(Vec<super::tag::WhereParam>),
		ObjectId(super::_prisma::read_filters::IntFilter),
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::TagIdObjectIdEquals(tag_id, object_id) => (
					"tag_id_object_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							tag_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(tag_id as i64),
						),
						(
							object_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(object_id as i64),
						),
					]),
				),
				Self::TagId(value) => (tag_id::NAME, value.into()),
				Self::TagIs(where_params) => (
					tag::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagIsNot(where_params) => (
					tag::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		TagIdObjectIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::TagIdObjectIdEquals(tag_id, object_id) => {
					Self::TagIdObjectIdEquals(tag_id, object_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		TagId(super::SortOrder),
		ObjectId(super::SortOrder),
		Tag(Vec<super::tag::OrderByWithRelationParam>),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::TagId(param) => ("tag_id", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::Tag(param) => (
					"tag",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Tag(super::tag::UniqueArgs),
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Tag(args) => {
					let mut selections =
						<super::tag::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(tag::NAME, None, [], selections)
				}
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		TagId(super::_prisma::write_params::IntParam),
		ConnectTag(super::tag::UniqueWhereParam),
		ObjectId(super::_prisma::write_params::IntParam),
		ConnectObject(super::object::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::TagId(value) => (tag_id::NAME, value.into()),
				Self::ConnectTag(where_param) => (
					tag::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::tag::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		TagId(super::_prisma::write_params::IntParam),
		ObjectId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::TagId(value) => ("tag_id", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_tag_on_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: tag_on_object :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: tag_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: tag_on_object :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: tag_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { tag_id , tag , object_id , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: tag_on_object :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: tag_on_object :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: tag_on_object :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["tag_id" , "tag" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: tag_on_object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; tag : $ selection_mode : ident { $ ($ selections : tt) + }) => { tag :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: tag_on_object :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TagOnObject" , available relations are "tag_id, tag, object_id, object")) } ; (@ field_module ; tag : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: tag :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; tag_id) => { Into :: < sd_prisma :: prisma :: tag_on_object :: SelectParam > :: into (sd_prisma :: prisma :: tag_on_object :: tag_id :: Select) } ; (@ selection_field_to_selection_param ; tag $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: tag_on_object :: SelectParam > :: into (sd_prisma :: prisma :: tag_on_object :: tag :: Select :: $ selection_mode (sd_prisma :: prisma :: tag :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tag $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: tag_on_object :: SelectParam > :: into (sd_prisma :: prisma :: tag_on_object :: tag :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < sd_prisma :: prisma :: tag_on_object :: SelectParam > :: into (sd_prisma :: prisma :: tag_on_object :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: tag_on_object :: SelectParam > :: into (sd_prisma :: prisma :: tag_on_object :: object :: Select :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: tag_on_object :: SelectParam > :: into (sd_prisma :: prisma :: tag_on_object :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: tag_on_object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; tag_id) => { "tag_id" } ; (@ field_serde_name ; tag) => { "tag" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_tag_on_object as select;
	pub enum SelectParam {
		TagId(tag_id::Select),
		Tag(tag::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::TagId(data) => data.to_selection(),
				Self::Tag(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_tag_on_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: tag_on_object :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: tag_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: tag_on_object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: tag_on_object :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: tag_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: tag_on_object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { tag , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: tag_on_object :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: tag_on_object :: tag_id :: NAME)] pub tag_id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: tag_on_object :: object_id :: NAME)] pub object_id : i32 , $ (# [specta (rename_from_path = sd_prisma :: prisma :: tag_on_object :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: tag_on_object :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (tag_id) , stringify ! (object_id)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: tag_on_object :: tag_id :: NAME , & self . tag_id) ? ; state . serialize_field (sd_prisma :: prisma :: tag_on_object :: object_id :: NAME , & self . object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , tag_id , object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME) , + , sd_prisma :: prisma :: tag_on_object :: tag_id :: NAME , sd_prisma :: prisma :: tag_on_object :: object_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: tag_on_object :: tag_id :: NAME => Ok (Field :: tag_id) , sd_prisma :: prisma :: tag_on_object :: object_id :: NAME => Ok (Field :: object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut tag_id = None ; let mut object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: tag_id => { if tag_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag_on_object :: tag_id :: NAME)) ; } tag_id = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag_on_object :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag_on_object :: $ field :: NAME)) ? ;) * let tag_id = tag_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag_on_object :: tag_id :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: tag_on_object :: object_id :: NAME)) ? ; Ok (Data { tag_id , object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["tag_id" , "tag" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: tag_on_object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; tag : $ selection_mode : ident { $ ($ selections : tt) + }) => { tag :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: tag_on_object :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TagOnObject" , available relations are "tag, object")) } ; (@ field_module ; tag : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: tag :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; tag $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: tag_on_object :: IncludeParam > :: into (sd_prisma :: prisma :: tag_on_object :: tag :: Include :: $ selection_mode (sd_prisma :: prisma :: tag :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tag $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: tag_on_object :: IncludeParam > :: into (sd_prisma :: prisma :: tag_on_object :: tag :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: tag_on_object :: IncludeParam > :: into (sd_prisma :: prisma :: tag_on_object :: object :: Include :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: tag_on_object :: IncludeParam > :: into (sd_prisma :: prisma :: tag_on_object :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: tag_on_object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; tag_id) => { "tag_id" } ; (@ field_serde_name ; tag) => { "tag" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_tag_on_object as include;
	pub enum IncludeParam {
		TagId(tag_id::Include),
		Tag(tag::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::TagId(data) => data.to_selection(),
				Self::Tag(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub type Type = object::Data;
		pub type RecursiveSafeType = Box<object::Data>;
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod tag {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "tag";
		pub type Type = tag::Data;
		pub type RecursiveSafeType = Box<tag::Data>;
		pub fn is(value: Vec<tag::WhereParam>) -> WhereParam {
			WhereParam::TagIs(value)
		}
		pub fn is_not(value: Vec<tag::WhereParam>) -> WhereParam {
			WhereParam::TagIsNot(value)
		}
		pub struct Order(Vec<tag::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<tag::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Tag(v)
			}
		}
		pub struct Fetch(pub tag::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<tag::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Tag(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(tag::UniqueArgs::new())
		}
		pub struct Connect(tag::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectTag(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: tag::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<tag::SelectParam>),
			Include(Vec<tag::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Tag(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<tag::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("tag", None, [], selections)
			}
			pub fn select(nested_selections: Vec<tag::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<tag::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<tag::SelectParam>),
			Include(Vec<tag::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Tag(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<tag::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<tag::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("tag", None, [], selections)
			}
			pub fn select(nested_selections: Vec<tag::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<tag::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod tag_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "tag_id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::TagId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, TagId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TagId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TagId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TagId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TagId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TagId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub tag: super::tag::UniqueWhereParam,
		pub object: super::object::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.tag_on_object()
				.create(self.tag, self.object, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([tag::connect(self.tag), object::connect(self.object)]);
			self._params
		}
	}
	pub fn create(
		tag: super::tag::UniqueWhereParam,
		object: super::object::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			tag,
			object,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub tag_id: i32,
		pub object_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.tag_on_object()
				.create_unchecked(self.tag_id, self.object_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([tag_id::set(self.tag_id), object_id::set(self.object_id)]);
			self._params
		}
	}
	pub fn create_unchecked(
		tag_id: i32,
		object_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			tag_id,
			object_id,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(tag_id::NAME),
				::prisma_client_rust::sel(object_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "TagOnObject", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "tag_id")]
		pub tag_id: tag_id::Type,
		#[serde(rename = "tag")]
		#[specta(skip)]
		pub tag: Option<tag::RecursiveSafeType>,
		#[serde(rename = "object_id")]
		pub object_id: object_id::Type,
		#[serde(rename = "object")]
		#[specta(skip)]
		pub object: Option<object::RecursiveSafeType>,
	}
	impl Data {
		pub fn tag(
			&self,
		) -> Result<&super::tag::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.tag
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(tag),
				))
				.map(|v| v.as_ref())
		}
		pub fn object(
			&self,
		) -> Result<&super::object::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_tag_on_object { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: tag_on_object struct $ struct_name { # [serde (rename = "tag_id")] pub tag_id : i32 , # [serde (rename = "object_id")] pub object_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_tag_on_object as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			tag: super::tag::UniqueWhereParam,
			object: super::object::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([tag::connect(tag), object::connect(object)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			tag_id: i32,
			object_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([tag_id::set(tag_id), object_id::set(object_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod label {
	use super::_prisma::*;
	pub const NAME: &str = "Label";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
		LabelObjectsSome(Vec<super::label_on_object::WhereParam>),
		LabelObjectsEvery(Vec<super::label_on_object::WhereParam>),
		LabelObjectsNone(Vec<super::label_on_object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::LabelObjectsSome(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelObjectsEvery(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelObjectsNone(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		LabelObjects(Vec<super::label_on_object::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::LabelObjects(param) => (
					"label_objects",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		LabelObjects(super::label_on_object::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::LabelObjects(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						label_objects::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		ConnectLabelObjects(Vec<super::label_on_object::UniqueWhereParam>),
		DisconnectLabelObjects(Vec<super::label_on_object::UniqueWhereParam>),
		SetLabelObjects(Vec<super::label_on_object::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ConnectLabelObjects(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectLabelObjects(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetLabelObjects(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_label { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: label :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: label :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: label :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: label :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: label :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: label :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , date_created , date_modified , label_objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: label :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: label :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: label :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: label :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: label :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: label :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "date_created" , "date_modified" , "label_objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: label :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; label_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < label_objects :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: label :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Label" , available relations are "id, pub_id, name, date_created, date_modified, label_objects")) } ; (@ field_module ; label_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: label_on_object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: label :: SelectParam > :: into (sd_prisma :: prisma :: label :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < sd_prisma :: prisma :: label :: SelectParam > :: into (sd_prisma :: prisma :: label :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < sd_prisma :: prisma :: label :: SelectParam > :: into (sd_prisma :: prisma :: label :: name :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: label :: SelectParam > :: into (sd_prisma :: prisma :: label :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < sd_prisma :: prisma :: label :: SelectParam > :: into (sd_prisma :: prisma :: label :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; label_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: label :: SelectParam > :: into (sd_prisma :: prisma :: label :: label_objects :: Select :: $ selection_mode (sd_prisma :: prisma :: label_on_object :: ManyArgs :: new (sd_prisma :: prisma :: label_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: label_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; label_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: label :: SelectParam > :: into (sd_prisma :: prisma :: label :: label_objects :: Select :: Fetch (sd_prisma :: prisma :: label_on_object :: ManyArgs :: new (sd_prisma :: prisma :: label_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: label :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; label_objects) => { "label_objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_label as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		LabelObjects(label_objects::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::LabelObjects(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_label { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: label :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: label :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: label :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: label :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: label :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: label :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: label :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: label :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { label_objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: label :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: label :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: label :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: label :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: label :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = sd_prisma :: prisma :: label :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: label :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: label :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (date_created) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: label :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: label :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: label :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (sd_prisma :: prisma :: label :: name :: NAME , & self . name) ? ; state . serialize_field (sd_prisma :: prisma :: label :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: label :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , date_created , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: label :: $ field :: NAME) , + , sd_prisma :: prisma :: label :: id :: NAME , sd_prisma :: prisma :: label :: pub_id :: NAME , sd_prisma :: prisma :: label :: name :: NAME , sd_prisma :: prisma :: label :: date_created :: NAME , sd_prisma :: prisma :: label :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: label :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: label :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: label :: pub_id :: NAME => Ok (Field :: pub_id) , sd_prisma :: prisma :: label :: name :: NAME => Ok (Field :: name) , sd_prisma :: prisma :: label :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: label :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut date_created = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label :: name :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label :: date_modified :: NAME)) ? ; Ok (Data { id , pub_id , name , date_created , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "date_created" , "date_modified" , "label_objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: label :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; label_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < label_objects :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: label :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Label" , available relations are "label_objects")) } ; (@ field_module ; label_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: label_on_object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; label_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: label :: IncludeParam > :: into (sd_prisma :: prisma :: label :: label_objects :: Include :: $ selection_mode (sd_prisma :: prisma :: label_on_object :: ManyArgs :: new (sd_prisma :: prisma :: label_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: label_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; label_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: label :: IncludeParam > :: into (sd_prisma :: prisma :: label :: label_objects :: Include :: Fetch (sd_prisma :: prisma :: label_on_object :: ManyArgs :: new (sd_prisma :: prisma :: label_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: label :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; label_objects) => { "label_objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_label as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		LabelObjects(label_objects::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::LabelObjects(data) => data.to_selection(),
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type =
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub type Type =
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod label_objects {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "label_objects";
		pub type Type = Vec<label_on_object::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelObjectsSome(value)
		}
		pub fn every(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelObjectsEvery(value)
		}
		pub fn none(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelObjectsNone(value)
		}
		pub struct Order(Vec<label_on_object::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<label_on_object::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LabelObjects(v)
			}
		}
		pub struct Fetch(pub label_on_object::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<label_on_object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: label_on_object::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: label_on_object::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::LabelObjects(v)
			}
		}
		pub fn fetch(params: Vec<label_on_object::WhereParam>) -> Fetch {
			Fetch(label_on_object::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<label_on_object::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLabelObjects(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<label_on_object::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<label_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectLabelObjects(params)
		}
		pub fn set(params: Vec<label_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::SetLabelObjects(params)
		}
		pub enum Select {
			Select(label_on_object::ManyArgs, Vec<label_on_object::SelectParam>),
			Include(
				label_on_object::ManyArgs,
				Vec<label_on_object::IncludeParam>,
			),
			Fetch(label_on_object::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LabelObjects(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(label_on_object::ManyArgs, Vec<label_on_object::SelectParam>),
			Include(
				label_on_object::ManyArgs,
				Vec<label_on_object::IncludeParam>,
			),
			Fetch(label_on_object::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LabelObjects(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.label().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.label().create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Label", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: pub_id::Type,
		#[serde(rename = "name")]
		pub name: name::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "date_modified")]
		pub date_modified: date_modified::Type,
		#[serde(rename = "label_objects")]
		#[specta(skip)]
		pub label_objects: Option<label_objects::RecursiveSafeType>,
	}
	impl Data {
		pub fn label_objects(
			&self,
		) -> Result<&label_objects::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.label_objects
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(label_objects),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_label { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: label struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_label as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod label_on_object {
	use super::_prisma::*;
	pub const NAME: &str = "LabelOnObject";
	pub fn label_id_object_id<T: From<UniqueWhereParam>>(label_id: i32, object_id: i32) -> T {
		UniqueWhereParam::LabelIdObjectIdEquals(label_id, object_id).into()
	}
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LabelIdObjectIdEquals(i32, i32),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		LabelId(super::_prisma::read_filters::IntFilter),
		LabelIs(Vec<super::label::WhereParam>),
		LabelIsNot(Vec<super::label::WhereParam>),
		ObjectId(super::_prisma::read_filters::IntFilter),
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::LabelIdObjectIdEquals(label_id, object_id) => (
					"label_id_object_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							label_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(label_id as i64),
						),
						(
							object_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(object_id as i64),
						),
					]),
				),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::LabelId(value) => (label_id::NAME, value.into()),
				Self::LabelIs(where_params) => (
					label::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelIsNot(where_params) => (
					label::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		LabelIdObjectIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::LabelIdObjectIdEquals(label_id, object_id) => {
					Self::LabelIdObjectIdEquals(label_id, object_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		DateCreated(super::SortOrder),
		LabelId(super::SortOrder),
		ObjectId(super::SortOrder),
		Label(Vec<super::label::OrderByWithRelationParam>),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::LabelId(param) => ("label_id", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::Label(param) => (
					"label",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Label(super::label::UniqueArgs),
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Label(args) => {
					let mut selections = < super :: label :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(label::NAME, None, [], selections)
				}
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		LabelId(super::_prisma::write_params::IntParam),
		ConnectLabel(super::label::UniqueWhereParam),
		ObjectId(super::_prisma::write_params::IntParam),
		ConnectObject(super::object::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::LabelId(value) => (label_id::NAME, value.into()),
				Self::ConnectLabel(where_param) => (
					label::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::label::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		LabelId(super::_prisma::write_params::IntParam),
		ObjectId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::LabelId(value) => ("label_id", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_label_on_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: label_on_object :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: label_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: label_on_object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: label_on_object :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: label_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: label_on_object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { date_created , label_id , label , object_id , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: label_on_object :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: label_on_object :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: label_on_object :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: label_on_object :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: label_on_object :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: label_on_object :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label_on_object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label_on_object :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "label_id" , "label" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: label_on_object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; label : $ selection_mode : ident { $ ($ selections : tt) + }) => { label :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: label_on_object :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "LabelOnObject" , available relations are "date_created, label_id, label, object_id, object")) } ; (@ field_module ; label : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: label :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: label_on_object :: SelectParam > :: into (sd_prisma :: prisma :: label_on_object :: date_created :: Select) } ; (@ selection_field_to_selection_param ; label_id) => { Into :: < sd_prisma :: prisma :: label_on_object :: SelectParam > :: into (sd_prisma :: prisma :: label_on_object :: label_id :: Select) } ; (@ selection_field_to_selection_param ; label $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: label_on_object :: SelectParam > :: into (sd_prisma :: prisma :: label_on_object :: label :: Select :: $ selection_mode (sd_prisma :: prisma :: label :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; label $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: label_on_object :: SelectParam > :: into (sd_prisma :: prisma :: label_on_object :: label :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < sd_prisma :: prisma :: label_on_object :: SelectParam > :: into (sd_prisma :: prisma :: label_on_object :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: label_on_object :: SelectParam > :: into (sd_prisma :: prisma :: label_on_object :: object :: Select :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: label_on_object :: SelectParam > :: into (sd_prisma :: prisma :: label_on_object :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: label_on_object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; label_id) => { "label_id" } ; (@ field_serde_name ; label) => { "label" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_label_on_object as select;
	pub enum SelectParam {
		DateCreated(date_created::Select),
		LabelId(label_id::Select),
		Label(label::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::LabelId(data) => data.to_selection(),
				Self::Label(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_label_on_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: label_on_object :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: label_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: label_on_object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: label_on_object :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: label_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: label_on_object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { label , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: label_on_object :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: label_on_object :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = sd_prisma :: prisma :: label_on_object :: label_id :: NAME)] pub label_id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: label_on_object :: object_id :: NAME)] pub object_id : i32 , $ (# [specta (rename_from_path = sd_prisma :: prisma :: label_on_object :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: label_on_object :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (date_created) , stringify ! (label_id) , stringify ! (object_id)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: label_on_object :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: label_on_object :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: label_on_object :: label_id :: NAME , & self . label_id) ? ; state . serialize_field (sd_prisma :: prisma :: label_on_object :: object_id :: NAME , & self . object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , date_created , label_id , object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: label_on_object :: $ field :: NAME) , + , sd_prisma :: prisma :: label_on_object :: date_created :: NAME , sd_prisma :: prisma :: label_on_object :: label_id :: NAME , sd_prisma :: prisma :: label_on_object :: object_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: label_on_object :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: label_on_object :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: label_on_object :: label_id :: NAME => Ok (Field :: label_id) , sd_prisma :: prisma :: label_on_object :: object_id :: NAME => Ok (Field :: object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut date_created = None ; let mut label_id = None ; let mut object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label_on_object :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: label_id => { if label_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label_on_object :: label_id :: NAME)) ; } label_id = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label_on_object :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: label_on_object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label_on_object :: $ field :: NAME)) ? ;) * let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label_on_object :: date_created :: NAME)) ? ; let label_id = label_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label_on_object :: label_id :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: label_on_object :: object_id :: NAME)) ? ; Ok (Data { date_created , label_id , object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "label_id" , "label" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: label_on_object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; label : $ selection_mode : ident { $ ($ selections : tt) + }) => { label :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: label_on_object :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "LabelOnObject" , available relations are "label, object")) } ; (@ field_module ; label : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: label :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; label $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: label_on_object :: IncludeParam > :: into (sd_prisma :: prisma :: label_on_object :: label :: Include :: $ selection_mode (sd_prisma :: prisma :: label :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; label $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: label_on_object :: IncludeParam > :: into (sd_prisma :: prisma :: label_on_object :: label :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: label_on_object :: IncludeParam > :: into (sd_prisma :: prisma :: label_on_object :: object :: Include :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: label_on_object :: IncludeParam > :: into (sd_prisma :: prisma :: label_on_object :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: label_on_object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; label_id) => { "label_id" } ; (@ field_serde_name ; label) => { "label" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_label_on_object as include;
	pub enum IncludeParam {
		DateCreated(date_created::Include),
		LabelId(label_id::Include),
		Label(label::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::LabelId(data) => data.to_selection(),
				Self::Label(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type =
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod label {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "label";
		pub type Type = label::Data;
		pub type RecursiveSafeType = Box<label::Data>;
		pub fn is(value: Vec<label::WhereParam>) -> WhereParam {
			WhereParam::LabelIs(value)
		}
		pub fn is_not(value: Vec<label::WhereParam>) -> WhereParam {
			WhereParam::LabelIsNot(value)
		}
		pub struct Order(Vec<label::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<label::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Label(v)
			}
		}
		pub struct Fetch(pub label::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<label::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Label(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(label::UniqueArgs::new())
		}
		pub struct Connect(label::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLabel(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: label::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<label::SelectParam>),
			Include(Vec<label::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Label(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<label::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("label", None, [], selections)
			}
			pub fn select(nested_selections: Vec<label::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<label::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<label::SelectParam>),
			Include(Vec<label::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Label(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<label::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<label::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("label", None, [], selections)
			}
			pub fn select(nested_selections: Vec<label::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<label::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod label_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "label_id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::LabelId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, LabelId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LabelId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LabelId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LabelId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LabelId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LabelId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub type Type = object::Data;
		pub type RecursiveSafeType = Box<object::Data>;
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub label: super::label::UniqueWhereParam,
		pub object: super::object::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.label_on_object()
				.create(self.label, self.object, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([label::connect(self.label), object::connect(self.object)]);
			self._params
		}
	}
	pub fn create(
		label: super::label::UniqueWhereParam,
		object: super::object::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			label,
			object,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub label_id: i32,
		pub object_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.label_on_object()
				.create_unchecked(self.label_id, self.object_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([label_id::set(self.label_id), object_id::set(self.object_id)]);
			self._params
		}
	}
	pub fn create_unchecked(
		label_id: i32,
		object_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			label_id,
			object_id,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(label_id::NAME),
				::prisma_client_rust::sel(object_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "LabelOnObject", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "label_id")]
		pub label_id: label_id::Type,
		#[serde(rename = "label")]
		#[specta(skip)]
		pub label: Option<label::RecursiveSafeType>,
		#[serde(rename = "object_id")]
		pub object_id: object_id::Type,
		#[serde(rename = "object")]
		#[specta(skip)]
		pub object: Option<object::RecursiveSafeType>,
	}
	impl Data {
		pub fn label(
			&self,
		) -> Result<&super::label::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.label
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(label),
				))
				.map(|v| v.as_ref())
		}
		pub fn object(
			&self,
		) -> Result<&super::object::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_label_on_object { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: label_on_object struct $ struct_name { # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "label_id")] pub label_id : i32 , # [serde (rename = "object_id")] pub object_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_label_on_object as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			label: super::label::UniqueWhereParam,
			object: super::object::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([label::connect(label), object::connect(object)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			label_id: i32,
			object_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([label_id::set(label_id), object_id::set(object_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod space {
	use super::_prisma::*;
	pub const NAME: &str = "Space";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		Description(super::_prisma::read_filters::StringNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
		DateModified(super::_prisma::read_filters::DateTimeNullableFilter),
		ObjectsSome(Vec<super::object_in_space::WhereParam>),
		ObjectsEvery(Vec<super::object_in_space::WhereParam>),
		ObjectsNone(Vec<super::object_in_space::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Description(value) => (description::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ObjectsSome(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectsEvery(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectsNone(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		Description(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		Objects(Vec<super::object_in_space::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Description(param) => ("description", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::Objects(param) => (
					"objects",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Objects(super::object_in_space::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Objects(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						objects::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Description(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateModified(super::_prisma::write_params::DateTimeNullableParam),
		ConnectObjects(Vec<super::object_in_space::UniqueWhereParam>),
		DisconnectObjects(Vec<super::object_in_space::UniqueWhereParam>),
		SetObjects(Vec<super::object_in_space::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Description(value) => (description::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ConnectObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Description(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateModified(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Description(value) => ("description", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_space { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: space :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: space :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: space :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: space :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , description , date_created , date_modified , objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: space :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: space :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: space :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: space :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: space :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: space :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: space :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: space :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "description" , "date_created" , "date_modified" , "objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: space :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < objects :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: space :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Space" , available relations are "id, pub_id, name, description, date_created, date_modified, objects")) } ; (@ field_module ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object_in_space :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: space :: SelectParam > :: into (sd_prisma :: prisma :: space :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < sd_prisma :: prisma :: space :: SelectParam > :: into (sd_prisma :: prisma :: space :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < sd_prisma :: prisma :: space :: SelectParam > :: into (sd_prisma :: prisma :: space :: name :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < sd_prisma :: prisma :: space :: SelectParam > :: into (sd_prisma :: prisma :: space :: description :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: space :: SelectParam > :: into (sd_prisma :: prisma :: space :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < sd_prisma :: prisma :: space :: SelectParam > :: into (sd_prisma :: prisma :: space :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: space :: SelectParam > :: into (sd_prisma :: prisma :: space :: objects :: Select :: $ selection_mode (sd_prisma :: prisma :: object_in_space :: ManyArgs :: new (sd_prisma :: prisma :: object_in_space :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: object_in_space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: space :: SelectParam > :: into (sd_prisma :: prisma :: space :: objects :: Select :: Fetch (sd_prisma :: prisma :: object_in_space :: ManyArgs :: new (sd_prisma :: prisma :: object_in_space :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: space :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; objects) => { "objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_space as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		Description(description::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		Objects(objects::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Objects(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_space { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: space :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: space :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: space :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: space :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: space :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: space :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: space :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: space :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: space :: description :: NAME)] pub description : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: space :: date_created :: NAME)] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: space :: date_modified :: NAME)] pub date_modified : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: space :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: space :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (description) , stringify ! (date_created) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: space :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: space :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: space :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (sd_prisma :: prisma :: space :: name :: NAME , & self . name) ? ; state . serialize_field (sd_prisma :: prisma :: space :: description :: NAME , & self . description) ? ; state . serialize_field (sd_prisma :: prisma :: space :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: space :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , description , date_created , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: space :: $ field :: NAME) , + , sd_prisma :: prisma :: space :: id :: NAME , sd_prisma :: prisma :: space :: pub_id :: NAME , sd_prisma :: prisma :: space :: name :: NAME , sd_prisma :: prisma :: space :: description :: NAME , sd_prisma :: prisma :: space :: date_created :: NAME , sd_prisma :: prisma :: space :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: space :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: space :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: space :: pub_id :: NAME => Ok (Field :: pub_id) , sd_prisma :: prisma :: space :: name :: NAME => Ok (Field :: name) , sd_prisma :: prisma :: space :: description :: NAME => Ok (Field :: description) , sd_prisma :: prisma :: space :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: space :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut description = None ; let mut date_created = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: space :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: space :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: space :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: space :: description :: NAME)) ; } description = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: space :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: space :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: space :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: space :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: space :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: space :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: space :: name :: NAME)) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: space :: description :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: space :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: space :: date_modified :: NAME)) ? ; Ok (Data { id , pub_id , name , description , date_created , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "description" , "date_created" , "date_modified" , "objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: space :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < objects :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: space :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Space" , available relations are "objects")) } ; (@ field_module ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object_in_space :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: space :: IncludeParam > :: into (sd_prisma :: prisma :: space :: objects :: Include :: $ selection_mode (sd_prisma :: prisma :: object_in_space :: ManyArgs :: new (sd_prisma :: prisma :: object_in_space :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: object_in_space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: space :: IncludeParam > :: into (sd_prisma :: prisma :: space :: objects :: Include :: Fetch (sd_prisma :: prisma :: object_in_space :: ManyArgs :: new (sd_prisma :: prisma :: object_in_space :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: space :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; objects) => { "objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_space as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		Description(description::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		Objects(objects::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Objects(data) => data.to_selection(),
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod description {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "description";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Description,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Description(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Description(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Description(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Description(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Description(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Description(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Description(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod objects {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "objects";
		pub type Type = Vec<object_in_space::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::ObjectsSome(value)
		}
		pub fn every(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::ObjectsEvery(value)
		}
		pub fn none(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::ObjectsNone(value)
		}
		pub struct Order(Vec<object_in_space::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<object_in_space::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Objects(v)
			}
		}
		pub struct Fetch(pub object_in_space::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object_in_space::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: object_in_space::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: object_in_space::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Objects(v)
			}
		}
		pub fn fetch(params: Vec<object_in_space::WhereParam>) -> Fetch {
			Fetch(object_in_space::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<object_in_space::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObjects(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<object_in_space::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<object_in_space::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectObjects(params)
		}
		pub fn set(params: Vec<object_in_space::UniqueWhereParam>) -> SetParam {
			SetParam::SetObjects(params)
		}
		pub enum Select {
			Select(object_in_space::ManyArgs, Vec<object_in_space::SelectParam>),
			Include(
				object_in_space::ManyArgs,
				Vec<object_in_space::IncludeParam>,
			),
			Fetch(object_in_space::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Objects(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(object_in_space::ManyArgs, Vec<object_in_space::SelectParam>),
			Include(
				object_in_space::ManyArgs,
				Vec<object_in_space::IncludeParam>,
			),
			Fetch(object_in_space::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Objects(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.space().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.space().create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(description::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Space", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: pub_id::Type,
		#[serde(rename = "name")]
		pub name: name::Type,
		#[serde(rename = "description")]
		pub description: description::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "date_modified")]
		pub date_modified: date_modified::Type,
		#[serde(rename = "objects")]
		#[specta(skip)]
		pub objects: Option<objects::RecursiveSafeType>,
	}
	impl Data {
		pub fn objects(
			&self,
		) -> Result<&objects::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.objects
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(objects),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_space { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: space struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "description")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub description : Option < String > , # [serde (rename = "date_created")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_modified")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_modified : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_space as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod object_in_space {
	use super::_prisma::*;
	pub const NAME: &str = "ObjectInSpace";
	pub fn space_id_object_id<T: From<UniqueWhereParam>>(space_id: i32, object_id: i32) -> T {
		UniqueWhereParam::SpaceIdObjectIdEquals(space_id, object_id).into()
	}
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		SpaceIdObjectIdEquals(i32, i32),
		SpaceId(super::_prisma::read_filters::IntFilter),
		SpaceIs(Vec<super::space::WhereParam>),
		SpaceIsNot(Vec<super::space::WhereParam>),
		ObjectId(super::_prisma::read_filters::IntFilter),
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::SpaceIdObjectIdEquals(space_id, object_id) => (
					"space_id_object_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							space_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(space_id as i64),
						),
						(
							object_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(object_id as i64),
						),
					]),
				),
				Self::SpaceId(value) => (space_id::NAME, value.into()),
				Self::SpaceIs(where_params) => (
					space::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SpaceIsNot(where_params) => (
					space::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		SpaceIdObjectIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::SpaceIdObjectIdEquals(space_id, object_id) => {
					Self::SpaceIdObjectIdEquals(space_id, object_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		SpaceId(super::SortOrder),
		ObjectId(super::SortOrder),
		Space(Vec<super::space::OrderByWithRelationParam>),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::SpaceId(param) => ("space_id", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::Space(param) => (
					"space",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Space(super::space::UniqueArgs),
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Space(args) => {
					let mut selections = < super :: space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(space::NAME, None, [], selections)
				}
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		SpaceId(super::_prisma::write_params::IntParam),
		ConnectSpace(super::space::UniqueWhereParam),
		ObjectId(super::_prisma::write_params::IntParam),
		ConnectObject(super::object::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::SpaceId(value) => (space_id::NAME, value.into()),
				Self::ConnectSpace(where_param) => (
					space::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		SpaceId(super::_prisma::write_params::IntParam),
		ObjectId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::SpaceId(value) => ("space_id", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_object_in_space { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: object_in_space :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: object_in_space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: object_in_space :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: object_in_space :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: object_in_space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: object_in_space :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { space_id , space , object_id , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: object_in_space :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: object_in_space :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: object_in_space :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: object_in_space :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: object_in_space :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: object_in_space :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object_in_space :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object_in_space :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["space_id" , "space" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: object_in_space :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; space : $ selection_mode : ident { $ ($ selections : tt) + }) => { space :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: object_in_space :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ObjectInSpace" , available relations are "space_id, space, object_id, object")) } ; (@ field_module ; space : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: space :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; space_id) => { Into :: < sd_prisma :: prisma :: object_in_space :: SelectParam > :: into (sd_prisma :: prisma :: object_in_space :: space_id :: Select) } ; (@ selection_field_to_selection_param ; space $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object_in_space :: SelectParam > :: into (sd_prisma :: prisma :: object_in_space :: space :: Select :: $ selection_mode (sd_prisma :: prisma :: space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; space $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object_in_space :: SelectParam > :: into (sd_prisma :: prisma :: object_in_space :: space :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < sd_prisma :: prisma :: object_in_space :: SelectParam > :: into (sd_prisma :: prisma :: object_in_space :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object_in_space :: SelectParam > :: into (sd_prisma :: prisma :: object_in_space :: object :: Select :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object_in_space :: SelectParam > :: into (sd_prisma :: prisma :: object_in_space :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: object_in_space :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; space_id) => { "space_id" } ; (@ field_serde_name ; space) => { "space" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_object_in_space as select;
	pub enum SelectParam {
		SpaceId(space_id::Select),
		Space(space::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::SpaceId(data) => data.to_selection(),
				Self::Space(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_object_in_space { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: object_in_space :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: object_in_space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: object_in_space :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: object_in_space :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: object_in_space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: object_in_space :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { space , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: object_in_space :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: object_in_space :: space_id :: NAME)] pub space_id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: object_in_space :: object_id :: NAME)] pub object_id : i32 , $ (# [specta (rename_from_path = sd_prisma :: prisma :: object_in_space :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: object_in_space :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (space_id) , stringify ! (object_id)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: object_in_space :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: object_in_space :: space_id :: NAME , & self . space_id) ? ; state . serialize_field (sd_prisma :: prisma :: object_in_space :: object_id :: NAME , & self . object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , space_id , object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: object_in_space :: $ field :: NAME) , + , sd_prisma :: prisma :: object_in_space :: space_id :: NAME , sd_prisma :: prisma :: object_in_space :: object_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: object_in_space :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: object_in_space :: space_id :: NAME => Ok (Field :: space_id) , sd_prisma :: prisma :: object_in_space :: object_id :: NAME => Ok (Field :: object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut space_id = None ; let mut object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: space_id => { if space_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object_in_space :: space_id :: NAME)) ; } space_id = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object_in_space :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: object_in_space :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object_in_space :: $ field :: NAME)) ? ;) * let space_id = space_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object_in_space :: space_id :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: object_in_space :: object_id :: NAME)) ? ; Ok (Data { space_id , object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["space_id" , "space" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: object_in_space :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; space : $ selection_mode : ident { $ ($ selections : tt) + }) => { space :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: object_in_space :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ObjectInSpace" , available relations are "space, object")) } ; (@ field_module ; space : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: space :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; space $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object_in_space :: IncludeParam > :: into (sd_prisma :: prisma :: object_in_space :: space :: Include :: $ selection_mode (sd_prisma :: prisma :: space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; space $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object_in_space :: IncludeParam > :: into (sd_prisma :: prisma :: object_in_space :: space :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: object_in_space :: IncludeParam > :: into (sd_prisma :: prisma :: object_in_space :: object :: Include :: $ selection_mode (sd_prisma :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: object_in_space :: IncludeParam > :: into (sd_prisma :: prisma :: object_in_space :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: object_in_space :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; space_id) => { "space_id" } ; (@ field_serde_name ; space) => { "space" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_object_in_space as include;
	pub enum IncludeParam {
		SpaceId(space_id::Include),
		Space(space::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::SpaceId(data) => data.to_selection(),
				Self::Space(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub type Type = object::Data;
		pub type RecursiveSafeType = Box<object::Data>;
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod space {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "space";
		pub type Type = space::Data;
		pub type RecursiveSafeType = Box<space::Data>;
		pub fn is(value: Vec<space::WhereParam>) -> WhereParam {
			WhereParam::SpaceIs(value)
		}
		pub fn is_not(value: Vec<space::WhereParam>) -> WhereParam {
			WhereParam::SpaceIsNot(value)
		}
		pub struct Order(Vec<space::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<space::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Space(v)
			}
		}
		pub struct Fetch(pub space::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<space::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Space(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(space::UniqueArgs::new())
		}
		pub struct Connect(space::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectSpace(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: space::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<space::SelectParam>),
			Include(Vec<space::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Space(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<space::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("space", None, [], selections)
			}
			pub fn select(nested_selections: Vec<space::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<space::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<space::SelectParam>),
			Include(Vec<space::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Space(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<space::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<space::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("space", None, [], selections)
			}
			pub fn select(nested_selections: Vec<space::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<space::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod space_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "space_id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::SpaceId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, SpaceId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::SpaceId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::SpaceId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SpaceId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SpaceId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SpaceId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub space: super::space::UniqueWhereParam,
		pub object: super::object::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.object_in_space()
				.create(self.space, self.object, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([space::connect(self.space), object::connect(self.object)]);
			self._params
		}
	}
	pub fn create(
		space: super::space::UniqueWhereParam,
		object: super::object::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			space,
			object,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub space_id: i32,
		pub object_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.object_in_space()
				.create_unchecked(self.space_id, self.object_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([space_id::set(self.space_id), object_id::set(self.object_id)]);
			self._params
		}
	}
	pub fn create_unchecked(
		space_id: i32,
		object_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			space_id,
			object_id,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(space_id::NAME),
				::prisma_client_rust::sel(object_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "ObjectInSpace", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "space_id")]
		pub space_id: space_id::Type,
		#[serde(rename = "space")]
		#[specta(skip)]
		pub space: Option<space::RecursiveSafeType>,
		#[serde(rename = "object_id")]
		pub object_id: object_id::Type,
		#[serde(rename = "object")]
		#[specta(skip)]
		pub object: Option<object::RecursiveSafeType>,
	}
	impl Data {
		pub fn space(
			&self,
		) -> Result<&super::space::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.space
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(space),
				))
				.map(|v| v.as_ref())
		}
		pub fn object(
			&self,
		) -> Result<&super::object::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_object_in_space { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: object_in_space struct $ struct_name { # [serde (rename = "space_id")] pub space_id : i32 , # [serde (rename = "object_id")] pub object_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_object_in_space as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			space: super::space::UniqueWhereParam,
			object: super::object::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([space::connect(space), object::connect(object)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			space_id: i32,
			object_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([space_id::set(space_id), object_id::set(object_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod job {
	use super::_prisma::*;
	pub const NAME: &str = "Job";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		Action(super::_prisma::read_filters::StringNullableFilter),
		Status(super::_prisma::read_filters::IntNullableFilter),
		ErrorsText(super::_prisma::read_filters::StringNullableFilter),
		Data(super::_prisma::read_filters::BytesNullableFilter),
		Metadata(super::_prisma::read_filters::BytesNullableFilter),
		ParentId(super::_prisma::read_filters::BytesNullableFilter),
		TaskCount(super::_prisma::read_filters::IntNullableFilter),
		CompletedTaskCount(super::_prisma::read_filters::IntNullableFilter),
		DateEstimatedCompletion(super::_prisma::read_filters::DateTimeNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
		DateStarted(super::_prisma::read_filters::DateTimeNullableFilter),
		DateCompleted(super::_prisma::read_filters::DateTimeNullableFilter),
		ParentIsNull,
		ParentIs(Vec<super::job::WhereParam>),
		ParentIsNot(Vec<super::job::WhereParam>),
		ChildrenSome(Vec<super::job::WhereParam>),
		ChildrenEvery(Vec<super::job::WhereParam>),
		ChildrenNone(Vec<super::job::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Action(value) => (action::NAME, value.into()),
				Self::Status(value) => (status::NAME, value.into()),
				Self::ErrorsText(value) => (errors_text::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::Metadata(value) => (metadata::NAME, value.into()),
				Self::ParentId(value) => (parent_id::NAME, value.into()),
				Self::TaskCount(value) => (task_count::NAME, value.into()),
				Self::CompletedTaskCount(value) => (completed_task_count::NAME, value.into()),
				Self::DateEstimatedCompletion(value) => {
					(date_estimated_completion::NAME, value.into())
				}
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateStarted(value) => (date_started::NAME, value.into()),
				Self::DateCompleted(value) => (date_completed::NAME, value.into()),
				Self::ParentIsNull => (
					parent::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::ParentIs(where_params) => (
					parent::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ParentIsNot(where_params) => (
					parent::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ChildrenSome(where_params) => (
					children::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ChildrenEvery(where_params) => (
					children::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ChildrenNone(where_params) => (
					children::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		Name(super::SortOrder),
		Action(super::SortOrder),
		Status(super::SortOrder),
		ErrorsText(super::SortOrder),
		Data(super::SortOrder),
		Metadata(super::SortOrder),
		ParentId(super::SortOrder),
		TaskCount(super::SortOrder),
		CompletedTaskCount(super::SortOrder),
		DateEstimatedCompletion(super::SortOrder),
		DateCreated(super::SortOrder),
		DateStarted(super::SortOrder),
		DateCompleted(super::SortOrder),
		Parent(Vec<super::job::OrderByWithRelationParam>),
		Children(Vec<super::job::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Action(param) => ("action", param.into()),
				Self::Status(param) => ("status", param.into()),
				Self::ErrorsText(param) => ("errors_text", param.into()),
				Self::Data(param) => ("data", param.into()),
				Self::Metadata(param) => ("metadata", param.into()),
				Self::ParentId(param) => ("parent_id", param.into()),
				Self::TaskCount(param) => ("task_count", param.into()),
				Self::CompletedTaskCount(param) => ("completed_task_count", param.into()),
				Self::DateEstimatedCompletion(param) => ("date_estimated_completion", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateStarted(param) => ("date_started", param.into()),
				Self::DateCompleted(param) => ("date_completed", param.into()),
				Self::Parent(param) => (
					"parent",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Children(param) => (
					"children",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Parent(super::job::UniqueArgs),
		Children(super::job::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Parent(args) => {
					let mut selections =
						<super::job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(parent::NAME, None, [], selections)
				}
				Self::Children(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(
						<super::job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						),
					);
					::prisma_client_rust::Selection::new(
						children::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Action(super::_prisma::write_params::StringNullableParam),
		Status(super::_prisma::write_params::IntNullableParam),
		ErrorsText(super::_prisma::write_params::StringNullableParam),
		Data(super::_prisma::write_params::BytesNullableParam),
		Metadata(super::_prisma::write_params::BytesNullableParam),
		ParentId(super::_prisma::write_params::BytesNullableParam),
		TaskCount(super::_prisma::write_params::IntNullableParam),
		CompletedTaskCount(super::_prisma::write_params::IntNullableParam),
		DateEstimatedCompletion(super::_prisma::write_params::DateTimeNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateStarted(super::_prisma::write_params::DateTimeNullableParam),
		DateCompleted(super::_prisma::write_params::DateTimeNullableParam),
		ConnectParent(super::job::UniqueWhereParam),
		DisconnectParent,
		ConnectChildren(Vec<super::job::UniqueWhereParam>),
		DisconnectChildren(Vec<super::job::UniqueWhereParam>),
		SetChildren(Vec<super::job::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Action(value) => (action::NAME, value.into()),
				Self::Status(value) => (status::NAME, value.into()),
				Self::ErrorsText(value) => (errors_text::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::Metadata(value) => (metadata::NAME, value.into()),
				Self::ParentId(value) => (parent_id::NAME, value.into()),
				Self::TaskCount(value) => (task_count::NAME, value.into()),
				Self::CompletedTaskCount(value) => (completed_task_count::NAME, value.into()),
				Self::DateEstimatedCompletion(value) => {
					(date_estimated_completion::NAME, value.into())
				}
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateStarted(value) => (date_started::NAME, value.into()),
				Self::DateCompleted(value) => (date_completed::NAME, value.into()),
				Self::ConnectParent(where_param) => (
					parent::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectParent => (
					parent::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
				Self::ConnectChildren(where_params) => (
					children::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectChildren(where_params) => (
					children::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetChildren(where_params) => (
					children::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Action(super::_prisma::write_params::StringNullableParam),
		Status(super::_prisma::write_params::IntNullableParam),
		ErrorsText(super::_prisma::write_params::StringNullableParam),
		Data(super::_prisma::write_params::BytesNullableParam),
		Metadata(super::_prisma::write_params::BytesNullableParam),
		ParentId(super::_prisma::write_params::BytesNullableParam),
		TaskCount(super::_prisma::write_params::IntNullableParam),
		CompletedTaskCount(super::_prisma::write_params::IntNullableParam),
		DateEstimatedCompletion(super::_prisma::write_params::DateTimeNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateStarted(super::_prisma::write_params::DateTimeNullableParam),
		DateCompleted(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Action(value) => ("action", value.into()),
				Self::Status(value) => ("status", value.into()),
				Self::ErrorsText(value) => ("errors_text", value.into()),
				Self::Data(value) => ("data", value.into()),
				Self::Metadata(value) => ("metadata", value.into()),
				Self::ParentId(value) => ("parent_id", value.into()),
				Self::TaskCount(value) => ("task_count", value.into()),
				Self::CompletedTaskCount(value) => ("completed_task_count", value.into()),
				Self::DateEstimatedCompletion(value) => ("date_estimated_completion", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateStarted(value) => ("date_started", value.into()),
				Self::DateCompleted(value) => ("date_completed", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_job { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: job :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: job :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: job :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: job :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , action , status , errors_text , data , metadata , parent_id , task_count , completed_task_count , date_estimated_completion , date_created , date_started , date_completed , parent , children } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: job :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: job :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: job :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: job :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: job :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: job :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "action" , "status" , "errors_text" , "data" , "metadata" , "parent_id" , "task_count" , "completed_task_count" , "date_estimated_completion" , "date_created" , "date_started" , "date_completed" , "parent" , "children"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: job :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < parent :: Data > } ; (@ field_type ; children : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < children :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: job :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Job" , available relations are "id, name, action, status, errors_text, data, metadata, parent_id, task_count, completed_task_count, date_estimated_completion, date_created, date_started, date_completed, parent, children")) } ; (@ field_module ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: job :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; children : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: job :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: name :: Select) } ; (@ selection_field_to_selection_param ; action) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: action :: Select) } ; (@ selection_field_to_selection_param ; status) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: status :: Select) } ; (@ selection_field_to_selection_param ; errors_text) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: errors_text :: Select) } ; (@ selection_field_to_selection_param ; data) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: data :: Select) } ; (@ selection_field_to_selection_param ; metadata) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: metadata :: Select) } ; (@ selection_field_to_selection_param ; parent_id) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: parent_id :: Select) } ; (@ selection_field_to_selection_param ; task_count) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: task_count :: Select) } ; (@ selection_field_to_selection_param ; completed_task_count) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: completed_task_count :: Select) } ; (@ selection_field_to_selection_param ; date_estimated_completion) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: date_estimated_completion :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_started) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: date_started :: Select) } ; (@ selection_field_to_selection_param ; date_completed) => { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: date_completed :: Select) } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: parent :: Select :: $ selection_mode (sd_prisma :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: parent :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; children $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: children :: Select :: $ selection_mode (sd_prisma :: prisma :: job :: ManyArgs :: new (sd_prisma :: prisma :: job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; children $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: job :: SelectParam > :: into (sd_prisma :: prisma :: job :: children :: Select :: Fetch (sd_prisma :: prisma :: job :: ManyArgs :: new (sd_prisma :: prisma :: job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: job :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; action) => { "action" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; errors_text) => { "errors_text" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; parent_id) => { "parent_id" } ; (@ field_serde_name ; task_count) => { "task_count" } ; (@ field_serde_name ; completed_task_count) => { "completed_task_count" } ; (@ field_serde_name ; date_estimated_completion) => { "date_estimated_completion" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_started) => { "date_started" } ; (@ field_serde_name ; date_completed) => { "date_completed" } ; (@ field_serde_name ; parent) => { "parent" } ; (@ field_serde_name ; children) => { "children" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_job as select;
	pub enum SelectParam {
		Id(id::Select),
		Name(name::Select),
		Action(action::Select),
		Status(status::Select),
		ErrorsText(errors_text::Select),
		Data(data::Select),
		Metadata(metadata::Select),
		ParentId(parent_id::Select),
		TaskCount(task_count::Select),
		CompletedTaskCount(completed_task_count::Select),
		DateEstimatedCompletion(date_estimated_completion::Select),
		DateCreated(date_created::Select),
		DateStarted(date_started::Select),
		DateCompleted(date_completed::Select),
		Parent(parent::Select),
		Children(children::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Action(data) => data.to_selection(),
				Self::Status(data) => data.to_selection(),
				Self::ErrorsText(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::Metadata(data) => data.to_selection(),
				Self::ParentId(data) => data.to_selection(),
				Self::TaskCount(data) => data.to_selection(),
				Self::CompletedTaskCount(data) => data.to_selection(),
				Self::DateEstimatedCompletion(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateStarted(data) => data.to_selection(),
				Self::DateCompleted(data) => data.to_selection(),
				Self::Parent(data) => data.to_selection(),
				Self::Children(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_job { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: job :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: job :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: job :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: job :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { parent , children } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: job :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: job :: id :: NAME)] pub id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: action :: NAME)] pub action : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: status :: NAME)] pub status : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: errors_text :: NAME)] pub errors_text : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: data :: NAME)] pub data : Option < Vec < u8 > > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: metadata :: NAME)] pub metadata : Option < Vec < u8 > > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: parent_id :: NAME)] pub parent_id : Option < Vec < u8 > > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: task_count :: NAME)] pub task_count : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: completed_task_count :: NAME)] pub completed_task_count : Option < i32 > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: date_estimated_completion :: NAME)] pub date_estimated_completion : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: date_created :: NAME)] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: date_started :: NAME)] pub date_started : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: job :: date_completed :: NAME)] pub date_completed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: job :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: job :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (action) , stringify ! (status) , stringify ! (errors_text) , stringify ! (data) , stringify ! (metadata) , stringify ! (parent_id) , stringify ! (task_count) , stringify ! (completed_task_count) , stringify ! (date_estimated_completion) , stringify ! (date_created) , stringify ! (date_started) , stringify ! (date_completed)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: job :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: job :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: job :: name :: NAME , & self . name) ? ; state . serialize_field (sd_prisma :: prisma :: job :: action :: NAME , & self . action) ? ; state . serialize_field (sd_prisma :: prisma :: job :: status :: NAME , & self . status) ? ; state . serialize_field (sd_prisma :: prisma :: job :: errors_text :: NAME , & self . errors_text) ? ; state . serialize_field (sd_prisma :: prisma :: job :: data :: NAME , & self . data) ? ; state . serialize_field (sd_prisma :: prisma :: job :: metadata :: NAME , & self . metadata) ? ; state . serialize_field (sd_prisma :: prisma :: job :: parent_id :: NAME , & self . parent_id) ? ; state . serialize_field (sd_prisma :: prisma :: job :: task_count :: NAME , & self . task_count) ? ; state . serialize_field (sd_prisma :: prisma :: job :: completed_task_count :: NAME , & self . completed_task_count) ? ; state . serialize_field (sd_prisma :: prisma :: job :: date_estimated_completion :: NAME , & self . date_estimated_completion) ? ; state . serialize_field (sd_prisma :: prisma :: job :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: job :: date_started :: NAME , & self . date_started) ? ; state . serialize_field (sd_prisma :: prisma :: job :: date_completed :: NAME , & self . date_completed) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , action , status , errors_text , data , metadata , parent_id , task_count , completed_task_count , date_estimated_completion , date_created , date_started , date_completed } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: job :: $ field :: NAME) , + , sd_prisma :: prisma :: job :: id :: NAME , sd_prisma :: prisma :: job :: name :: NAME , sd_prisma :: prisma :: job :: action :: NAME , sd_prisma :: prisma :: job :: status :: NAME , sd_prisma :: prisma :: job :: errors_text :: NAME , sd_prisma :: prisma :: job :: data :: NAME , sd_prisma :: prisma :: job :: metadata :: NAME , sd_prisma :: prisma :: job :: parent_id :: NAME , sd_prisma :: prisma :: job :: task_count :: NAME , sd_prisma :: prisma :: job :: completed_task_count :: NAME , sd_prisma :: prisma :: job :: date_estimated_completion :: NAME , sd_prisma :: prisma :: job :: date_created :: NAME , sd_prisma :: prisma :: job :: date_started :: NAME , sd_prisma :: prisma :: job :: date_completed :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: job :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: job :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: job :: name :: NAME => Ok (Field :: name) , sd_prisma :: prisma :: job :: action :: NAME => Ok (Field :: action) , sd_prisma :: prisma :: job :: status :: NAME => Ok (Field :: status) , sd_prisma :: prisma :: job :: errors_text :: NAME => Ok (Field :: errors_text) , sd_prisma :: prisma :: job :: data :: NAME => Ok (Field :: data) , sd_prisma :: prisma :: job :: metadata :: NAME => Ok (Field :: metadata) , sd_prisma :: prisma :: job :: parent_id :: NAME => Ok (Field :: parent_id) , sd_prisma :: prisma :: job :: task_count :: NAME => Ok (Field :: task_count) , sd_prisma :: prisma :: job :: completed_task_count :: NAME => Ok (Field :: completed_task_count) , sd_prisma :: prisma :: job :: date_estimated_completion :: NAME => Ok (Field :: date_estimated_completion) , sd_prisma :: prisma :: job :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: job :: date_started :: NAME => Ok (Field :: date_started) , sd_prisma :: prisma :: job :: date_completed :: NAME => Ok (Field :: date_completed) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut action = None ; let mut status = None ; let mut errors_text = None ; let mut data = None ; let mut metadata = None ; let mut parent_id = None ; let mut task_count = None ; let mut completed_task_count = None ; let mut date_estimated_completion = None ; let mut date_created = None ; let mut date_started = None ; let mut date_completed = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: action => { if action . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: action :: NAME)) ; } action = Some (map . next_value () ?) ; } Field :: status => { if status . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: status :: NAME)) ; } status = Some (map . next_value () ?) ; } Field :: errors_text => { if errors_text . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: errors_text :: NAME)) ; } errors_text = Some (map . next_value () ?) ; } Field :: data => { if data . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: data :: NAME)) ; } data = Some (map . next_value () ?) ; } Field :: metadata => { if metadata . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: metadata :: NAME)) ; } metadata = Some (map . next_value () ?) ; } Field :: parent_id => { if parent_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: parent_id :: NAME)) ; } parent_id = Some (map . next_value () ?) ; } Field :: task_count => { if task_count . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: task_count :: NAME)) ; } task_count = Some (map . next_value () ?) ; } Field :: completed_task_count => { if completed_task_count . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: completed_task_count :: NAME)) ; } completed_task_count = Some (map . next_value () ?) ; } Field :: date_estimated_completion => { if date_estimated_completion . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: date_estimated_completion :: NAME)) ; } date_estimated_completion = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_started => { if date_started . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: date_started :: NAME)) ; } date_started = Some (map . next_value () ?) ; } Field :: date_completed => { if date_completed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: date_completed :: NAME)) ; } date_completed = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: job :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: name :: NAME)) ? ; let action = action . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: action :: NAME)) ? ; let status = status . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: status :: NAME)) ? ; let errors_text = errors_text . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: errors_text :: NAME)) ? ; let data = data . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: data :: NAME)) ? ; let metadata = metadata . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: metadata :: NAME)) ? ; let parent_id = parent_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: parent_id :: NAME)) ? ; let task_count = task_count . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: task_count :: NAME)) ? ; let completed_task_count = completed_task_count . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: completed_task_count :: NAME)) ? ; let date_estimated_completion = date_estimated_completion . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: date_estimated_completion :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: date_created :: NAME)) ? ; let date_started = date_started . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: date_started :: NAME)) ? ; let date_completed = date_completed . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: job :: date_completed :: NAME)) ? ; Ok (Data { id , name , action , status , errors_text , data , metadata , parent_id , task_count , completed_task_count , date_estimated_completion , date_created , date_started , date_completed , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "action" , "status" , "errors_text" , "data" , "metadata" , "parent_id" , "task_count" , "completed_task_count" , "date_estimated_completion" , "date_created" , "date_started" , "date_completed" , "parent" , "children"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: job :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < parent :: Data > } ; (@ field_type ; children : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < children :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: job :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Job" , available relations are "parent, children")) } ; (@ field_module ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: job :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; children : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: job :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: job :: IncludeParam > :: into (sd_prisma :: prisma :: job :: parent :: Include :: $ selection_mode (sd_prisma :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: job :: IncludeParam > :: into (sd_prisma :: prisma :: job :: parent :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; children $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: job :: IncludeParam > :: into (sd_prisma :: prisma :: job :: children :: Include :: $ selection_mode (sd_prisma :: prisma :: job :: ManyArgs :: new (sd_prisma :: prisma :: job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; children $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: job :: IncludeParam > :: into (sd_prisma :: prisma :: job :: children :: Include :: Fetch (sd_prisma :: prisma :: job :: ManyArgs :: new (sd_prisma :: prisma :: job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: job :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; action) => { "action" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; errors_text) => { "errors_text" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; parent_id) => { "parent_id" } ; (@ field_serde_name ; task_count) => { "task_count" } ; (@ field_serde_name ; completed_task_count) => { "completed_task_count" } ; (@ field_serde_name ; date_estimated_completion) => { "date_estimated_completion" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_started) => { "date_started" } ; (@ field_serde_name ; date_completed) => { "date_completed" } ; (@ field_serde_name ; parent) => { "parent" } ; (@ field_serde_name ; children) => { "children" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_job as include;
	pub enum IncludeParam {
		Id(id::Include),
		Name(name::Include),
		Action(action::Include),
		Status(status::Include),
		ErrorsText(errors_text::Include),
		Data(data::Include),
		Metadata(metadata::Include),
		ParentId(parent_id::Include),
		TaskCount(task_count::Include),
		CompletedTaskCount(completed_task_count::Include),
		DateEstimatedCompletion(date_estimated_completion::Include),
		DateCreated(date_created::Include),
		DateStarted(date_started::Include),
		DateCompleted(date_completed::Include),
		Parent(parent::Include),
		Children(children::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Action(data) => data.to_selection(),
				Self::Status(data) => data.to_selection(),
				Self::ErrorsText(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::Metadata(data) => data.to_selection(),
				Self::ParentId(data) => data.to_selection(),
				Self::TaskCount(data) => data.to_selection(),
				Self::CompletedTaskCount(data) => data.to_selection(),
				Self::DateEstimatedCompletion(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateStarted(data) => data.to_selection(),
				Self::DateCompleted(data) => data.to_selection(),
				Self::Parent(data) => data.to_selection(),
				Self::Children(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod action {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "action";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Action(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Action,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Action(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Action(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Action(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Action(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Action(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Action(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Action(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod children {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "children";
		pub type Type = Vec<job::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ChildrenSome(value)
		}
		pub fn every(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ChildrenEvery(value)
		}
		pub fn none(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ChildrenNone(value)
		}
		pub struct Order(Vec<job::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<job::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Children(v)
			}
		}
		pub struct Fetch(pub job::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<job::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: job::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: job::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Children(v)
			}
		}
		pub fn fetch(params: Vec<job::WhereParam>) -> Fetch {
			Fetch(job::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<job::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectChildren(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<job::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<job::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectChildren(params)
		}
		pub fn set(params: Vec<job::UniqueWhereParam>) -> SetParam {
			SetParam::SetChildren(params)
		}
		pub enum Select {
			Select(job::ManyArgs, Vec<job::SelectParam>),
			Include(job::ManyArgs, Vec<job::IncludeParam>),
			Fetch(job::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Children(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(args: job::ManyArgs, nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(args: job::ManyArgs, nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(job::ManyArgs, Vec<job::SelectParam>),
			Include(job::ManyArgs, Vec<job::IncludeParam>),
			Fetch(job::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Children(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections =
							<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(args: job::ManyArgs, nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(args: job::ManyArgs, nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod completed_task_count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "completed_task_count";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::CompletedTaskCount(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			CompletedTaskCount,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::CompletedTaskCount(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CompletedTaskCount(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::CompletedTaskCount(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::CompletedTaskCount(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CompletedTaskCount(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CompletedTaskCount(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CompletedTaskCount(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod data {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "data";
		pub type Type = Option<Vec<u8>>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::Data(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			Data,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Data(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Data(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Data(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_completed {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_completed";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCompleted(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCompleted,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCompleted(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCompleted(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCompleted(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCompleted(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCompleted(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCompleted(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCompleted(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_estimated_completion {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_estimated_completion";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateEstimatedCompletion(
				_prisma::read_filters::DateTimeNullableFilter::Equals(value),
			)
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateEstimatedCompletion,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateEstimatedCompletion(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateEstimatedCompletion(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateEstimatedCompletion(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateEstimatedCompletion(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateEstimatedCompletion(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateEstimatedCompletion(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateEstimatedCompletion(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_started {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_started";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateStarted(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateStarted,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateStarted(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateStarted(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateStarted(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateStarted(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateStarted(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateStarted(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateStarted(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod errors_text {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "errors_text";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::ErrorsText(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			ErrorsText,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ErrorsText(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ErrorsText(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::ErrorsText(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ErrorsText(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ErrorsText(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ErrorsText(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ErrorsText(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Id, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod metadata {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "metadata";
		pub type Type = Option<Vec<u8>>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::Metadata(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			Metadata,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Metadata(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Metadata(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Metadata(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Metadata(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Metadata(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Metadata(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Metadata(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod parent {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "parent";
		pub type Type = Option<job::Data>;
		pub type RecursiveSafeType = Option<Box<job::Data>>;
		pub fn is(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ParentIs(value)
		}
		pub fn is_not(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ParentIsNot(value)
		}
		pub struct Order(Vec<job::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<job::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Parent(v)
			}
		}
		pub struct Fetch(pub job::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<job::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Parent(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(job::UniqueArgs::new())
		}
		pub struct Connect(job::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectParent(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: job::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectParent
		}
		pub fn is_null() -> WhereParam {
			WhereParam::ParentIsNull
		}
		pub enum Select {
			Select(Vec<job::SelectParam>),
			Include(Vec<job::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Parent(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("parent", None, [], selections)
			}
			pub fn select(nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<job::SelectParam>),
			Include(Vec<job::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Parent(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("parent", None, [], selections)
			}
			pub fn select(nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod parent_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "parent_id";
		pub type Type = Option<Vec<u8>>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::ParentId(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			ParentId,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ParentId(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ParentId(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ParentId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ParentId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ParentId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod status {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "status";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::Status(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			Status,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Status(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Status(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Status(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Status(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Status(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Status(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Status(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod task_count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "task_count";
		pub type Type = Option<i32>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::TaskCount(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			TaskCount,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TaskCount(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TaskCount(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TaskCount(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TaskCount(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TaskCount(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TaskCount(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TaskCount(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.job().create(self.id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([id::set(self.id)]);
			self._params
		}
	}
	pub fn create(id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.job().create_unchecked(self.id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([id::set(self.id)]);
			self._params
		}
	}
	pub fn create_unchecked(id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(action::NAME),
				::prisma_client_rust::sel(status::NAME),
				::prisma_client_rust::sel(errors_text::NAME),
				::prisma_client_rust::sel(data::NAME),
				::prisma_client_rust::sel(metadata::NAME),
				::prisma_client_rust::sel(parent_id::NAME),
				::prisma_client_rust::sel(task_count::NAME),
				::prisma_client_rust::sel(completed_task_count::NAME),
				::prisma_client_rust::sel(date_estimated_completion::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_started::NAME),
				::prisma_client_rust::sel(date_completed::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Job", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "name")]
		pub name: name::Type,
		#[serde(rename = "action")]
		pub action: action::Type,
		#[serde(rename = "status")]
		pub status: status::Type,
		#[serde(rename = "errors_text")]
		pub errors_text: errors_text::Type,
		#[serde(rename = "data")]
		pub data: data::Type,
		#[serde(rename = "metadata")]
		pub metadata: metadata::Type,
		#[serde(rename = "parent_id")]
		pub parent_id: parent_id::Type,
		#[serde(rename = "task_count")]
		pub task_count: task_count::Type,
		#[serde(rename = "completed_task_count")]
		pub completed_task_count: completed_task_count::Type,
		#[serde(rename = "date_estimated_completion")]
		pub date_estimated_completion: date_estimated_completion::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "date_started")]
		pub date_started: date_started::Type,
		#[serde(rename = "date_completed")]
		pub date_completed: date_completed::Type,
		#[serde(
			rename = "parent",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub parent: Option<parent::RecursiveSafeType>,
		#[serde(rename = "children")]
		#[specta(skip)]
		pub children: Option<children::RecursiveSafeType>,
	}
	impl Data {
		pub fn parent(
			&self,
		) -> Result<Option<&super::job::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.parent
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(parent),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
		pub fn children(
			&self,
		) -> Result<&children::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.children
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(children),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_job { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: job struct $ struct_name { # [serde (rename = "id")] pub id : Vec < u8 > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "action")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub action : Option < String > , # [serde (rename = "status")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub status : Option < i32 > , # [serde (rename = "errors_text")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub errors_text : Option < String > , # [serde (rename = "data")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub data : Option < Vec < u8 > > , # [serde (rename = "metadata")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub metadata : Option < Vec < u8 > > , # [serde (rename = "parent_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub parent_id : Option < Vec < u8 > > , # [serde (rename = "task_count")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub task_count : Option < i32 > , # [serde (rename = "completed_task_count")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub completed_task_count : Option < i32 > , # [serde (rename = "date_estimated_completion")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_estimated_completion : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_created")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_started")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_started : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_completed")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_completed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_job as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([id::set(id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([id::set(id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod indexer_rule {
	use super::_prisma::*;
	pub const NAME: &str = "IndexerRule";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		Default(super::_prisma::read_filters::BooleanNullableFilter),
		RulesPerKind(super::_prisma::read_filters::BytesNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
		DateModified(super::_prisma::read_filters::DateTimeNullableFilter),
		LocationsSome(Vec<super::indexer_rules_in_location::WhereParam>),
		LocationsEvery(Vec<super::indexer_rules_in_location::WhereParam>),
		LocationsNone(Vec<super::indexer_rules_in_location::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Default(value) => (default::NAME, value.into()),
				Self::RulesPerKind(value) => (rules_per_kind::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::LocationsSome(where_params) => (
					locations::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationsEvery(where_params) => (
					locations::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationsNone(where_params) => (
					locations::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		Default(super::SortOrder),
		RulesPerKind(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		Locations(Vec<super::indexer_rules_in_location::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Default(param) => ("default", param.into()),
				Self::RulesPerKind(param) => ("rules_per_kind", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::Locations(param) => (
					"locations",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Locations(super::indexer_rules_in_location::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Locations(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						locations::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Default(super::_prisma::write_params::BooleanNullableParam),
		RulesPerKind(super::_prisma::write_params::BytesNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateModified(super::_prisma::write_params::DateTimeNullableParam),
		ConnectLocations(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
		DisconnectLocations(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
		SetLocations(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Default(value) => (default::NAME, value.into()),
				Self::RulesPerKind(value) => (rules_per_kind::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ConnectLocations(where_params) => (
					locations::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectLocations(where_params) => (
					locations::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetLocations(where_params) => (
					locations::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Default(super::_prisma::write_params::BooleanNullableParam),
		RulesPerKind(super::_prisma::write_params::BytesNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		DateModified(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Default(value) => ("default", value.into()),
				Self::RulesPerKind(value) => ("rules_per_kind", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_indexer_rule { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: indexer_rule :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: indexer_rule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: indexer_rule :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: indexer_rule :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: indexer_rule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: indexer_rule :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , default , rules_per_kind , date_created , date_modified , locations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: indexer_rule :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: indexer_rule :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: indexer_rule :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "default" , "rules_per_kind" , "date_created" , "date_modified" , "locations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: indexer_rule :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < locations :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: indexer_rule :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "IndexerRule" , available relations are "id, pub_id, name, default, rules_per_kind, date_created, date_modified, locations")) } ; (@ field_module ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: indexer_rule :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rule :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < sd_prisma :: prisma :: indexer_rule :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rule :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < sd_prisma :: prisma :: indexer_rule :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rule :: name :: Select) } ; (@ selection_field_to_selection_param ; default) => { Into :: < sd_prisma :: prisma :: indexer_rule :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rule :: default :: Select) } ; (@ selection_field_to_selection_param ; rules_per_kind) => { Into :: < sd_prisma :: prisma :: indexer_rule :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rule :: rules_per_kind :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < sd_prisma :: prisma :: indexer_rule :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rule :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < sd_prisma :: prisma :: indexer_rule :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rule :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: indexer_rule :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rule :: locations :: Select :: $ selection_mode (sd_prisma :: prisma :: indexer_rules_in_location :: ManyArgs :: new (sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: indexer_rule :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rule :: locations :: Select :: Fetch (sd_prisma :: prisma :: indexer_rules_in_location :: ManyArgs :: new (sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: indexer_rule :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; default) => { "default" } ; (@ field_serde_name ; rules_per_kind) => { "rules_per_kind" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; locations) => { "locations" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_indexer_rule as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		Default(default::Select),
		RulesPerKind(rules_per_kind::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		Locations(locations::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Default(data) => data.to_selection(),
				Self::RulesPerKind(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Locations(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_indexer_rule { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: indexer_rule :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: indexer_rule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: indexer_rule :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: indexer_rule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: indexer_rule :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: indexer_rule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: indexer_rule :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: indexer_rule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { locations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: indexer_rule :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: indexer_rule :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: indexer_rule :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: indexer_rule :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = sd_prisma :: prisma :: indexer_rule :: default :: NAME)] pub default : Option < bool > , # [specta (rename_from_path = sd_prisma :: prisma :: indexer_rule :: rules_per_kind :: NAME)] pub rules_per_kind : Option < Vec < u8 > > , # [specta (rename_from_path = sd_prisma :: prisma :: indexer_rule :: date_created :: NAME)] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = sd_prisma :: prisma :: indexer_rule :: date_modified :: NAME)] pub date_modified : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: indexer_rule :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: indexer_rule :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (default) , stringify ! (rules_per_kind) , stringify ! (date_created) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: indexer_rule :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: indexer_rule :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (sd_prisma :: prisma :: indexer_rule :: name :: NAME , & self . name) ? ; state . serialize_field (sd_prisma :: prisma :: indexer_rule :: default :: NAME , & self . default) ? ; state . serialize_field (sd_prisma :: prisma :: indexer_rule :: rules_per_kind :: NAME , & self . rules_per_kind) ? ; state . serialize_field (sd_prisma :: prisma :: indexer_rule :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (sd_prisma :: prisma :: indexer_rule :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , default , rules_per_kind , date_created , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME) , + , sd_prisma :: prisma :: indexer_rule :: id :: NAME , sd_prisma :: prisma :: indexer_rule :: pub_id :: NAME , sd_prisma :: prisma :: indexer_rule :: name :: NAME , sd_prisma :: prisma :: indexer_rule :: default :: NAME , sd_prisma :: prisma :: indexer_rule :: rules_per_kind :: NAME , sd_prisma :: prisma :: indexer_rule :: date_created :: NAME , sd_prisma :: prisma :: indexer_rule :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: indexer_rule :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: indexer_rule :: pub_id :: NAME => Ok (Field :: pub_id) , sd_prisma :: prisma :: indexer_rule :: name :: NAME => Ok (Field :: name) , sd_prisma :: prisma :: indexer_rule :: default :: NAME => Ok (Field :: default) , sd_prisma :: prisma :: indexer_rule :: rules_per_kind :: NAME => Ok (Field :: rules_per_kind) , sd_prisma :: prisma :: indexer_rule :: date_created :: NAME => Ok (Field :: date_created) , sd_prisma :: prisma :: indexer_rule :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut default = None ; let mut rules_per_kind = None ; let mut date_created = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rule :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rule :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rule :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: default => { if default . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rule :: default :: NAME)) ; } default = Some (map . next_value () ?) ; } Field :: rules_per_kind => { if rules_per_kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rule :: rules_per_kind :: NAME)) ; } rules_per_kind = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rule :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rule :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rule :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rule :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rule :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rule :: name :: NAME)) ? ; let default = default . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rule :: default :: NAME)) ? ; let rules_per_kind = rules_per_kind . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rule :: rules_per_kind :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rule :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rule :: date_modified :: NAME)) ? ; Ok (Data { id , pub_id , name , default , rules_per_kind , date_created , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "default" , "rules_per_kind" , "date_created" , "date_modified" , "locations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: indexer_rule :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < locations :: Data > } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: indexer_rule :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "IndexerRule" , available relations are "locations")) } ; (@ field_module ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: indexer_rule :: IncludeParam > :: into (sd_prisma :: prisma :: indexer_rule :: locations :: Include :: $ selection_mode (sd_prisma :: prisma :: indexer_rules_in_location :: ManyArgs :: new (sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: indexer_rule :: IncludeParam > :: into (sd_prisma :: prisma :: indexer_rule :: locations :: Include :: Fetch (sd_prisma :: prisma :: indexer_rules_in_location :: ManyArgs :: new (sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: indexer_rule :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; default) => { "default" } ; (@ field_serde_name ; rules_per_kind) => { "rules_per_kind" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; locations) => { "locations" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_indexer_rule as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		Default(default::Include),
		RulesPerKind(rules_per_kind::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		Locations(locations::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Default(data) => data.to_selection(),
				Self::RulesPerKind(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Locations(data) => data.to_selection(),
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod default {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "default";
		pub type Type = Option<bool>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<bool>) -> WhereParam {
			WhereParam::Default(_prisma::read_filters::BooleanNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanNullableFilter,
			Default,
			{
				fn not(_: Option<bool>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Default(v)
			}
		}
		pub struct Set(pub Option<bool>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Default(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Default(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<bool>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Default(_prisma::write_params::BooleanNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Default(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Default(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Default(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod locations {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "locations";
		pub type Type = Vec<indexer_rules_in_location::Data>;
		pub type RecursiveSafeType = Type;
		pub fn some(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::LocationsSome(value)
		}
		pub fn every(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::LocationsEvery(value)
		}
		pub fn none(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::LocationsNone(value)
		}
		pub struct Order(Vec<indexer_rules_in_location::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(
			v: Vec<indexer_rules_in_location::OrderByRelationAggregateParam>,
		) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Locations(v)
			}
		}
		pub struct Fetch(pub indexer_rules_in_location::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<indexer_rules_in_location::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(
				mut self,
				param: indexer_rules_in_location::OrderByWithRelationParam,
			) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: indexer_rules_in_location::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Locations(v)
			}
		}
		pub fn fetch(params: Vec<indexer_rules_in_location::WhereParam>) -> Fetch {
			Fetch(indexer_rules_in_location::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<indexer_rules_in_location::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLocations(v)
			}
		}
		pub fn connect<T: From<Connect>>(
			params: Vec<indexer_rules_in_location::UniqueWhereParam>,
		) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectLocations(params)
		}
		pub fn set(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
			SetParam::SetLocations(params)
		}
		pub enum Select {
			Select(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::SelectParam>,
			),
			Include(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::IncludeParam>,
			),
			Fetch(indexer_rules_in_location::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Locations(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::SelectParam>,
			),
			Include(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::IncludeParam>,
			),
			Fetch(indexer_rules_in_location::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Locations(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub type Type = Option<String>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod rules_per_kind {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "rules_per_kind";
		pub type Type = Option<Vec<u8>>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::RulesPerKind(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			RulesPerKind,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::RulesPerKind(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RulesPerKind(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::RulesPerKind(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::RulesPerKind(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RulesPerKind(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::RulesPerKind(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::RulesPerKind(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.indexer_rule().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.indexer_rule()
				.create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(default::NAME),
				::prisma_client_rust::sel(rules_per_kind::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "IndexerRule", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: pub_id::Type,
		#[serde(rename = "name")]
		pub name: name::Type,
		#[serde(rename = "default")]
		pub default: default::Type,
		#[serde(rename = "rules_per_kind")]
		pub rules_per_kind: rules_per_kind::Type,
		#[serde(rename = "date_created")]
		pub date_created: date_created::Type,
		#[serde(rename = "date_modified")]
		pub date_modified: date_modified::Type,
		#[serde(rename = "locations")]
		#[specta(skip)]
		pub locations: Option<locations::RecursiveSafeType>,
	}
	impl Data {
		pub fn locations(
			&self,
		) -> Result<&locations::Type, ::prisma_client_rust::RelationNotFetchedError> {
			self.locations
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(locations),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_indexer_rule { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: indexer_rule struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "default")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub default : Option < bool > , # [serde (rename = "rules_per_kind")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub rules_per_kind : Option < Vec < u8 > > , # [serde (rename = "date_created")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_modified")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_modified : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_indexer_rule as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod indexer_rules_in_location {
	use super::_prisma::*;
	pub const NAME: &str = "IndexerRulesInLocation";
	pub fn location_id_indexer_rule_id<T: From<UniqueWhereParam>>(
		location_id: i32,
		indexer_rule_id: i32,
	) -> T {
		UniqueWhereParam::LocationIdIndexerRuleIdEquals(location_id, indexer_rule_id).into()
	}
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LocationIdIndexerRuleIdEquals(i32, i32),
		LocationId(super::_prisma::read_filters::IntFilter),
		LocationIs(Vec<super::location::WhereParam>),
		LocationIsNot(Vec<super::location::WhereParam>),
		IndexerRuleId(super::_prisma::read_filters::IntFilter),
		IndexerRuleIs(Vec<super::indexer_rule::WhereParam>),
		IndexerRuleIsNot(Vec<super::indexer_rule::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::LocationIdIndexerRuleIdEquals(location_id, indexer_rule_id) => (
					"location_id_indexer_rule_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							location_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(location_id as i64),
						),
						(
							indexer_rule_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(indexer_rule_id as i64),
						),
					]),
				),
				Self::LocationId(value) => (location_id::NAME, value.into()),
				Self::LocationIs(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationIsNot(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRuleId(value) => (indexer_rule_id::NAME, value.into()),
				Self::IndexerRuleIs(where_params) => (
					indexer_rule::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRuleIsNot(where_params) => (
					indexer_rule::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		LocationIdIndexerRuleIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::LocationIdIndexerRuleIdEquals(location_id, indexer_rule_id) => {
					Self::LocationIdIndexerRuleIdEquals(location_id, indexer_rule_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		LocationId(super::SortOrder),
		IndexerRuleId(super::SortOrder),
		Location(Vec<super::location::OrderByWithRelationParam>),
		IndexerRule(Vec<super::indexer_rule::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::LocationId(param) => ("location_id", param.into()),
				Self::IndexerRuleId(param) => ("indexer_rule_id", param.into()),
				Self::Location(param) => (
					"location",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::IndexerRule(param) => (
					"indexer_rule",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {
		Location(super::location::UniqueArgs),
		IndexerRule(super::indexer_rule::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Location(args) => {
					let mut selections = < super :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(location::NAME, None, [], selections)
				}
				Self::IndexerRule(args) => {
					let mut selections = < super :: indexer_rule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(indexer_rule::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		LocationId(super::_prisma::write_params::IntParam),
		ConnectLocation(super::location::UniqueWhereParam),
		IndexerRuleId(super::_prisma::write_params::IntParam),
		ConnectIndexerRule(super::indexer_rule::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::LocationId(value) => (location_id::NAME, value.into()),
				Self::ConnectLocation(where_param) => (
					location::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRuleId(value) => (indexer_rule_id::NAME, value.into()),
				Self::ConnectIndexerRule(where_param) => (
					indexer_rule::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::indexer_rule::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		LocationId(super::_prisma::write_params::IntParam),
		IndexerRuleId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::LocationId(value) => ("location_id", value.into()),
				Self::IndexerRuleId(value) => ("indexer_rule_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_indexer_rules_in_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: indexer_rules_in_location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: indexer_rules_in_location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { location_id , location , indexer_rule_id , indexer_rule } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: indexer_rules_in_location :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["location_id" , "location" , "indexer_rule_id" , "indexer_rule"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: indexer_rules_in_location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { location :: Data } ; (@ field_type ; indexer_rule : $ selection_mode : ident { $ ($ selections : tt) + }) => { indexer_rule :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "IndexerRulesInLocation" , available relations are "location_id, location, indexer_rule_id, indexer_rule")) } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; indexer_rule : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: indexer_rule :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; location_id) => { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: location_id :: Select) } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: location :: Select :: $ selection_mode (sd_prisma :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: location :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; indexer_rule_id) => { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule_id :: Select) } ; (@ selection_field_to_selection_param ; indexer_rule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule :: Select :: $ selection_mode (sd_prisma :: prisma :: indexer_rule :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; indexer_rule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: SelectParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: indexer_rules_in_location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; location) => { "location" } ; (@ field_serde_name ; indexer_rule_id) => { "indexer_rule_id" } ; (@ field_serde_name ; indexer_rule) => { "indexer_rule" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_indexer_rules_in_location as select;
	pub enum SelectParam {
		LocationId(location_id::Select),
		Location(location::Select),
		IndexerRuleId(indexer_rule_id::Select),
		IndexerRule(indexer_rule::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::LocationId(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::IndexerRuleId(data) => data.to_selection(),
				Self::IndexerRule(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_indexer_rules_in_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: indexer_rules_in_location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: indexer_rules_in_location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { location , indexer_rule } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: indexer_rules_in_location :: location_id :: NAME)] pub location_id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME)] pub indexer_rule_id : i32 , $ (# [specta (rename_from_path = sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: indexer_rules_in_location :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (location_id) , stringify ! (indexer_rule_id)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: indexer_rules_in_location :: location_id :: NAME , & self . location_id) ? ; state . serialize_field (sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME , & self . indexer_rule_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , location_id , indexer_rule_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME) , + , sd_prisma :: prisma :: indexer_rules_in_location :: location_id :: NAME , sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: indexer_rules_in_location :: location_id :: NAME => Ok (Field :: location_id) , sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME => Ok (Field :: indexer_rule_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut location_id = None ; let mut indexer_rule_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: location_id => { if location_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rules_in_location :: location_id :: NAME)) ; } location_id = Some (map . next_value () ?) ; } Field :: indexer_rule_id => { if indexer_rule_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME)) ; } indexer_rule_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: NAME)) ? ;) * let location_id = location_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rules_in_location :: location_id :: NAME)) ? ; let indexer_rule_id = indexer_rule_id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME)) ? ; Ok (Data { location_id , indexer_rule_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["location_id" , "location" , "indexer_rule_id" , "indexer_rule"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: indexer_rules_in_location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { location :: Data } ; (@ field_type ; indexer_rule : $ selection_mode : ident { $ ($ selections : tt) + }) => { indexer_rule :: Data } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: indexer_rules_in_location :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "IndexerRulesInLocation" , available relations are "location, indexer_rule")) } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; indexer_rule : $ selection_mode : ident { $ ($ selections : tt) + }) => { sd_prisma :: prisma :: indexer_rule :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: IncludeParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: location :: Include :: $ selection_mode (sd_prisma :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: IncludeParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: location :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; indexer_rule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: IncludeParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule :: Include :: $ selection_mode (sd_prisma :: prisma :: indexer_rule :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; indexer_rule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < sd_prisma :: prisma :: indexer_rules_in_location :: IncludeParam > :: into (sd_prisma :: prisma :: indexer_rules_in_location :: indexer_rule :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: indexer_rules_in_location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; location) => { "location" } ; (@ field_serde_name ; indexer_rule_id) => { "indexer_rule_id" } ; (@ field_serde_name ; indexer_rule) => { "indexer_rule" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_indexer_rules_in_location as include;
	pub enum IncludeParam {
		LocationId(location_id::Include),
		Location(location::Include),
		IndexerRuleId(indexer_rule_id::Include),
		IndexerRule(indexer_rule::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::LocationId(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::IndexerRuleId(data) => data.to_selection(),
				Self::IndexerRule(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod indexer_rule {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "indexer_rule";
		pub type Type = indexer_rule::Data;
		pub type RecursiveSafeType = Box<indexer_rule::Data>;
		pub fn is(value: Vec<indexer_rule::WhereParam>) -> WhereParam {
			WhereParam::IndexerRuleIs(value)
		}
		pub fn is_not(value: Vec<indexer_rule::WhereParam>) -> WhereParam {
			WhereParam::IndexerRuleIsNot(value)
		}
		pub struct Order(Vec<indexer_rule::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<indexer_rule::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IndexerRule(v)
			}
		}
		pub struct Fetch(pub indexer_rule::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<indexer_rule::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::IndexerRule(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(indexer_rule::UniqueArgs::new())
		}
		pub struct Connect(indexer_rule::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectIndexerRule(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: indexer_rule::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<indexer_rule::SelectParam>),
			Include(Vec<indexer_rule::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IndexerRule(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<indexer_rule::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						)
					}
				};
				::prisma_client_rust::Selection::new("indexer_rule", None, [], selections)
			}
			pub fn select(nested_selections: Vec<indexer_rule::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<indexer_rule::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<indexer_rule::SelectParam>),
			Include(Vec<indexer_rule::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IndexerRule(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = < indexer_rule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<indexer_rule::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						)
					}
				};
				::prisma_client_rust::Selection::new("indexer_rule", None, [], selections)
			}
			pub fn select(nested_selections: Vec<indexer_rule::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<indexer_rule::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod indexer_rule_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "indexer_rule_id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::IndexerRuleId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			IndexerRuleId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IndexerRuleId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IndexerRuleId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IndexerRuleId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IndexerRuleId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IndexerRuleId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod location {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "location";
		pub type Type = location::Data;
		pub type RecursiveSafeType = Box<location::Data>;
		pub fn is(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIs(value)
		}
		pub fn is_not(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIsNot(value)
		}
		pub struct Order(Vec<location::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<location::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Location(v)
			}
		}
		pub struct Fetch(pub location::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<location::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Location(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(location::UniqueArgs::new())
		}
		pub struct Connect(location::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLocation(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: location::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<location::SelectParam>),
			Include(Vec<location::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Location(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("location", None, [], selections)
			}
			pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<location::SelectParam>),
			Include(Vec<location::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Location(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = < location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("location", None, [], selections)
			}
			pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod location_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "location_id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::LocationId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			LocationId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LocationId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LocationId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LocationId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LocationId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LocationId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub location: super::location::UniqueWhereParam,
		pub indexer_rule: super::indexer_rule::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.indexer_rules_in_location().create(
				self.location,
				self.indexer_rule,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				location::connect(self.location),
				indexer_rule::connect(self.indexer_rule),
			]);
			self._params
		}
	}
	pub fn create(
		location: super::location::UniqueWhereParam,
		indexer_rule: super::indexer_rule::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			location,
			indexer_rule,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub location_id: i32,
		pub indexer_rule_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.indexer_rules_in_location().create_unchecked(
				self.location_id,
				self.indexer_rule_id,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				location_id::set(self.location_id),
				indexer_rule_id::set(self.indexer_rule_id),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		location_id: i32,
		indexer_rule_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			location_id,
			indexer_rule_id,
			_params,
		}
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(location_id::NAME),
				::prisma_client_rust::sel(indexer_rule_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(
		rename = "IndexerRulesInLocation",
		crate = "prisma_client_rust::specta"
	)]
	pub struct Data {
		#[serde(rename = "location_id")]
		pub location_id: location_id::Type,
		#[serde(rename = "location")]
		#[specta(skip)]
		pub location: Option<location::RecursiveSafeType>,
		#[serde(rename = "indexer_rule_id")]
		pub indexer_rule_id: indexer_rule_id::Type,
		#[serde(rename = "indexer_rule")]
		#[specta(skip)]
		pub indexer_rule: Option<indexer_rule::RecursiveSafeType>,
	}
	impl Data {
		pub fn location(
			&self,
		) -> Result<&super::location::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.location
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(location),
				))
				.map(|v| v.as_ref())
		}
		pub fn indexer_rule(
			&self,
		) -> Result<&super::indexer_rule::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.indexer_rule
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(indexer_rule),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_indexer_rules_in_location { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: indexer_rules_in_location struct $ struct_name { # [serde (rename = "location_id")] pub location_id : i32 , # [serde (rename = "indexer_rule_id")] pub indexer_rule_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_indexer_rules_in_location as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			location: super::location::UniqueWhereParam,
			indexer_rule: super::indexer_rule::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				location::connect(location),
				indexer_rule::connect(indexer_rule),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			location_id: i32,
			indexer_rule_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				location_id::set(location_id),
				indexer_rule_id::set(indexer_rule_id),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod preference {
	use super::_prisma::*;
	pub const NAME: &str = "Preference";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Key(super::_prisma::read_filters::StringFilter),
		Value(super::_prisma::read_filters::BytesNullableFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Key(value) => (key::NAME, value.into()),
				Self::Value(value) => (value::NAME, value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		KeyEquals(String),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::KeyEquals(value) => {
					Self::Key(super::_prisma::read_filters::StringFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Key(super::SortOrder),
		Value(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Key(param) => ("key", param.into()),
				Self::Value(param) => ("value", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Key(super::_prisma::write_params::StringParam),
		Value(super::_prisma::write_params::BytesNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Key(value) => (key::NAME, value.into()),
				Self::Value(value) => (value::NAME, value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Key(super::_prisma::write_params::StringParam),
		Value(super::_prisma::write_params::BytesNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Key(value) => ("key", value.into()),
				Self::Value(value) => ("value", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_preference { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: preference :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: preference :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: preference :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: preference :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: preference :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: preference :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { key , value } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: preference :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: preference :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: preference :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: preference :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: preference :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: preference :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: preference :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: preference :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["key" , "value"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: preference :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: preference :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Preference" , available relations are "key, value")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; key) => { Into :: < sd_prisma :: prisma :: preference :: SelectParam > :: into (sd_prisma :: prisma :: preference :: key :: Select) } ; (@ selection_field_to_selection_param ; value) => { Into :: < sd_prisma :: prisma :: preference :: SelectParam > :: into (sd_prisma :: prisma :: preference :: value :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: preference :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; key) => { "key" } ; (@ field_serde_name ; value) => { "value" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_preference as select;
	pub enum SelectParam {
		Key(key::Select),
		Value(value::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Key(data) => data.to_selection(),
				Self::Value(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_preference { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: preference :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: preference :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: preference :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: preference :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: preference :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: preference :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: preference :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: preference :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: preference :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: preference :: key :: NAME)] pub key : String , # [specta (rename_from_path = sd_prisma :: prisma :: preference :: value :: NAME)] pub value : Option < Vec < u8 > > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: preference :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: preference :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (key) , stringify ! (value)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: preference :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: preference :: key :: NAME , & self . key) ? ; state . serialize_field (sd_prisma :: prisma :: preference :: value :: NAME , & self . value) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , key , value } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: preference :: $ field :: NAME) , + , sd_prisma :: prisma :: preference :: key :: NAME , sd_prisma :: prisma :: preference :: value :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: preference :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: preference :: key :: NAME => Ok (Field :: key) , sd_prisma :: prisma :: preference :: value :: NAME => Ok (Field :: value) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut key = None ; let mut value = None ; while let Some (key) = map . next_key () ? { match key { Field :: key => { if key . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: preference :: key :: NAME)) ; } key = Some (map . next_value () ?) ; } Field :: value => { if value . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: preference :: value :: NAME)) ; } value = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: preference :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: preference :: $ field :: NAME)) ? ;) * let key = key . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: preference :: key :: NAME)) ? ; let value = value . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: preference :: value :: NAME)) ? ; Ok (Data { key , value , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["key" , "value"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: preference :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: preference :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Preference" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: preference :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; key) => { "key" } ; (@ field_serde_name ; value) => { "value" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_preference as include;
	pub enum IncludeParam {
		Key(key::Include),
		Value(value::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Key(data) => data.to_selection(),
				Self::Value(data) => data.to_selection(),
			}
		}
	}
	pub mod key {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key";
		pub type Type = String;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::KeyEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Key, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Key(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Key(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Key(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Key(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Key(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Key(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Key(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod value {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "value";
		pub type Type = Option<Vec<u8>>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::Value(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			Value,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Value(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Value(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Value(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Value(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Value(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Value(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Value(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub key: String,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.preference().create(self.key, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([key::set(self.key)]);
			self._params
		}
	}
	pub fn create(key: String, _params: Vec<SetParam>) -> Create {
		Create { key, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub key: String,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.preference().create_unchecked(self.key, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([key::set(self.key)]);
			self._params
		}
	}
	pub fn create_unchecked(key: String, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { key, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(key::NAME),
				::prisma_client_rust::sel(value::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Preference", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "key")]
		pub key: key::Type,
		#[serde(rename = "value")]
		pub value: value::Type,
	}
	impl Data {}
	#[macro_export]
	macro_rules ! _partial_unchecked_preference { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: preference struct $ struct_name { # [serde (rename = "key")] pub key : String , # [serde (rename = "value")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub value : Option < Vec < u8 > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_preference as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, key: String, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([key::set(key)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			key: String,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([key::set(key)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod notification {
	use super::_prisma::*;
	pub const NAME: &str = "Notification";
	#[derive(Debug, Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		Read(super::_prisma::read_filters::BooleanFilter),
		Data(super::_prisma::read_filters::BytesFilter),
		ExpiresAt(super::_prisma::read_filters::DateTimeNullableFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::Read(value) => (read::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::ExpiresAt(value) => (expires_at::NAME, value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Debug, Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		Read(super::SortOrder),
		Data(super::SortOrder),
		ExpiresAt(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::Read(param) => ("read", param.into()),
				Self::Data(param) => ("data", param.into()),
				Self::ExpiresAt(param) => ("expires_at", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Debug, Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		Read(super::_prisma::write_params::BooleanParam),
		Data(super::_prisma::write_params::BytesParam),
		ExpiresAt(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::Read(value) => (read::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::ExpiresAt(value) => (expires_at::NAME, value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Debug, Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		Read(super::_prisma::write_params::BooleanParam),
		Data(super::_prisma::write_params::BytesParam),
		ExpiresAt(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::Read(value) => ("read", value.into()),
				Self::Data(value) => ("data", value.into()),
				Self::ExpiresAt(value) => ("expires_at", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_notification { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: notification :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: notification :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: notification :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: notification :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: notification :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: notification :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , read , data , expires_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: notification :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = sd_prisma :: prisma :: notification :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: notification :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: notification :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: notification :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: notification :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: notification :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: notification :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "read" , "data" , "expires_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: notification :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: notification :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Notification" , available relations are "id, read, data, expires_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < sd_prisma :: prisma :: notification :: SelectParam > :: into (sd_prisma :: prisma :: notification :: id :: Select) } ; (@ selection_field_to_selection_param ; read) => { Into :: < sd_prisma :: prisma :: notification :: SelectParam > :: into (sd_prisma :: prisma :: notification :: read :: Select) } ; (@ selection_field_to_selection_param ; data) => { Into :: < sd_prisma :: prisma :: notification :: SelectParam > :: into (sd_prisma :: prisma :: notification :: data :: Select) } ; (@ selection_field_to_selection_param ; expires_at) => { Into :: < sd_prisma :: prisma :: notification :: SelectParam > :: into (sd_prisma :: prisma :: notification :: expires_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: notification :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; read) => { "read" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; expires_at) => { "expires_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_notification as select;
	pub enum SelectParam {
		Id(id::Select),
		Read(read::Select),
		Data(data::Select),
		ExpiresAt(expires_at::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Read(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::ExpiresAt(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_notification { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { sd_prisma :: prisma :: notification :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: notification :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([sd_prisma :: prisma :: notification :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: notification :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { sd_prisma :: prisma :: notification :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = sd_prisma :: prisma :: notification :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([sd_prisma :: prisma :: notification :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < sd_prisma :: prisma :: notification :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; sd_prisma :: prisma :: notification :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = sd_prisma :: prisma :: notification :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = sd_prisma :: prisma :: notification :: read :: NAME)] pub read : bool , # [specta (rename_from_path = sd_prisma :: prisma :: notification :: data :: NAME)] pub data : Vec < u8 > , # [specta (rename_from_path = sd_prisma :: prisma :: notification :: expires_at :: NAME)] pub expires_at : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (# [specta (rename_from_path = sd_prisma :: prisma :: notification :: $ field :: NAME)] pub $ field : sd_prisma :: prisma :: notification :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (read) , stringify ! (data) , stringify ! (expires_at)] . len ()) ? ; $ (state . serialize_field (sd_prisma :: prisma :: notification :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (sd_prisma :: prisma :: notification :: id :: NAME , & self . id) ? ; state . serialize_field (sd_prisma :: prisma :: notification :: read :: NAME , & self . read) ? ; state . serialize_field (sd_prisma :: prisma :: notification :: data :: NAME , & self . data) ? ; state . serialize_field (sd_prisma :: prisma :: notification :: expires_at :: NAME , & self . expires_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , read , data , expires_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (sd_prisma :: prisma :: notification :: $ field :: NAME) , + , sd_prisma :: prisma :: notification :: id :: NAME , sd_prisma :: prisma :: notification :: read :: NAME , sd_prisma :: prisma :: notification :: data :: NAME , sd_prisma :: prisma :: notification :: expires_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (sd_prisma :: prisma :: notification :: $ field :: NAME => Ok (Field :: $ field)) , * , sd_prisma :: prisma :: notification :: id :: NAME => Ok (Field :: id) , sd_prisma :: prisma :: notification :: read :: NAME => Ok (Field :: read) , sd_prisma :: prisma :: notification :: data :: NAME => Ok (Field :: data) , sd_prisma :: prisma :: notification :: expires_at :: NAME => Ok (Field :: expires_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut read = None ; let mut data = None ; let mut expires_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: notification :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: read => { if read . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: notification :: read :: NAME)) ; } read = Some (map . next_value () ?) ; } Field :: data => { if data . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: notification :: data :: NAME)) ; } data = Some (map . next_value () ?) ; } Field :: expires_at => { if expires_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: notification :: expires_at :: NAME)) ; } expires_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (sd_prisma :: prisma :: notification :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: notification :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: notification :: id :: NAME)) ? ; let read = read . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: notification :: read :: NAME)) ? ; let data = data . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: notification :: data :: NAME)) ? ; let expires_at = expires_at . ok_or_else (|| serde :: de :: Error :: missing_field (sd_prisma :: prisma :: notification :: expires_at :: NAME)) ? ; Ok (Data { id , read , data , expires_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "read" , "data" , "expires_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { sd_prisma :: prisma :: notification :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident) => { sd_prisma :: prisma :: notification :: $ field :: Type } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Notification" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (sd_prisma :: prisma :: notification :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; read) => { "read" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; expires_at) => { "expires_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_notification as include;
	pub enum IncludeParam {
		Id(id::Include),
		Read(read::Include),
		Data(data::Include),
		ExpiresAt(expires_at::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Read(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::ExpiresAt(data) => data.to_selection(),
			}
		}
	}
	pub mod data {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "data";
		pub type Type = Vec<u8>;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::Data(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Data, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Data(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Data(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Data(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod expires_at {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "expires_at";
		pub type Type = Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>;
		pub type RecursiveSafeType = Type;
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::ExpiresAt(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			ExpiresAt,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ExpiresAt(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ExpiresAt(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::ExpiresAt(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ExpiresAt(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ExpiresAt(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ExpiresAt(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ExpiresAt(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub type Type = i32;
		pub type RecursiveSafeType = Type;
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod read {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "read";
		pub type Type = bool;
		pub type RecursiveSafeType = Type;
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::Read(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			Read,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Read(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Read(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Read(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Read(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Read(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Read(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Read(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Debug, Clone)]
	pub struct Create {
		pub data: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.notification().create(self.data, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([data::set(self.data)]);
			self._params
		}
	}
	pub fn create(data: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { data, _params }
	}
	#[derive(Debug, Clone)]
	pub struct CreateUnchecked {
		pub data: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.notification()
				.create_unchecked(self.data, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([data::set(self.data)]);
			self._params
		}
	}
	pub fn create_unchecked(data: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { data, _params }
	}
	#[derive(Debug, Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(read::NAME),
				::prisma_client_rust::sel(data::NAME),
				::prisma_client_rust::sel(expires_at::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Notification", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: id::Type,
		#[serde(rename = "read")]
		pub read: read::Type,
		#[serde(rename = "data")]
		pub data: data::Type,
		#[serde(rename = "expires_at")]
		pub expires_at: expires_at::Type,
	}
	impl Data {}
	#[macro_export]
	macro_rules ! _partial_unchecked_notification { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { sd_prisma :: prisma :: notification struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "read")] pub read : bool , # [serde (rename = "data")] pub data : Vec < u8 > , # [serde (rename = "expires_at")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub expires_at : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_notification as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, data: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([data::set(data)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			data: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([data::set(data)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod _prisma {
	pub struct PrismaClientBuilder {
		url: Option<String>,
		action_notifier: ::prisma_client_rust::ActionNotifier,
	}
	impl PrismaClientBuilder {
		fn new() -> Self {
			Self {
				url: None,
				action_notifier: ::prisma_client_rust::ActionNotifier::new(),
			}
		}
		pub fn with_url(mut self, url: String) -> Self {
			self.url = Some(url);
			self
		}
		pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
			let internals = ::prisma_client_rust::PrismaClientInternals::new(
				self.url,
				self.action_notifier,
				super::DATAMODEL_STR,
			)
			.await?;
			Ok(PrismaClient(internals))
		}
	}
	pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
	impl ::std::fmt::Debug for PrismaClient {
		fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
			f.debug_struct("PrismaClient").finish()
		}
	}
	impl PrismaClient {
		pub fn _builder() -> PrismaClientBuilder {
			PrismaClientBuilder::new()
		}
		pub fn _query_raw<T: ::prisma_client_rust::Data>(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::QueryRaw<T> {
			::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub fn _execute_raw(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::ExecuteRaw {
			::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub async fn _batch<
			'batch,
			T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
			Marker,
		>(
			&self,
			queries: T,
		) -> ::prisma_client_rust::Result<
			<T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
		> {
			::prisma_client_rust::batch(queries, &self.0).await
		}
		pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
			::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
		}
		pub async fn _migrate_deploy(
			&self,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateDeployError> {
			let res = ::prisma_client_rust::migrations::migrate_deploy(
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.0.url(),
			)
			.await;
			::prisma_client_rust::tokio::time::sleep(core::time::Duration::from_millis(1)).await;
			res
		}
		pub async fn _migrate_resolve(
			&self,
			migration: &str,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateResolveError> {
			::prisma_client_rust::migrations::migrate_resolve(
				migration,
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.0.url(),
			)
			.await
		}
		pub fn _db_push(&self) -> ::prisma_client_rust::migrations::DbPush {
			::prisma_client_rust::migrations::db_push(super::DATAMODEL_STR, &self.0.url())
		}
		pub fn shared_operation(&self) -> super::shared_operation::Actions {
			super::shared_operation::Actions { client: &self.0 }
		}
		pub fn node(&self) -> super::node::Actions {
			super::node::Actions { client: &self.0 }
		}
		pub fn instance(&self) -> super::instance::Actions {
			super::instance::Actions { client: &self.0 }
		}
		pub fn statistics(&self) -> super::statistics::Actions {
			super::statistics::Actions { client: &self.0 }
		}
		pub fn volume(&self) -> super::volume::Actions {
			super::volume::Actions { client: &self.0 }
		}
		pub fn location(&self) -> super::location::Actions {
			super::location::Actions { client: &self.0 }
		}
		pub fn file_path(&self) -> super::file_path::Actions {
			super::file_path::Actions { client: &self.0 }
		}
		pub fn object(&self) -> super::object::Actions {
			super::object::Actions { client: &self.0 }
		}
		pub fn media_data(&self) -> super::media_data::Actions {
			super::media_data::Actions { client: &self.0 }
		}
		pub fn tag(&self) -> super::tag::Actions {
			super::tag::Actions { client: &self.0 }
		}
		pub fn tag_on_object(&self) -> super::tag_on_object::Actions {
			super::tag_on_object::Actions { client: &self.0 }
		}
		pub fn label(&self) -> super::label::Actions {
			super::label::Actions { client: &self.0 }
		}
		pub fn label_on_object(&self) -> super::label_on_object::Actions {
			super::label_on_object::Actions { client: &self.0 }
		}
		pub fn space(&self) -> super::space::Actions {
			super::space::Actions { client: &self.0 }
		}
		pub fn object_in_space(&self) -> super::object_in_space::Actions {
			super::object_in_space::Actions { client: &self.0 }
		}
		pub fn job(&self) -> super::job::Actions {
			super::job::Actions { client: &self.0 }
		}
		pub fn indexer_rule(&self) -> super::indexer_rule::Actions {
			super::indexer_rule::Actions { client: &self.0 }
		}
		pub fn indexer_rules_in_location(&self) -> super::indexer_rules_in_location::Actions {
			super::indexer_rules_in_location::Actions { client: &self.0 }
		}
		pub fn preference(&self) -> super::preference::Actions {
			super::preference::Actions { client: &self.0 }
		}
		pub fn notification(&self) -> super::notification::Actions {
			super::notification::Actions { client: &self.0 }
		}
	}
	impl ::prisma_client_rust::PrismaClient for PrismaClient {
		fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
			&self.0
		}
		fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
			&mut self.0
		}
		fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
			Self(self.0.with_tx_id(tx_id))
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum FilePathScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "is_dir")]
		IsDir,
		#[serde(rename = "cas_id")]
		CasId,
		#[serde(rename = "integrity_checksum")]
		IntegrityChecksum,
		#[serde(rename = "location_id")]
		LocationId,
		#[serde(rename = "materialized_path")]
		MaterializedPath,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "extension")]
		Extension,
		#[serde(rename = "size_in_bytes")]
		SizeInBytes,
		#[serde(rename = "size_in_bytes_bytes")]
		SizeInBytesBytes,
		#[serde(rename = "inode")]
		Inode,
		#[serde(rename = "device")]
		Device,
		#[serde(rename = "object_id")]
		ObjectId,
		#[serde(rename = "key_id")]
		KeyId,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
		#[serde(rename = "date_indexed")]
		DateIndexed,
	}
	impl ToString for FilePathScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::IsDir => "is_dir".to_string(),
				Self::CasId => "cas_id".to_string(),
				Self::IntegrityChecksum => "integrity_checksum".to_string(),
				Self::LocationId => "location_id".to_string(),
				Self::MaterializedPath => "materialized_path".to_string(),
				Self::Name => "name".to_string(),
				Self::Extension => "extension".to_string(),
				Self::SizeInBytes => "size_in_bytes".to_string(),
				Self::SizeInBytesBytes => "size_in_bytes_bytes".to_string(),
				Self::Inode => "inode".to_string(),
				Self::Device => "device".to_string(),
				Self::ObjectId => "object_id".to_string(),
				Self::KeyId => "key_id".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
				Self::DateIndexed => "date_indexed".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum IndexerRuleScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "default")]
		Default,
		#[serde(rename = "rules_per_kind")]
		RulesPerKind,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for IndexerRuleScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::Default => "default".to_string(),
				Self::RulesPerKind => "rules_per_kind".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum IndexerRulesInLocationScalarFieldEnum {
		#[serde(rename = "location_id")]
		LocationId,
		#[serde(rename = "indexer_rule_id")]
		IndexerRuleId,
	}
	impl ToString for IndexerRulesInLocationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::LocationId => "location_id".to_string(),
				Self::IndexerRuleId => "indexer_rule_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum InstanceScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "identity")]
		Identity,
		#[serde(rename = "node_id")]
		NodeId,
		#[serde(rename = "node_name")]
		NodeName,
		#[serde(rename = "node_platform")]
		NodePlatform,
		#[serde(rename = "last_seen")]
		LastSeen,
		#[serde(rename = "date_created")]
		DateCreated,
	}
	impl ToString for InstanceScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Identity => "identity".to_string(),
				Self::NodeId => "node_id".to_string(),
				Self::NodeName => "node_name".to_string(),
				Self::NodePlatform => "node_platform".to_string(),
				Self::LastSeen => "last_seen".to_string(),
				Self::DateCreated => "date_created".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum JobScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "action")]
		Action,
		#[serde(rename = "status")]
		Status,
		#[serde(rename = "errors_text")]
		ErrorsText,
		#[serde(rename = "data")]
		Data,
		#[serde(rename = "metadata")]
		Metadata,
		#[serde(rename = "parent_id")]
		ParentId,
		#[serde(rename = "task_count")]
		TaskCount,
		#[serde(rename = "completed_task_count")]
		CompletedTaskCount,
		#[serde(rename = "date_estimated_completion")]
		DateEstimatedCompletion,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_started")]
		DateStarted,
		#[serde(rename = "date_completed")]
		DateCompleted,
	}
	impl ToString for JobScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Name => "name".to_string(),
				Self::Action => "action".to_string(),
				Self::Status => "status".to_string(),
				Self::ErrorsText => "errors_text".to_string(),
				Self::Data => "data".to_string(),
				Self::Metadata => "metadata".to_string(),
				Self::ParentId => "parent_id".to_string(),
				Self::TaskCount => "task_count".to_string(),
				Self::CompletedTaskCount => "completed_task_count".to_string(),
				Self::DateEstimatedCompletion => "date_estimated_completion".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateStarted => "date_started".to_string(),
				Self::DateCompleted => "date_completed".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum LabelOnObjectScalarFieldEnum {
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "label_id")]
		LabelId,
		#[serde(rename = "object_id")]
		ObjectId,
	}
	impl ToString for LabelOnObjectScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::DateCreated => "date_created".to_string(),
				Self::LabelId => "label_id".to_string(),
				Self::ObjectId => "object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum LabelScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for LabelScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum LocationScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "path")]
		Path,
		#[serde(rename = "total_capacity")]
		TotalCapacity,
		#[serde(rename = "available_capacity")]
		AvailableCapacity,
		#[serde(rename = "is_archived")]
		IsArchived,
		#[serde(rename = "generate_preview_media")]
		GeneratePreviewMedia,
		#[serde(rename = "sync_preview_media")]
		SyncPreviewMedia,
		#[serde(rename = "hidden")]
		Hidden,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "instance_id")]
		InstanceId,
	}
	impl ToString for LocationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::Path => "path".to_string(),
				Self::TotalCapacity => "total_capacity".to_string(),
				Self::AvailableCapacity => "available_capacity".to_string(),
				Self::IsArchived => "is_archived".to_string(),
				Self::GeneratePreviewMedia => "generate_preview_media".to_string(),
				Self::SyncPreviewMedia => "sync_preview_media".to_string(),
				Self::Hidden => "hidden".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::InstanceId => "instance_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum MediaDataScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_taken")]
		DateTaken,
		#[serde(rename = "pixel_width")]
		PixelWidth,
		#[serde(rename = "pixel_height")]
		PixelHeight,
		#[serde(rename = "color_space")]
		ColorSpace,
		#[serde(rename = "longitude")]
		Longitude,
		#[serde(rename = "latitude")]
		Latitude,
		#[serde(rename = "codecs")]
		Codecs,
		#[serde(rename = "device_make")]
		DeviceMake,
		#[serde(rename = "device_model")]
		DeviceModel,
		#[serde(rename = "device_software")]
		DeviceSoftware,
		#[serde(rename = "focal_length")]
		FocalLength,
		#[serde(rename = "shutter_speed")]
		ShutterSpeed,
		#[serde(rename = "orientation")]
		Orientation,
		#[serde(rename = "copyright")]
		Copyright,
		#[serde(rename = "flash")]
		Flash,
		#[serde(rename = "artist")]
		Artist,
		#[serde(rename = "duration")]
		Duration,
		#[serde(rename = "fps")]
		Fps,
		#[serde(rename = "streams")]
		Streams,
	}
	impl ToString for MediaDataScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateTaken => "date_taken".to_string(),
				Self::PixelWidth => "pixel_width".to_string(),
				Self::PixelHeight => "pixel_height".to_string(),
				Self::ColorSpace => "color_space".to_string(),
				Self::Longitude => "longitude".to_string(),
				Self::Latitude => "latitude".to_string(),
				Self::Codecs => "codecs".to_string(),
				Self::DeviceMake => "device_make".to_string(),
				Self::DeviceModel => "device_model".to_string(),
				Self::DeviceSoftware => "device_software".to_string(),
				Self::FocalLength => "focal_length".to_string(),
				Self::ShutterSpeed => "shutter_speed".to_string(),
				Self::Orientation => "orientation".to_string(),
				Self::Copyright => "copyright".to_string(),
				Self::Flash => "flash".to_string(),
				Self::Artist => "artist".to_string(),
				Self::Duration => "duration".to_string(),
				Self::Fps => "fps".to_string(),
				Self::Streams => "streams".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum NodeScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "platform")]
		Platform,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "identity")]
		Identity,
		#[serde(rename = "node_peer_id")]
		NodePeerId,
	}
	impl ToString for NodeScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::Platform => "platform".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::Identity => "identity".to_string(),
				Self::NodePeerId => "node_peer_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum NotificationScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "read")]
		Read,
		#[serde(rename = "data")]
		Data,
		#[serde(rename = "expires_at")]
		ExpiresAt,
	}
	impl ToString for NotificationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Read => "read".to_string(),
				Self::Data => "data".to_string(),
				Self::ExpiresAt => "expires_at".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum ObjectInSpaceScalarFieldEnum {
		#[serde(rename = "space_id")]
		SpaceId,
		#[serde(rename = "object_id")]
		ObjectId,
	}
	impl ToString for ObjectInSpaceScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::SpaceId => "space_id".to_string(),
				Self::ObjectId => "object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum ObjectScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "kind")]
		Kind,
		#[serde(rename = "key_id")]
		KeyId,
		#[serde(rename = "hidden")]
		Hidden,
		#[serde(rename = "favorite")]
		Favorite,
		#[serde(rename = "important")]
		Important,
		#[serde(rename = "note")]
		Note,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_accessed")]
		DateAccessed,
	}
	impl ToString for ObjectScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Kind => "kind".to_string(),
				Self::KeyId => "key_id".to_string(),
				Self::Hidden => "hidden".to_string(),
				Self::Favorite => "favorite".to_string(),
				Self::Important => "important".to_string(),
				Self::Note => "note".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateAccessed => "date_accessed".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum PreferenceScalarFieldEnum {
		#[serde(rename = "key")]
		Key,
		#[serde(rename = "value")]
		Value,
	}
	impl ToString for PreferenceScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Key => "key".to_string(),
				Self::Value => "value".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum SharedOperationScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "timestamp")]
		Timestamp,
		#[serde(rename = "model")]
		Model,
		#[serde(rename = "record_id")]
		RecordId,
		#[serde(rename = "kind")]
		Kind,
		#[serde(rename = "data")]
		Data,
		#[serde(rename = "instance_id")]
		InstanceId,
	}
	impl ToString for SharedOperationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Timestamp => "timestamp".to_string(),
				Self::Model => "model".to_string(),
				Self::RecordId => "record_id".to_string(),
				Self::Kind => "kind".to_string(),
				Self::Data => "data".to_string(),
				Self::InstanceId => "instance_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum SortOrder {
		#[serde(rename = "asc")]
		Asc,
		#[serde(rename = "desc")]
		Desc,
	}
	impl ToString for SortOrder {
		fn to_string(&self) -> String {
			match self {
				Self::Asc => "asc".to_string(),
				Self::Desc => "desc".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum SpaceScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "description")]
		Description,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for SpaceScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::Description => "description".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum StatisticsScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "date_captured")]
		DateCaptured,
		#[serde(rename = "total_object_count")]
		TotalObjectCount,
		#[serde(rename = "library_db_size")]
		LibraryDbSize,
		#[serde(rename = "total_bytes_used")]
		TotalBytesUsed,
		#[serde(rename = "total_bytes_capacity")]
		TotalBytesCapacity,
		#[serde(rename = "total_unique_bytes")]
		TotalUniqueBytes,
		#[serde(rename = "total_bytes_free")]
		TotalBytesFree,
		#[serde(rename = "preview_media_bytes")]
		PreviewMediaBytes,
	}
	impl ToString for StatisticsScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::DateCaptured => "date_captured".to_string(),
				Self::TotalObjectCount => "total_object_count".to_string(),
				Self::LibraryDbSize => "library_db_size".to_string(),
				Self::TotalBytesUsed => "total_bytes_used".to_string(),
				Self::TotalBytesCapacity => "total_bytes_capacity".to_string(),
				Self::TotalUniqueBytes => "total_unique_bytes".to_string(),
				Self::TotalBytesFree => "total_bytes_free".to_string(),
				Self::PreviewMediaBytes => "preview_media_bytes".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum TagOnObjectScalarFieldEnum {
		#[serde(rename = "tag_id")]
		TagId,
		#[serde(rename = "object_id")]
		ObjectId,
	}
	impl ToString for TagOnObjectScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::TagId => "tag_id".to_string(),
				Self::ObjectId => "object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum TagScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "color")]
		Color,
		#[serde(rename = "redundancy_goal")]
		RedundancyGoal,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for TagScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::Color => "color".to_string(),
				Self::RedundancyGoal => "redundancy_goal".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum TransactionIsolationLevel {
		#[serde(rename = "Serializable")]
		Serializable,
	}
	impl ToString for TransactionIsolationLevel {
		fn to_string(&self) -> String {
			match self {
				Self::Serializable => "Serializable".to_string(),
			}
		}
	}
	impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum VolumeScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "mount_point")]
		MountPoint,
		#[serde(rename = "total_bytes_capacity")]
		TotalBytesCapacity,
		#[serde(rename = "total_bytes_available")]
		TotalBytesAvailable,
		#[serde(rename = "disk_type")]
		DiskType,
		#[serde(rename = "filesystem")]
		Filesystem,
		#[serde(rename = "is_system")]
		IsSystem,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for VolumeScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Name => "name".to_string(),
				Self::MountPoint => "mount_point".to_string(),
				Self::TotalBytesCapacity => "total_bytes_capacity".to_string(),
				Self::TotalBytesAvailable => "total_bytes_available".to_string(),
				Self::DiskType => "disk_type".to_string(),
				Self::Filesystem => "filesystem".to_string(),
				Self::IsSystem => "is_system".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	impl Into<::prisma_client_rust::PrismaValue> for SortOrder {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				SortOrder::Asc => ::prisma_client_rust::PrismaValue::String("asc".to_string()),
				SortOrder::Desc => ::prisma_client_rust::PrismaValue::String("desc".to_string()),
			}
		}
	}
	pub mod read_filters {
		#[derive(Debug, Clone)]
		pub enum BooleanFilter {
			Equals(bool),
			Not(bool),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BooleanFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::Boolean(value),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum BooleanNullableFilter {
			Equals(Option<bool>),
			Not(Option<bool>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BooleanNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							value
								.map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
								.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
							.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum BigIntFilter {
			Equals(i64),
			InVec(Vec<i64>),
			NotInVec(Vec<i64>),
			Lt(i64),
			Lte(i64),
			Gt(i64),
			Gte(i64),
			Not(i64),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::BigInt(value),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum FloatNullableFilter {
			Equals(Option<f64>),
			InVec(Vec<f64>),
			NotInVec(Vec<f64>),
			Lt(f64),
			Lte(f64),
			Gt(f64),
			Gte(f64),
			Not(Option<f64>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for FloatNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) }
			}
		}
		#[derive(Debug, Clone)]
		pub enum StringFilter {
			Equals(String),
			InVec(Vec<String>),
			NotInVec(Vec<String>),
			Lt(String),
			Lte(String),
			Gt(String),
			Gte(String),
			Contains(String),
			StartsWith(String),
			EndsWith(String),
			Not(String),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::String(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::String(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Contains(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"contains".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::StartsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"startsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::EndsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"endsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum StringNullableFilter {
			Equals(Option<String>),
			InVec(Vec<String>),
			NotInVec(Vec<String>),
			Lt(String),
			Lte(String),
			Gt(String),
			Gte(String),
			Contains(String),
			StartsWith(String),
			EndsWith(String),
			Not(Option<String>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							value
								.map(|value| ::prisma_client_rust::PrismaValue::String(value))
								.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::String(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::String(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Contains(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"contains".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::StartsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"startsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::EndsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"endsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum BytesFilter {
			Equals(Vec<u8>),
			InVec(Vec<Vec<u8>>),
			NotInVec(Vec<Vec<u8>>),
			Not(Vec<u8>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BytesFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::Bytes(value),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
									.collect(),
							),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Bytes(value),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum BytesNullableFilter {
			Equals(Option<Vec<u8>>),
			InVec(Vec<Vec<u8>>),
			NotInVec(Vec<Vec<u8>>),
			Not(Option<Vec<u8>>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BytesNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							value
								.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
								.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
									.collect(),
							),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
							.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum DateTimeFilter {
			Equals(
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			),
			InVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			NotInVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::DateTime(value),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum DateTimeNullableFilter {
			Equals(
				Option<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			InVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			NotInVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Not(
				Option<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							value
								.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
								.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
							.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum IntFilter {
			Equals(i32),
			InVec(Vec<i32>),
			NotInVec(Vec<i32>),
			Lt(i32),
			Lte(i32),
			Gt(i32),
			Gte(i32),
			Not(i32),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::Int(value as i64),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| {
										::prisma_client_rust::PrismaValue::Int(value as i64)
									})
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| {
										::prisma_client_rust::PrismaValue::Int(value as i64)
									})
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum IntNullableFilter {
			Equals(Option<i32>),
			InVec(Vec<i32>),
			NotInVec(Vec<i32>),
			Lt(i32),
			Lte(i32),
			Gt(i32),
			Gte(i32),
			Not(Option<i32>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for IntNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							value
								.map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
								.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| {
										::prisma_client_rust::PrismaValue::Int(value as i64)
									})
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| {
										::prisma_client_rust::PrismaValue::Int(value as i64)
									})
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
							.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					)]),
				}
			}
		}
	}
	pub mod write_params {
		#[derive(Debug, Clone)]
		pub enum BooleanParam {
			Set(bool),
		}
		impl Into<::prisma_client_rust::PrismaValue> for BooleanParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::Boolean(value),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum BooleanNullableParam {
			Set(Option<bool>),
		}
		impl Into<::prisma_client_rust::PrismaValue> for BooleanNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => value
						.map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum BigIntParam {
			Set(i64),
			Increment(i64),
			Decrement(i64),
			Multiply(i64),
			Divide(i64),
		}
		impl Into<::prisma_client_rust::PrismaValue> for BigIntParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::BigInt(value),
					Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum FloatNullableParam {
			Set(Option<f64>),
			Increment(f64),
			Decrement(f64),
			Multiply(f64),
			Divide(f64),
		}
		impl Into<::prisma_client_rust::PrismaValue> for FloatNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self { Self :: Set (value) => value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null) , Self :: Increment (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Decrement (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Multiply (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Divide (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) }
			}
		}
		#[derive(Debug, Clone)]
		pub enum StringParam {
			Set(String),
		}
		impl Into<::prisma_client_rust::PrismaValue> for StringParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::String(value),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum StringNullableParam {
			Set(Option<String>),
		}
		impl Into<::prisma_client_rust::PrismaValue> for StringNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum BytesParam {
			Set(Vec<u8>),
		}
		impl Into<::prisma_client_rust::PrismaValue> for BytesParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::Bytes(value),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum BytesNullableParam {
			Set(Option<Vec<u8>>),
		}
		impl Into<::prisma_client_rust::PrismaValue> for BytesNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => value
						.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum DateTimeParam {
			Set(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
		}
		impl Into<::prisma_client_rust::PrismaValue> for DateTimeParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::DateTime(value),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum DateTimeNullableParam {
			Set(
				Option<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
		}
		impl Into<::prisma_client_rust::PrismaValue> for DateTimeNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => value
						.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum IntParam {
			Set(i32),
			Increment(i32),
			Decrement(i32),
			Multiply(i32),
			Divide(i32),
		}
		impl Into<::prisma_client_rust::PrismaValue> for IntParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::Int(value as i64),
					Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				}
			}
		}
		#[derive(Debug, Clone)]
		pub enum IntNullableParam {
			Set(Option<i32>),
			Increment(i32),
			Decrement(i32),
			Multiply(i32),
			Divide(i32),
		}
		impl Into<::prisma_client_rust::PrismaValue> for IntNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => value
						.map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				}
			}
		}
	}
}
pub use _prisma::*;
