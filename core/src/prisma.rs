// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str =
	include_str!("/Users/broken/Code/spacedrive/core/prisma/schema.prisma");
static DATABASE_STR: &'static str = "sqlite";
use ::prisma_client_rust::migrations::include_dir;
pub static MIGRATIONS_DIR: &::prisma_client_rust::migrations::include_dir::Dir = &::prisma_client_rust::migrations::include_dir::include_dir!(
	"/Users/broken/Code/spacedrive/core/prisma/migrations"
);
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
	url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	PrismaClient::_builder()
		.with_url(url.to_string())
		.build()
		.await
}
pub mod owned_operation {
	use super::_prisma::*;
	pub const NAME: &str = "OwnedOperation";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::BytesFilter),
		Timestamp(super::_prisma::read_filters::BigIntFilter),
		Data(super::_prisma::read_filters::BytesFilter),
		Model(super::_prisma::read_filters::StringFilter),
		NodeId(super::_prisma::read_filters::IntFilter),
		NodeIs(Vec<super::node::WhereParam>),
		NodeIsNot(Vec<super::node::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::Timestamp(value) => (timestamp::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::Model(value) => (model::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::NodeIs(where_params) => (
					node::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::NodeIsNot(where_params) => (
					node::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		Timestamp(super::SortOrder),
		Data(super::SortOrder),
		Model(super::SortOrder),
		NodeId(super::SortOrder),
		Node(Vec<super::node::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::Timestamp(param) => ("timestamp", param.into()),
				Self::Data(param) => ("data", param.into()),
				Self::Model(param) => ("model", param.into()),
				Self::NodeId(param) => ("node_id", param.into()),
				Self::Node(param) => (
					"node",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Node(super::node::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Node(args) => {
					let mut selections =
						<super::node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(node::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::BytesParam),
		Timestamp(super::_prisma::write_params::BigIntParam),
		Data(super::_prisma::write_params::BytesParam),
		Model(super::_prisma::write_params::StringParam),
		NodeId(super::_prisma::write_params::IntParam),
		ConnectNode(super::node::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::Timestamp(value) => (timestamp::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::Model(value) => (model::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::ConnectNode(where_param) => (
					node::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::node::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::BytesParam),
		Timestamp(super::_prisma::write_params::BigIntParam),
		Data(super::_prisma::write_params::BytesParam),
		Model(super::_prisma::write_params::StringParam),
		NodeId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::Timestamp(value) => ("timestamp", value.into()),
				Self::Data(value) => ("data", value.into()),
				Self::Model(value) => ("model", value.into()),
				Self::NodeId(value) => ("node_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_owned_operation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: owned_operation :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: owned_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: owned_operation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: owned_operation :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: owned_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: owned_operation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , timestamp , data , model , node_id , node } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: owned_operation :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: owned_operation :: $ field :: NAME)] pub $ field : crate :: prisma :: owned_operation :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: owned_operation :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: owned_operation :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: owned_operation :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: owned_operation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: owned_operation :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "timestamp" , "data" , "model" , "node_id" , "node"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: owned_operation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { Vec < u8 > } ; (@ field_type ; timestamp) => { i64 } ; (@ field_type ; data) => { Vec < u8 > } ; (@ field_type ; model) => { String } ; (@ field_type ; node_id) => { i32 } ; (@ field_type ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { node :: Data } ; (@ field_type ; node) => { crate :: prisma :: node :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "OwnedOperation" , available relations are "id, timestamp, data, model, node_id, node")) } ; (@ field_module ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: node :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: owned_operation :: SelectParam > :: into (crate :: prisma :: owned_operation :: id :: Select) } ; (@ selection_field_to_selection_param ; timestamp) => { Into :: < crate :: prisma :: owned_operation :: SelectParam > :: into (crate :: prisma :: owned_operation :: timestamp :: Select) } ; (@ selection_field_to_selection_param ; data) => { Into :: < crate :: prisma :: owned_operation :: SelectParam > :: into (crate :: prisma :: owned_operation :: data :: Select) } ; (@ selection_field_to_selection_param ; model) => { Into :: < crate :: prisma :: owned_operation :: SelectParam > :: into (crate :: prisma :: owned_operation :: model :: Select) } ; (@ selection_field_to_selection_param ; node_id) => { Into :: < crate :: prisma :: owned_operation :: SelectParam > :: into (crate :: prisma :: owned_operation :: node_id :: Select) } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: owned_operation :: SelectParam > :: into (crate :: prisma :: owned_operation :: node :: Select :: $ selection_mode (crate :: prisma :: node :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: owned_operation :: SelectParam > :: into (crate :: prisma :: owned_operation :: node :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: owned_operation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; model) => { "model" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; node) => { "node" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_owned_operation as select;
	pub enum SelectParam {
		Id(id::Select),
		Timestamp(timestamp::Select),
		Data(data::Select),
		Model(model::Select),
		NodeId(node_id::Select),
		Node(node::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Timestamp(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::Model(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Node(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_owned_operation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: owned_operation :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: owned_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: owned_operation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: owned_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: owned_operation :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: owned_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: owned_operation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: owned_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { node } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: owned_operation :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: owned_operation :: id :: NAME)] pub id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: owned_operation :: timestamp :: NAME)] pub timestamp : i64 , # [specta (rename_from_path = crate :: prisma :: owned_operation :: data :: NAME)] pub data : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: owned_operation :: model :: NAME)] pub model : String , # [specta (rename_from_path = crate :: prisma :: owned_operation :: node_id :: NAME)] pub node_id : i32 , $ (# [specta (rename_from_path = crate :: prisma :: owned_operation :: $ field :: NAME)] pub $ field : crate :: prisma :: owned_operation :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (timestamp) , stringify ! (data) , stringify ! (model) , stringify ! (node_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: owned_operation :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: owned_operation :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: owned_operation :: timestamp :: NAME , & self . timestamp) ? ; state . serialize_field (crate :: prisma :: owned_operation :: data :: NAME , & self . data) ? ; state . serialize_field (crate :: prisma :: owned_operation :: model :: NAME , & self . model) ? ; state . serialize_field (crate :: prisma :: owned_operation :: node_id :: NAME , & self . node_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , timestamp , data , model , node_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: owned_operation :: $ field :: NAME) , + , crate :: prisma :: owned_operation :: id :: NAME , crate :: prisma :: owned_operation :: timestamp :: NAME , crate :: prisma :: owned_operation :: data :: NAME , crate :: prisma :: owned_operation :: model :: NAME , crate :: prisma :: owned_operation :: node_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: owned_operation :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: owned_operation :: id :: NAME => Ok (Field :: id) , crate :: prisma :: owned_operation :: timestamp :: NAME => Ok (Field :: timestamp) , crate :: prisma :: owned_operation :: data :: NAME => Ok (Field :: data) , crate :: prisma :: owned_operation :: model :: NAME => Ok (Field :: model) , crate :: prisma :: owned_operation :: node_id :: NAME => Ok (Field :: node_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut timestamp = None ; let mut data = None ; let mut model = None ; let mut node_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: owned_operation :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: timestamp => { if timestamp . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: owned_operation :: timestamp :: NAME)) ; } timestamp = Some (map . next_value () ?) ; } Field :: data => { if data . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: owned_operation :: data :: NAME)) ; } data = Some (map . next_value () ?) ; } Field :: model => { if model . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: owned_operation :: model :: NAME)) ; } model = Some (map . next_value () ?) ; } Field :: node_id => { if node_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: owned_operation :: node_id :: NAME)) ; } node_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: owned_operation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: owned_operation :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: owned_operation :: id :: NAME)) ? ; let timestamp = timestamp . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: owned_operation :: timestamp :: NAME)) ? ; let data = data . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: owned_operation :: data :: NAME)) ? ; let model = model . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: owned_operation :: model :: NAME)) ? ; let node_id = node_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: owned_operation :: node_id :: NAME)) ? ; Ok (Data { id , timestamp , data , model , node_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "timestamp" , "data" , "model" , "node_id" , "node"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: owned_operation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { node :: Data } ; (@ field_type ; node) => { crate :: prisma :: node :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "OwnedOperation" , available relations are "node")) } ; (@ field_module ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: node :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: owned_operation :: IncludeParam > :: into (crate :: prisma :: owned_operation :: node :: Include :: $ selection_mode (crate :: prisma :: node :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: owned_operation :: IncludeParam > :: into (crate :: prisma :: owned_operation :: node :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: owned_operation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; model) => { "model" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; node) => { "node" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_owned_operation as include;
	pub enum IncludeParam {
		Id(id::Include),
		Timestamp(timestamp::Include),
		Data(data::Include),
		Model(model::Include),
		NodeId(node_id::Include),
		Node(node::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Timestamp(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::Model(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Node(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod data {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "data";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::Data(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Data, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Data(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Data(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Data(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Id, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod model {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "model";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Model(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			Model,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Model(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Model(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Model(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Model(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Model(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Model(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Model(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod node {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node";
		pub fn is(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIs(value)
		}
		pub fn is_not(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIsNot(value)
		}
		pub struct Order(Vec<node::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<node::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Node(v)
			}
		}
		pub struct Fetch(pub node::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<node::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Node(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(node::UniqueArgs::new())
		}
		pub struct Connect(node::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectNode(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: node::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<node::SelectParam>),
			Include(Vec<node::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Node(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("node", None, [], selections)
			}
			pub fn select(nested_selections: Vec<node::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<node::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<node::SelectParam>),
			Include(Vec<node::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Node(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("node", None, [], selections)
			}
			pub fn select(nested_selections: Vec<node::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<node::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod node_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodeId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, NodeId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NodeId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NodeId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod timestamp {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "timestamp";
		pub fn equals(value: i64) -> WhereParam {
			WhereParam::Timestamp(_prisma::read_filters::BigIntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BigIntFilter,
			Timestamp,
			{
				fn in_vec(_: Vec<i64>) -> InVec;
				fn not_in_vec(_: Vec<i64>) -> NotInVec;
				fn lt(_: i64) -> Lt;
				fn lte(_: i64) -> Lte;
				fn gt(_: i64) -> Gt;
				fn gte(_: i64) -> Gte;
				fn not(_: i64) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Timestamp(v)
			}
		}
		pub struct Set(pub i64);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Timestamp(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Timestamp(_prisma::write_params::BigIntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i64) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Timestamp(_prisma::write_params::BigIntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Timestamp(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Timestamp(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Timestamp(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub id: Vec<u8>,
		pub timestamp: i64,
		pub data: Vec<u8>,
		pub model: String,
		pub node: super::node::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.owned_operation().create(
				self.id,
				self.timestamp,
				self.data,
				self.model,
				self.node,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				id::set(self.id),
				timestamp::set(self.timestamp),
				data::set(self.data),
				model::set(self.model),
				node::connect(self.node),
			]);
			self._params
		}
	}
	pub fn create(
		id: Vec<u8>,
		timestamp: i64,
		data: Vec<u8>,
		model: String,
		node: super::node::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			id,
			timestamp,
			data,
			model,
			node,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub id: Vec<u8>,
		pub timestamp: i64,
		pub data: Vec<u8>,
		pub model: String,
		pub node_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.owned_operation().create_unchecked(
				self.id,
				self.timestamp,
				self.data,
				self.model,
				self.node_id,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				id::set(self.id),
				timestamp::set(self.timestamp),
				data::set(self.data),
				model::set(self.model),
				node_id::set(self.node_id),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		id: Vec<u8>,
		timestamp: i64,
		data: Vec<u8>,
		model: String,
		node_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			id,
			timestamp,
			data,
			model,
			node_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(timestamp::NAME),
				::prisma_client_rust::sel(data::NAME),
				::prisma_client_rust::sel(model::NAME),
				::prisma_client_rust::sel(node_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "OwnedOperation", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: Vec<u8>,
		#[serde(rename = "timestamp")]
		pub timestamp: i64,
		#[serde(rename = "data")]
		pub data: Vec<u8>,
		#[serde(rename = "model")]
		pub model: String,
		#[serde(rename = "node_id")]
		pub node_id: i32,
		#[serde(rename = "node")]
		#[specta(skip)]
		pub node: Option<Box<super::node::Data>>,
	}
	impl Data {
		pub fn node(
			&self,
		) -> Result<&super::node::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.node
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(node),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_owned_operation { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: owned_operation struct $ struct_name { # [serde (rename = "id")] pub id : Vec < u8 > , # [serde (rename = "timestamp")] pub timestamp : i64 , # [serde (rename = "data")] pub data : Vec < u8 > , # [serde (rename = "model")] pub model : String , # [serde (rename = "node_id")] pub node_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_owned_operation as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			id: Vec<u8>,
			timestamp: i64,
			data: Vec<u8>,
			model: String,
			node: super::node::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				id::set(id),
				timestamp::set(timestamp),
				data::set(data),
				model::set(model),
				node::connect(node),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			id: Vec<u8>,
			timestamp: i64,
			data: Vec<u8>,
			model: String,
			node_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				id::set(id),
				timestamp::set(timestamp),
				data::set(data),
				model::set(model),
				node_id::set(node_id),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod shared_operation {
	use super::_prisma::*;
	pub const NAME: &str = "SharedOperation";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::BytesFilter),
		Timestamp(super::_prisma::read_filters::BigIntFilter),
		Model(super::_prisma::read_filters::StringFilter),
		RecordId(super::_prisma::read_filters::BytesFilter),
		Kind(super::_prisma::read_filters::StringFilter),
		Data(super::_prisma::read_filters::BytesFilter),
		NodeId(super::_prisma::read_filters::IntFilter),
		NodeIs(Vec<super::node::WhereParam>),
		NodeIsNot(Vec<super::node::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::Timestamp(value) => (timestamp::NAME, value.into()),
				Self::Model(value) => (model::NAME, value.into()),
				Self::RecordId(value) => (record_id::NAME, value.into()),
				Self::Kind(value) => (kind::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::NodeIs(where_params) => (
					node::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::NodeIsNot(where_params) => (
					node::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		Timestamp(super::SortOrder),
		Model(super::SortOrder),
		RecordId(super::SortOrder),
		Kind(super::SortOrder),
		Data(super::SortOrder),
		NodeId(super::SortOrder),
		Node(Vec<super::node::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::Timestamp(param) => ("timestamp", param.into()),
				Self::Model(param) => ("model", param.into()),
				Self::RecordId(param) => ("record_id", param.into()),
				Self::Kind(param) => ("kind", param.into()),
				Self::Data(param) => ("data", param.into()),
				Self::NodeId(param) => ("node_id", param.into()),
				Self::Node(param) => (
					"node",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Node(super::node::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Node(args) => {
					let mut selections =
						<super::node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(node::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::BytesParam),
		Timestamp(super::_prisma::write_params::BigIntParam),
		Model(super::_prisma::write_params::StringParam),
		RecordId(super::_prisma::write_params::BytesParam),
		Kind(super::_prisma::write_params::StringParam),
		Data(super::_prisma::write_params::BytesParam),
		NodeId(super::_prisma::write_params::IntParam),
		ConnectNode(super::node::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::Timestamp(value) => (timestamp::NAME, value.into()),
				Self::Model(value) => (model::NAME, value.into()),
				Self::RecordId(value) => (record_id::NAME, value.into()),
				Self::Kind(value) => (kind::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::ConnectNode(where_param) => (
					node::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::node::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::BytesParam),
		Timestamp(super::_prisma::write_params::BigIntParam),
		Model(super::_prisma::write_params::StringParam),
		RecordId(super::_prisma::write_params::BytesParam),
		Kind(super::_prisma::write_params::StringParam),
		Data(super::_prisma::write_params::BytesParam),
		NodeId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::Timestamp(value) => ("timestamp", value.into()),
				Self::Model(value) => ("model", value.into()),
				Self::RecordId(value) => ("record_id", value.into()),
				Self::Kind(value) => ("kind", value.into()),
				Self::Data(value) => ("data", value.into()),
				Self::NodeId(value) => ("node_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_shared_operation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: shared_operation :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: shared_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: shared_operation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: shared_operation :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: shared_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: shared_operation :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , timestamp , model , record_id , kind , data , node_id , node } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: shared_operation :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: shared_operation :: $ field :: NAME)] pub $ field : crate :: prisma :: shared_operation :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: shared_operation :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: shared_operation :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: shared_operation :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shared_operation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shared_operation :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "timestamp" , "model" , "record_id" , "kind" , "data" , "node_id" , "node"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: shared_operation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { Vec < u8 > } ; (@ field_type ; timestamp) => { i64 } ; (@ field_type ; model) => { String } ; (@ field_type ; record_id) => { Vec < u8 > } ; (@ field_type ; kind) => { String } ; (@ field_type ; data) => { Vec < u8 > } ; (@ field_type ; node_id) => { i32 } ; (@ field_type ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { node :: Data } ; (@ field_type ; node) => { crate :: prisma :: node :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SharedOperation" , available relations are "id, timestamp, model, record_id, kind, data, node_id, node")) } ; (@ field_module ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: node :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: shared_operation :: SelectParam > :: into (crate :: prisma :: shared_operation :: id :: Select) } ; (@ selection_field_to_selection_param ; timestamp) => { Into :: < crate :: prisma :: shared_operation :: SelectParam > :: into (crate :: prisma :: shared_operation :: timestamp :: Select) } ; (@ selection_field_to_selection_param ; model) => { Into :: < crate :: prisma :: shared_operation :: SelectParam > :: into (crate :: prisma :: shared_operation :: model :: Select) } ; (@ selection_field_to_selection_param ; record_id) => { Into :: < crate :: prisma :: shared_operation :: SelectParam > :: into (crate :: prisma :: shared_operation :: record_id :: Select) } ; (@ selection_field_to_selection_param ; kind) => { Into :: < crate :: prisma :: shared_operation :: SelectParam > :: into (crate :: prisma :: shared_operation :: kind :: Select) } ; (@ selection_field_to_selection_param ; data) => { Into :: < crate :: prisma :: shared_operation :: SelectParam > :: into (crate :: prisma :: shared_operation :: data :: Select) } ; (@ selection_field_to_selection_param ; node_id) => { Into :: < crate :: prisma :: shared_operation :: SelectParam > :: into (crate :: prisma :: shared_operation :: node_id :: Select) } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: shared_operation :: SelectParam > :: into (crate :: prisma :: shared_operation :: node :: Select :: $ selection_mode (crate :: prisma :: node :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: shared_operation :: SelectParam > :: into (crate :: prisma :: shared_operation :: node :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: shared_operation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; model) => { "model" } ; (@ field_serde_name ; record_id) => { "record_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; node) => { "node" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_shared_operation as select;
	pub enum SelectParam {
		Id(id::Select),
		Timestamp(timestamp::Select),
		Model(model::Select),
		RecordId(record_id::Select),
		Kind(kind::Select),
		Data(data::Select),
		NodeId(node_id::Select),
		Node(node::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Timestamp(data) => data.to_selection(),
				Self::Model(data) => data.to_selection(),
				Self::RecordId(data) => data.to_selection(),
				Self::Kind(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Node(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_shared_operation { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: shared_operation :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: shared_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: shared_operation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: shared_operation :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: shared_operation :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: shared_operation :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { node } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: shared_operation :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: shared_operation :: id :: NAME)] pub id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: shared_operation :: timestamp :: NAME)] pub timestamp : i64 , # [specta (rename_from_path = crate :: prisma :: shared_operation :: model :: NAME)] pub model : String , # [specta (rename_from_path = crate :: prisma :: shared_operation :: record_id :: NAME)] pub record_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: shared_operation :: kind :: NAME)] pub kind : String , # [specta (rename_from_path = crate :: prisma :: shared_operation :: data :: NAME)] pub data : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: shared_operation :: node_id :: NAME)] pub node_id : i32 , $ (# [specta (rename_from_path = crate :: prisma :: shared_operation :: $ field :: NAME)] pub $ field : crate :: prisma :: shared_operation :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (timestamp) , stringify ! (model) , stringify ! (record_id) , stringify ! (kind) , stringify ! (data) , stringify ! (node_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: shared_operation :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: shared_operation :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: shared_operation :: timestamp :: NAME , & self . timestamp) ? ; state . serialize_field (crate :: prisma :: shared_operation :: model :: NAME , & self . model) ? ; state . serialize_field (crate :: prisma :: shared_operation :: record_id :: NAME , & self . record_id) ? ; state . serialize_field (crate :: prisma :: shared_operation :: kind :: NAME , & self . kind) ? ; state . serialize_field (crate :: prisma :: shared_operation :: data :: NAME , & self . data) ? ; state . serialize_field (crate :: prisma :: shared_operation :: node_id :: NAME , & self . node_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , timestamp , model , record_id , kind , data , node_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: shared_operation :: $ field :: NAME) , + , crate :: prisma :: shared_operation :: id :: NAME , crate :: prisma :: shared_operation :: timestamp :: NAME , crate :: prisma :: shared_operation :: model :: NAME , crate :: prisma :: shared_operation :: record_id :: NAME , crate :: prisma :: shared_operation :: kind :: NAME , crate :: prisma :: shared_operation :: data :: NAME , crate :: prisma :: shared_operation :: node_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: shared_operation :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: shared_operation :: id :: NAME => Ok (Field :: id) , crate :: prisma :: shared_operation :: timestamp :: NAME => Ok (Field :: timestamp) , crate :: prisma :: shared_operation :: model :: NAME => Ok (Field :: model) , crate :: prisma :: shared_operation :: record_id :: NAME => Ok (Field :: record_id) , crate :: prisma :: shared_operation :: kind :: NAME => Ok (Field :: kind) , crate :: prisma :: shared_operation :: data :: NAME => Ok (Field :: data) , crate :: prisma :: shared_operation :: node_id :: NAME => Ok (Field :: node_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut timestamp = None ; let mut model = None ; let mut record_id = None ; let mut kind = None ; let mut data = None ; let mut node_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shared_operation :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: timestamp => { if timestamp . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shared_operation :: timestamp :: NAME)) ; } timestamp = Some (map . next_value () ?) ; } Field :: model => { if model . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shared_operation :: model :: NAME)) ; } model = Some (map . next_value () ?) ; } Field :: record_id => { if record_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shared_operation :: record_id :: NAME)) ; } record_id = Some (map . next_value () ?) ; } Field :: kind => { if kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shared_operation :: kind :: NAME)) ; } kind = Some (map . next_value () ?) ; } Field :: data => { if data . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shared_operation :: data :: NAME)) ; } data = Some (map . next_value () ?) ; } Field :: node_id => { if node_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shared_operation :: node_id :: NAME)) ; } node_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: shared_operation :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shared_operation :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shared_operation :: id :: NAME)) ? ; let timestamp = timestamp . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shared_operation :: timestamp :: NAME)) ? ; let model = model . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shared_operation :: model :: NAME)) ? ; let record_id = record_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shared_operation :: record_id :: NAME)) ? ; let kind = kind . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shared_operation :: kind :: NAME)) ? ; let data = data . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shared_operation :: data :: NAME)) ? ; let node_id = node_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: shared_operation :: node_id :: NAME)) ? ; Ok (Data { id , timestamp , model , record_id , kind , data , node_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "timestamp" , "model" , "record_id" , "kind" , "data" , "node_id" , "node"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: shared_operation :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { node :: Data } ; (@ field_type ; node) => { crate :: prisma :: node :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SharedOperation" , available relations are "node")) } ; (@ field_module ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: node :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: shared_operation :: IncludeParam > :: into (crate :: prisma :: shared_operation :: node :: Include :: $ selection_mode (crate :: prisma :: node :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: shared_operation :: IncludeParam > :: into (crate :: prisma :: shared_operation :: node :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: shared_operation :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; timestamp) => { "timestamp" } ; (@ field_serde_name ; model) => { "model" } ; (@ field_serde_name ; record_id) => { "record_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; node) => { "node" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_shared_operation as include;
	pub enum IncludeParam {
		Id(id::Include),
		Timestamp(timestamp::Include),
		Model(model::Include),
		RecordId(record_id::Include),
		Kind(kind::Include),
		Data(data::Include),
		NodeId(node_id::Include),
		Node(node::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Timestamp(data) => data.to_selection(),
				Self::Model(data) => data.to_selection(),
				Self::RecordId(data) => data.to_selection(),
				Self::Kind(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Node(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod data {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "data";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::Data(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Data, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Data(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Data(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Data(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Id, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod kind {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "kind";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Kind(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Kind, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Kind(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Kind(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Kind(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Kind(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Kind(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Kind(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Kind(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod model {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "model";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Model(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			Model,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Model(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Model(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Model(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Model(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Model(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Model(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Model(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod node {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node";
		pub fn is(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIs(value)
		}
		pub fn is_not(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIsNot(value)
		}
		pub struct Order(Vec<node::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<node::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Node(v)
			}
		}
		pub struct Fetch(pub node::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<node::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Node(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(node::UniqueArgs::new())
		}
		pub struct Connect(node::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectNode(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: node::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<node::SelectParam>),
			Include(Vec<node::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Node(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("node", None, [], selections)
			}
			pub fn select(nested_selections: Vec<node::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<node::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<node::SelectParam>),
			Include(Vec<node::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Node(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("node", None, [], selections)
			}
			pub fn select(nested_selections: Vec<node::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<node::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod node_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodeId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, NodeId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NodeId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NodeId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod record_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "record_id";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::RecordId(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			RecordId,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::RecordId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RecordId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::RecordId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::RecordId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RecordId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::RecordId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::RecordId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod timestamp {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "timestamp";
		pub fn equals(value: i64) -> WhereParam {
			WhereParam::Timestamp(_prisma::read_filters::BigIntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BigIntFilter,
			Timestamp,
			{
				fn in_vec(_: Vec<i64>) -> InVec;
				fn not_in_vec(_: Vec<i64>) -> NotInVec;
				fn lt(_: i64) -> Lt;
				fn lte(_: i64) -> Lte;
				fn gt(_: i64) -> Gt;
				fn gte(_: i64) -> Gte;
				fn not(_: i64) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Timestamp(v)
			}
		}
		pub struct Set(pub i64);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Timestamp(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Timestamp(_prisma::write_params::BigIntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i64) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BigIntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i64) -> T {
			UpdateOperation(_prisma::write_params::BigIntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Timestamp(_prisma::write_params::BigIntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Timestamp(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Timestamp(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Timestamp(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub id: Vec<u8>,
		pub timestamp: i64,
		pub model: String,
		pub record_id: Vec<u8>,
		pub kind: String,
		pub data: Vec<u8>,
		pub node: super::node::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.shared_operation().create(
				self.id,
				self.timestamp,
				self.model,
				self.record_id,
				self.kind,
				self.data,
				self.node,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				id::set(self.id),
				timestamp::set(self.timestamp),
				model::set(self.model),
				record_id::set(self.record_id),
				kind::set(self.kind),
				data::set(self.data),
				node::connect(self.node),
			]);
			self._params
		}
	}
	pub fn create(
		id: Vec<u8>,
		timestamp: i64,
		model: String,
		record_id: Vec<u8>,
		kind: String,
		data: Vec<u8>,
		node: super::node::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			id,
			timestamp,
			model,
			record_id,
			kind,
			data,
			node,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub id: Vec<u8>,
		pub timestamp: i64,
		pub model: String,
		pub record_id: Vec<u8>,
		pub kind: String,
		pub data: Vec<u8>,
		pub node_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.shared_operation().create_unchecked(
				self.id,
				self.timestamp,
				self.model,
				self.record_id,
				self.kind,
				self.data,
				self.node_id,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				id::set(self.id),
				timestamp::set(self.timestamp),
				model::set(self.model),
				record_id::set(self.record_id),
				kind::set(self.kind),
				data::set(self.data),
				node_id::set(self.node_id),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		id: Vec<u8>,
		timestamp: i64,
		model: String,
		record_id: Vec<u8>,
		kind: String,
		data: Vec<u8>,
		node_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			id,
			timestamp,
			model,
			record_id,
			kind,
			data,
			node_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(timestamp::NAME),
				::prisma_client_rust::sel(model::NAME),
				::prisma_client_rust::sel(record_id::NAME),
				::prisma_client_rust::sel(kind::NAME),
				::prisma_client_rust::sel(data::NAME),
				::prisma_client_rust::sel(node_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "SharedOperation", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: Vec<u8>,
		#[serde(rename = "timestamp")]
		pub timestamp: i64,
		#[serde(rename = "model")]
		pub model: String,
		#[serde(rename = "record_id")]
		pub record_id: Vec<u8>,
		#[serde(rename = "kind")]
		pub kind: String,
		#[serde(rename = "data")]
		pub data: Vec<u8>,
		#[serde(rename = "node_id")]
		pub node_id: i32,
		#[serde(rename = "node")]
		#[specta(skip)]
		pub node: Option<Box<super::node::Data>>,
	}
	impl Data {
		pub fn node(
			&self,
		) -> Result<&super::node::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.node
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(node),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_shared_operation { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: shared_operation struct $ struct_name { # [serde (rename = "id")] pub id : Vec < u8 > , # [serde (rename = "timestamp")] pub timestamp : i64 , # [serde (rename = "model")] pub model : String , # [serde (rename = "record_id")] pub record_id : Vec < u8 > , # [serde (rename = "kind")] pub kind : String , # [serde (rename = "data")] pub data : Vec < u8 > , # [serde (rename = "node_id")] pub node_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_shared_operation as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			id: Vec<u8>,
			timestamp: i64,
			model: String,
			record_id: Vec<u8>,
			kind: String,
			data: Vec<u8>,
			node: super::node::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				id::set(id),
				timestamp::set(timestamp),
				model::set(model),
				record_id::set(record_id),
				kind::set(kind),
				data::set(data),
				node::connect(node),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			id: Vec<u8>,
			timestamp: i64,
			model: String,
			record_id: Vec<u8>,
			kind: String,
			data: Vec<u8>,
			node_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				id::set(id),
				timestamp::set(timestamp),
				model::set(model),
				record_id::set(record_id),
				kind::set(kind),
				data::set(data),
				node_id::set(node_id),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod statistics {
	use super::_prisma::*;
	pub const NAME: &str = "Statistics";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		DateCaptured(super::_prisma::read_filters::DateTimeFilter),
		TotalObjectCount(super::_prisma::read_filters::IntFilter),
		LibraryDbSize(super::_prisma::read_filters::StringFilter),
		TotalBytesUsed(super::_prisma::read_filters::StringFilter),
		TotalBytesCapacity(super::_prisma::read_filters::StringFilter),
		TotalUniqueBytes(super::_prisma::read_filters::StringFilter),
		TotalBytesFree(super::_prisma::read_filters::StringFilter),
		PreviewMediaBytes(super::_prisma::read_filters::StringFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::DateCaptured(value) => (date_captured::NAME, value.into()),
				Self::TotalObjectCount(value) => (total_object_count::NAME, value.into()),
				Self::LibraryDbSize(value) => (library_db_size::NAME, value.into()),
				Self::TotalBytesUsed(value) => (total_bytes_used::NAME, value.into()),
				Self::TotalBytesCapacity(value) => (total_bytes_capacity::NAME, value.into()),
				Self::TotalUniqueBytes(value) => (total_unique_bytes::NAME, value.into()),
				Self::TotalBytesFree(value) => (total_bytes_free::NAME, value.into()),
				Self::PreviewMediaBytes(value) => (preview_media_bytes::NAME, value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		DateCaptured(super::SortOrder),
		TotalObjectCount(super::SortOrder),
		LibraryDbSize(super::SortOrder),
		TotalBytesUsed(super::SortOrder),
		TotalBytesCapacity(super::SortOrder),
		TotalUniqueBytes(super::SortOrder),
		TotalBytesFree(super::SortOrder),
		PreviewMediaBytes(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::DateCaptured(param) => ("date_captured", param.into()),
				Self::TotalObjectCount(param) => ("total_object_count", param.into()),
				Self::LibraryDbSize(param) => ("library_db_size", param.into()),
				Self::TotalBytesUsed(param) => ("total_bytes_used", param.into()),
				Self::TotalBytesCapacity(param) => ("total_bytes_capacity", param.into()),
				Self::TotalUniqueBytes(param) => ("total_unique_bytes", param.into()),
				Self::TotalBytesFree(param) => ("total_bytes_free", param.into()),
				Self::PreviewMediaBytes(param) => ("preview_media_bytes", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		DateCaptured(super::_prisma::write_params::DateTimeParam),
		TotalObjectCount(super::_prisma::write_params::IntParam),
		LibraryDbSize(super::_prisma::write_params::StringParam),
		TotalBytesUsed(super::_prisma::write_params::StringParam),
		TotalBytesCapacity(super::_prisma::write_params::StringParam),
		TotalUniqueBytes(super::_prisma::write_params::StringParam),
		TotalBytesFree(super::_prisma::write_params::StringParam),
		PreviewMediaBytes(super::_prisma::write_params::StringParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::DateCaptured(value) => (date_captured::NAME, value.into()),
				Self::TotalObjectCount(value) => (total_object_count::NAME, value.into()),
				Self::LibraryDbSize(value) => (library_db_size::NAME, value.into()),
				Self::TotalBytesUsed(value) => (total_bytes_used::NAME, value.into()),
				Self::TotalBytesCapacity(value) => (total_bytes_capacity::NAME, value.into()),
				Self::TotalUniqueBytes(value) => (total_unique_bytes::NAME, value.into()),
				Self::TotalBytesFree(value) => (total_bytes_free::NAME, value.into()),
				Self::PreviewMediaBytes(value) => (preview_media_bytes::NAME, value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		DateCaptured(super::_prisma::write_params::DateTimeParam),
		TotalObjectCount(super::_prisma::write_params::IntParam),
		LibraryDbSize(super::_prisma::write_params::StringParam),
		TotalBytesUsed(super::_prisma::write_params::StringParam),
		TotalBytesCapacity(super::_prisma::write_params::StringParam),
		TotalUniqueBytes(super::_prisma::write_params::StringParam),
		TotalBytesFree(super::_prisma::write_params::StringParam),
		PreviewMediaBytes(super::_prisma::write_params::StringParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::DateCaptured(value) => ("date_captured", value.into()),
				Self::TotalObjectCount(value) => ("total_object_count", value.into()),
				Self::LibraryDbSize(value) => ("library_db_size", value.into()),
				Self::TotalBytesUsed(value) => ("total_bytes_used", value.into()),
				Self::TotalBytesCapacity(value) => ("total_bytes_capacity", value.into()),
				Self::TotalUniqueBytes(value) => ("total_unique_bytes", value.into()),
				Self::TotalBytesFree(value) => ("total_bytes_free", value.into()),
				Self::PreviewMediaBytes(value) => ("preview_media_bytes", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_statistics { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: statistics :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: statistics :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: statistics :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: statistics :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: statistics :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: statistics :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , date_captured , total_object_count , library_db_size , total_bytes_used , total_bytes_capacity , total_unique_bytes , total_bytes_free , preview_media_bytes } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: statistics :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: statistics :: $ field :: NAME)] pub $ field : crate :: prisma :: statistics :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: statistics :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: statistics :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: statistics :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "date_captured" , "total_object_count" , "library_db_size" , "total_bytes_used" , "total_bytes_capacity" , "total_unique_bytes" , "total_bytes_free" , "preview_media_bytes"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: statistics :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; date_captured) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; total_object_count) => { i32 } ; (@ field_type ; library_db_size) => { String } ; (@ field_type ; total_bytes_used) => { String } ; (@ field_type ; total_bytes_capacity) => { String } ; (@ field_type ; total_unique_bytes) => { String } ; (@ field_type ; total_bytes_free) => { String } ; (@ field_type ; preview_media_bytes) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Statistics" , available relations are "id, date_captured, total_object_count, library_db_size, total_bytes_used, total_bytes_capacity, total_unique_bytes, total_bytes_free, preview_media_bytes")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: statistics :: SelectParam > :: into (crate :: prisma :: statistics :: id :: Select) } ; (@ selection_field_to_selection_param ; date_captured) => { Into :: < crate :: prisma :: statistics :: SelectParam > :: into (crate :: prisma :: statistics :: date_captured :: Select) } ; (@ selection_field_to_selection_param ; total_object_count) => { Into :: < crate :: prisma :: statistics :: SelectParam > :: into (crate :: prisma :: statistics :: total_object_count :: Select) } ; (@ selection_field_to_selection_param ; library_db_size) => { Into :: < crate :: prisma :: statistics :: SelectParam > :: into (crate :: prisma :: statistics :: library_db_size :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_used) => { Into :: < crate :: prisma :: statistics :: SelectParam > :: into (crate :: prisma :: statistics :: total_bytes_used :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_capacity) => { Into :: < crate :: prisma :: statistics :: SelectParam > :: into (crate :: prisma :: statistics :: total_bytes_capacity :: Select) } ; (@ selection_field_to_selection_param ; total_unique_bytes) => { Into :: < crate :: prisma :: statistics :: SelectParam > :: into (crate :: prisma :: statistics :: total_unique_bytes :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_free) => { Into :: < crate :: prisma :: statistics :: SelectParam > :: into (crate :: prisma :: statistics :: total_bytes_free :: Select) } ; (@ selection_field_to_selection_param ; preview_media_bytes) => { Into :: < crate :: prisma :: statistics :: SelectParam > :: into (crate :: prisma :: statistics :: preview_media_bytes :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: statistics :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; date_captured) => { "date_captured" } ; (@ field_serde_name ; total_object_count) => { "total_object_count" } ; (@ field_serde_name ; library_db_size) => { "library_db_size" } ; (@ field_serde_name ; total_bytes_used) => { "total_bytes_used" } ; (@ field_serde_name ; total_bytes_capacity) => { "total_bytes_capacity" } ; (@ field_serde_name ; total_unique_bytes) => { "total_unique_bytes" } ; (@ field_serde_name ; total_bytes_free) => { "total_bytes_free" } ; (@ field_serde_name ; preview_media_bytes) => { "preview_media_bytes" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_statistics as select;
	pub enum SelectParam {
		Id(id::Select),
		DateCaptured(date_captured::Select),
		TotalObjectCount(total_object_count::Select),
		LibraryDbSize(library_db_size::Select),
		TotalBytesUsed(total_bytes_used::Select),
		TotalBytesCapacity(total_bytes_capacity::Select),
		TotalUniqueBytes(total_unique_bytes::Select),
		TotalBytesFree(total_bytes_free::Select),
		PreviewMediaBytes(preview_media_bytes::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::DateCaptured(data) => data.to_selection(),
				Self::TotalObjectCount(data) => data.to_selection(),
				Self::LibraryDbSize(data) => data.to_selection(),
				Self::TotalBytesUsed(data) => data.to_selection(),
				Self::TotalBytesCapacity(data) => data.to_selection(),
				Self::TotalUniqueBytes(data) => data.to_selection(),
				Self::TotalBytesFree(data) => data.to_selection(),
				Self::PreviewMediaBytes(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_statistics { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: statistics :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: statistics :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: statistics :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: statistics :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: statistics :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: statistics :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: statistics :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: statistics :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: statistics :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: statistics :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: statistics :: date_captured :: NAME)] pub date_captured : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: statistics :: total_object_count :: NAME)] pub total_object_count : i32 , # [specta (rename_from_path = crate :: prisma :: statistics :: library_db_size :: NAME)] pub library_db_size : String , # [specta (rename_from_path = crate :: prisma :: statistics :: total_bytes_used :: NAME)] pub total_bytes_used : String , # [specta (rename_from_path = crate :: prisma :: statistics :: total_bytes_capacity :: NAME)] pub total_bytes_capacity : String , # [specta (rename_from_path = crate :: prisma :: statistics :: total_unique_bytes :: NAME)] pub total_unique_bytes : String , # [specta (rename_from_path = crate :: prisma :: statistics :: total_bytes_free :: NAME)] pub total_bytes_free : String , # [specta (rename_from_path = crate :: prisma :: statistics :: preview_media_bytes :: NAME)] pub preview_media_bytes : String , $ (# [specta (rename_from_path = crate :: prisma :: statistics :: $ field :: NAME)] pub $ field : crate :: prisma :: statistics :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (date_captured) , stringify ! (total_object_count) , stringify ! (library_db_size) , stringify ! (total_bytes_used) , stringify ! (total_bytes_capacity) , stringify ! (total_unique_bytes) , stringify ! (total_bytes_free) , stringify ! (preview_media_bytes)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: statistics :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: statistics :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: statistics :: date_captured :: NAME , & self . date_captured) ? ; state . serialize_field (crate :: prisma :: statistics :: total_object_count :: NAME , & self . total_object_count) ? ; state . serialize_field (crate :: prisma :: statistics :: library_db_size :: NAME , & self . library_db_size) ? ; state . serialize_field (crate :: prisma :: statistics :: total_bytes_used :: NAME , & self . total_bytes_used) ? ; state . serialize_field (crate :: prisma :: statistics :: total_bytes_capacity :: NAME , & self . total_bytes_capacity) ? ; state . serialize_field (crate :: prisma :: statistics :: total_unique_bytes :: NAME , & self . total_unique_bytes) ? ; state . serialize_field (crate :: prisma :: statistics :: total_bytes_free :: NAME , & self . total_bytes_free) ? ; state . serialize_field (crate :: prisma :: statistics :: preview_media_bytes :: NAME , & self . preview_media_bytes) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , date_captured , total_object_count , library_db_size , total_bytes_used , total_bytes_capacity , total_unique_bytes , total_bytes_free , preview_media_bytes } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: statistics :: $ field :: NAME) , + , crate :: prisma :: statistics :: id :: NAME , crate :: prisma :: statistics :: date_captured :: NAME , crate :: prisma :: statistics :: total_object_count :: NAME , crate :: prisma :: statistics :: library_db_size :: NAME , crate :: prisma :: statistics :: total_bytes_used :: NAME , crate :: prisma :: statistics :: total_bytes_capacity :: NAME , crate :: prisma :: statistics :: total_unique_bytes :: NAME , crate :: prisma :: statistics :: total_bytes_free :: NAME , crate :: prisma :: statistics :: preview_media_bytes :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: statistics :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: statistics :: id :: NAME => Ok (Field :: id) , crate :: prisma :: statistics :: date_captured :: NAME => Ok (Field :: date_captured) , crate :: prisma :: statistics :: total_object_count :: NAME => Ok (Field :: total_object_count) , crate :: prisma :: statistics :: library_db_size :: NAME => Ok (Field :: library_db_size) , crate :: prisma :: statistics :: total_bytes_used :: NAME => Ok (Field :: total_bytes_used) , crate :: prisma :: statistics :: total_bytes_capacity :: NAME => Ok (Field :: total_bytes_capacity) , crate :: prisma :: statistics :: total_unique_bytes :: NAME => Ok (Field :: total_unique_bytes) , crate :: prisma :: statistics :: total_bytes_free :: NAME => Ok (Field :: total_bytes_free) , crate :: prisma :: statistics :: preview_media_bytes :: NAME => Ok (Field :: preview_media_bytes) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut date_captured = None ; let mut total_object_count = None ; let mut library_db_size = None ; let mut total_bytes_used = None ; let mut total_bytes_capacity = None ; let mut total_unique_bytes = None ; let mut total_bytes_free = None ; let mut preview_media_bytes = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: date_captured => { if date_captured . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: date_captured :: NAME)) ; } date_captured = Some (map . next_value () ?) ; } Field :: total_object_count => { if total_object_count . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: total_object_count :: NAME)) ; } total_object_count = Some (map . next_value () ?) ; } Field :: library_db_size => { if library_db_size . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: library_db_size :: NAME)) ; } library_db_size = Some (map . next_value () ?) ; } Field :: total_bytes_used => { if total_bytes_used . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: total_bytes_used :: NAME)) ; } total_bytes_used = Some (map . next_value () ?) ; } Field :: total_bytes_capacity => { if total_bytes_capacity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: total_bytes_capacity :: NAME)) ; } total_bytes_capacity = Some (map . next_value () ?) ; } Field :: total_unique_bytes => { if total_unique_bytes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: total_unique_bytes :: NAME)) ; } total_unique_bytes = Some (map . next_value () ?) ; } Field :: total_bytes_free => { if total_bytes_free . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: total_bytes_free :: NAME)) ; } total_bytes_free = Some (map . next_value () ?) ; } Field :: preview_media_bytes => { if preview_media_bytes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: preview_media_bytes :: NAME)) ; } preview_media_bytes = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: statistics :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: id :: NAME)) ? ; let date_captured = date_captured . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: date_captured :: NAME)) ? ; let total_object_count = total_object_count . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: total_object_count :: NAME)) ? ; let library_db_size = library_db_size . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: library_db_size :: NAME)) ? ; let total_bytes_used = total_bytes_used . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: total_bytes_used :: NAME)) ? ; let total_bytes_capacity = total_bytes_capacity . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: total_bytes_capacity :: NAME)) ? ; let total_unique_bytes = total_unique_bytes . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: total_unique_bytes :: NAME)) ? ; let total_bytes_free = total_bytes_free . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: total_bytes_free :: NAME)) ? ; let preview_media_bytes = preview_media_bytes . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: statistics :: preview_media_bytes :: NAME)) ? ; Ok (Data { id , date_captured , total_object_count , library_db_size , total_bytes_used , total_bytes_capacity , total_unique_bytes , total_bytes_free , preview_media_bytes , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "date_captured" , "total_object_count" , "library_db_size" , "total_bytes_used" , "total_bytes_capacity" , "total_unique_bytes" , "total_bytes_free" , "preview_media_bytes"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: statistics :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Statistics" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: statistics :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; date_captured) => { "date_captured" } ; (@ field_serde_name ; total_object_count) => { "total_object_count" } ; (@ field_serde_name ; library_db_size) => { "library_db_size" } ; (@ field_serde_name ; total_bytes_used) => { "total_bytes_used" } ; (@ field_serde_name ; total_bytes_capacity) => { "total_bytes_capacity" } ; (@ field_serde_name ; total_unique_bytes) => { "total_unique_bytes" } ; (@ field_serde_name ; total_bytes_free) => { "total_bytes_free" } ; (@ field_serde_name ; preview_media_bytes) => { "preview_media_bytes" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_statistics as include;
	pub enum IncludeParam {
		Id(id::Include),
		DateCaptured(date_captured::Include),
		TotalObjectCount(total_object_count::Include),
		LibraryDbSize(library_db_size::Include),
		TotalBytesUsed(total_bytes_used::Include),
		TotalBytesCapacity(total_bytes_capacity::Include),
		TotalUniqueBytes(total_unique_bytes::Include),
		TotalBytesFree(total_bytes_free::Include),
		PreviewMediaBytes(preview_media_bytes::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::DateCaptured(data) => data.to_selection(),
				Self::TotalObjectCount(data) => data.to_selection(),
				Self::LibraryDbSize(data) => data.to_selection(),
				Self::TotalBytesUsed(data) => data.to_selection(),
				Self::TotalBytesCapacity(data) => data.to_selection(),
				Self::TotalUniqueBytes(data) => data.to_selection(),
				Self::TotalBytesFree(data) => data.to_selection(),
				Self::PreviewMediaBytes(data) => data.to_selection(),
			}
		}
	}
	pub mod date_captured {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_captured";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCaptured(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCaptured,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCaptured(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCaptured(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCaptured(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCaptured(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCaptured(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCaptured(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCaptured(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod library_db_size {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "library_db_size";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::LibraryDbSize(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			LibraryDbSize,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LibraryDbSize(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LibraryDbSize(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::LibraryDbSize(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LibraryDbSize(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LibraryDbSize(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LibraryDbSize(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LibraryDbSize(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod preview_media_bytes {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "preview_media_bytes";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::PreviewMediaBytes(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			PreviewMediaBytes,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PreviewMediaBytes(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PreviewMediaBytes(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PreviewMediaBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PreviewMediaBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PreviewMediaBytes(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PreviewMediaBytes(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PreviewMediaBytes(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_capacity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_capacity";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesCapacity(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesCapacity,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesCapacity(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesCapacity(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesCapacity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesCapacity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_free {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_free";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesFree(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesFree,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesFree(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesFree(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesFree(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesFree(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesFree(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesFree(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesFree(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_used {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_used";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesUsed(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesUsed,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesUsed(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesUsed(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesUsed(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesUsed(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesUsed(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesUsed(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesUsed(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_object_count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_object_count";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::TotalObjectCount(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			TotalObjectCount,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalObjectCount(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalObjectCount(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalObjectCount(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalObjectCount(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalObjectCount(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalObjectCount(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalObjectCount(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_unique_bytes {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_unique_bytes";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalUniqueBytes(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalUniqueBytes,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalUniqueBytes(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalUniqueBytes(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalUniqueBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalUniqueBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalUniqueBytes(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalUniqueBytes(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalUniqueBytes(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.statistics().create(self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([]);
			self._params
		}
	}
	pub fn create(_params: Vec<SetParam>) -> Create {
		Create { _params }
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.statistics().create_unchecked(self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([]);
			self._params
		}
	}
	pub fn create_unchecked(_params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { _params }
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(date_captured::NAME),
				::prisma_client_rust::sel(total_object_count::NAME),
				::prisma_client_rust::sel(library_db_size::NAME),
				::prisma_client_rust::sel(total_bytes_used::NAME),
				::prisma_client_rust::sel(total_bytes_capacity::NAME),
				::prisma_client_rust::sel(total_unique_bytes::NAME),
				::prisma_client_rust::sel(total_bytes_free::NAME),
				::prisma_client_rust::sel(preview_media_bytes::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Statistics", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "date_captured")]
		pub date_captured:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "total_object_count")]
		pub total_object_count: i32,
		#[serde(rename = "library_db_size")]
		pub library_db_size: String,
		#[serde(rename = "total_bytes_used")]
		pub total_bytes_used: String,
		#[serde(rename = "total_bytes_capacity")]
		pub total_bytes_capacity: String,
		#[serde(rename = "total_unique_bytes")]
		pub total_unique_bytes: String,
		#[serde(rename = "total_bytes_free")]
		pub total_bytes_free: String,
		#[serde(rename = "preview_media_bytes")]
		pub preview_media_bytes: String,
	}
	impl Data {}
	#[macro_export]
	macro_rules ! _partial_unchecked_statistics { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: statistics struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "date_captured")] pub date_captured : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "total_object_count")] pub total_object_count : i32 , # [serde (rename = "library_db_size")] pub library_db_size : String , # [serde (rename = "total_bytes_used")] pub total_bytes_used : String , # [serde (rename = "total_bytes_capacity")] pub total_bytes_capacity : String , # [serde (rename = "total_unique_bytes")] pub total_unique_bytes : String , # [serde (rename = "total_bytes_free")] pub total_bytes_free : String , # [serde (rename = "preview_media_bytes")] pub preview_media_bytes : String } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_statistics as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod node {
	use super::_prisma::*;
	pub const NAME: &str = "Node";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringFilter),
		Platform(super::_prisma::read_filters::IntFilter),
		Version(super::_prisma::read_filters::StringNullableFilter),
		LastSeen(super::_prisma::read_filters::DateTimeFilter),
		Timezone(super::_prisma::read_filters::StringNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		JobsSome(Vec<super::job::WhereParam>),
		JobsEvery(Vec<super::job::WhereParam>),
		JobsNone(Vec<super::job::WhereParam>),
		LocationSome(Vec<super::location::WhereParam>),
		LocationEvery(Vec<super::location::WhereParam>),
		LocationNone(Vec<super::location::WhereParam>),
		OwnedOperationSome(Vec<super::owned_operation::WhereParam>),
		OwnedOperationEvery(Vec<super::owned_operation::WhereParam>),
		OwnedOperationNone(Vec<super::owned_operation::WhereParam>),
		SharedOperationSome(Vec<super::shared_operation::WhereParam>),
		SharedOperationEvery(Vec<super::shared_operation::WhereParam>),
		SharedOperationNone(Vec<super::shared_operation::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Platform(value) => (platform::NAME, value.into()),
				Self::Version(value) => (version::NAME, value.into()),
				Self::LastSeen(value) => (last_seen::NAME, value.into()),
				Self::Timezone(value) => (timezone::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::JobsSome(where_params) => (
					jobs::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::JobsEvery(where_params) => (
					jobs::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::JobsNone(where_params) => (
					jobs::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationSome(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationEvery(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationNone(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::OwnedOperationSome(where_params) => (
					owned_operation::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::OwnedOperationEvery(where_params) => (
					owned_operation::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::OwnedOperationNone(where_params) => (
					owned_operation::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SharedOperationSome(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SharedOperationEvery(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SharedOperationNone(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		Platform(super::SortOrder),
		Version(super::SortOrder),
		LastSeen(super::SortOrder),
		Timezone(super::SortOrder),
		DateCreated(super::SortOrder),
		Jobs(Vec<super::job::OrderByRelationAggregateParam>),
		Location(Vec<super::location::OrderByRelationAggregateParam>),
		OwnedOperation(Vec<super::owned_operation::OrderByRelationAggregateParam>),
		SharedOperation(Vec<super::shared_operation::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Platform(param) => ("platform", param.into()),
				Self::Version(param) => ("version", param.into()),
				Self::LastSeen(param) => ("last_seen", param.into()),
				Self::Timezone(param) => ("timezone", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::Jobs(param) => (
					"jobs",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Location(param) => (
					"Location",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::OwnedOperation(param) => (
					"OwnedOperation",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::SharedOperation(param) => (
					"SharedOperation",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Jobs(super::job::ManyArgs),
		Location(super::location::ManyArgs),
		OwnedOperation(super::owned_operation::ManyArgs),
		SharedOperation(super::shared_operation::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Jobs(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(
						<super::job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						),
					);
					::prisma_client_rust::Selection::new(
						jobs::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::Location(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						location::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::OwnedOperation(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: owned_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						owned_operation::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::SharedOperation(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						shared_operation::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringParam),
		Platform(super::_prisma::write_params::IntParam),
		Version(super::_prisma::write_params::StringNullableParam),
		LastSeen(super::_prisma::write_params::DateTimeParam),
		Timezone(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		ConnectJobs(Vec<super::job::UniqueWhereParam>),
		DisconnectJobs(Vec<super::job::UniqueWhereParam>),
		SetJobs(Vec<super::job::UniqueWhereParam>),
		ConnectLocation(Vec<super::location::UniqueWhereParam>),
		DisconnectLocation(Vec<super::location::UniqueWhereParam>),
		SetLocation(Vec<super::location::UniqueWhereParam>),
		ConnectOwnedOperation(Vec<super::owned_operation::UniqueWhereParam>),
		DisconnectOwnedOperation(Vec<super::owned_operation::UniqueWhereParam>),
		SetOwnedOperation(Vec<super::owned_operation::UniqueWhereParam>),
		ConnectSharedOperation(Vec<super::shared_operation::UniqueWhereParam>),
		DisconnectSharedOperation(Vec<super::shared_operation::UniqueWhereParam>),
		SetSharedOperation(Vec<super::shared_operation::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Platform(value) => (platform::NAME, value.into()),
				Self::Version(value) => (version::NAME, value.into()),
				Self::LastSeen(value) => (last_seen::NAME, value.into()),
				Self::Timezone(value) => (timezone::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::ConnectJobs(where_params) => (
					jobs::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectJobs(where_params) => (
					jobs::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetJobs(where_params) => (
					jobs::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectLocation(where_params) => (
					location::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectLocation(where_params) => (
					location::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetLocation(where_params) => (
					location::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectOwnedOperation(where_params) => (
					owned_operation::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::owned_operation::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectOwnedOperation(where_params) => (
					owned_operation::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::owned_operation::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetOwnedOperation(where_params) => (
					owned_operation::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::owned_operation::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectSharedOperation(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::shared_operation::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectSharedOperation(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::shared_operation::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetSharedOperation(where_params) => (
					shared_operation::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::shared_operation::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringParam),
		Platform(super::_prisma::write_params::IntParam),
		Version(super::_prisma::write_params::StringNullableParam),
		LastSeen(super::_prisma::write_params::DateTimeParam),
		Timezone(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Platform(value) => ("platform", value.into()),
				Self::Version(value) => ("version", value.into()),
				Self::LastSeen(value) => ("last_seen", value.into()),
				Self::Timezone(value) => ("timezone", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_node { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: node :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: node :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: node :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: node :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: node :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: node :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , platform , version , last_seen , timezone , date_created , jobs , location , owned_operation , shared_operation } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: node :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: node :: $ field :: NAME)] pub $ field : crate :: prisma :: node :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: node :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: node :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: node :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "platform" , "version" , "last_seen" , "timezone" , "date_created" , "jobs" , "Location" , "OwnedOperation" , "SharedOperation"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: node :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pub_id) => { Vec < u8 > } ; (@ field_type ; name) => { String } ; (@ field_type ; platform) => { i32 } ; (@ field_type ; version) => { Option < String > } ; (@ field_type ; last_seen) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; timezone) => { Option < String > } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < jobs :: Data > } ; (@ field_type ; jobs) => { Vec < crate :: prisma :: job :: Data > } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < location :: Data > } ; (@ field_type ; location) => { Vec < crate :: prisma :: location :: Data > } ; (@ field_type ; owned_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < owned_operation :: Data > } ; (@ field_type ; owned_operation) => { Vec < crate :: prisma :: owned_operation :: Data > } ; (@ field_type ; shared_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < shared_operation :: Data > } ; (@ field_type ; shared_operation) => { Vec < crate :: prisma :: shared_operation :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Node" , available relations are "id, pub_id, name, platform, version, last_seen, timezone, date_created, jobs, location, owned_operation, shared_operation")) } ; (@ field_module ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: job :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; owned_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: owned_operation :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; shared_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: shared_operation :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: name :: Select) } ; (@ selection_field_to_selection_param ; platform) => { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: platform :: Select) } ; (@ selection_field_to_selection_param ; version) => { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: version :: Select) } ; (@ selection_field_to_selection_param ; last_seen) => { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: last_seen :: Select) } ; (@ selection_field_to_selection_param ; timezone) => { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: timezone :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: date_created :: Select) } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: jobs :: Select :: $ selection_mode (crate :: prisma :: job :: ManyArgs :: new (crate :: prisma :: job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: jobs :: Select :: Fetch (crate :: prisma :: job :: ManyArgs :: new (crate :: prisma :: job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: location :: Select :: $ selection_mode (crate :: prisma :: location :: ManyArgs :: new (crate :: prisma :: location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: location :: Select :: Fetch (crate :: prisma :: location :: ManyArgs :: new (crate :: prisma :: location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; owned_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: owned_operation :: Select :: $ selection_mode (crate :: prisma :: owned_operation :: ManyArgs :: new (crate :: prisma :: owned_operation :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: owned_operation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; owned_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: owned_operation :: Select :: Fetch (crate :: prisma :: owned_operation :: ManyArgs :: new (crate :: prisma :: owned_operation :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; shared_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: shared_operation :: Select :: $ selection_mode (crate :: prisma :: shared_operation :: ManyArgs :: new (crate :: prisma :: shared_operation :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: shared_operation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; shared_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: node :: SelectParam > :: into (crate :: prisma :: node :: shared_operation :: Select :: Fetch (crate :: prisma :: shared_operation :: ManyArgs :: new (crate :: prisma :: shared_operation :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: node :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; platform) => { "platform" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; last_seen) => { "last_seen" } ; (@ field_serde_name ; timezone) => { "timezone" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; jobs) => { "jobs" } ; (@ field_serde_name ; location) => { "Location" } ; (@ field_serde_name ; owned_operation) => { "OwnedOperation" } ; (@ field_serde_name ; shared_operation) => { "SharedOperation" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_node as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		Platform(platform::Select),
		Version(version::Select),
		LastSeen(last_seen::Select),
		Timezone(timezone::Select),
		DateCreated(date_created::Select),
		Jobs(jobs::Select),
		Location(location::Select),
		OwnedOperation(owned_operation::Select),
		SharedOperation(shared_operation::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Platform(data) => data.to_selection(),
				Self::Version(data) => data.to_selection(),
				Self::LastSeen(data) => data.to_selection(),
				Self::Timezone(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::Jobs(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::OwnedOperation(data) => data.to_selection(),
				Self::SharedOperation(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_node { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: node :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: node :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: node :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: node :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: node :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: node :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: node :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: node :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { jobs , location , owned_operation , shared_operation } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: node :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: node :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: node :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: node :: name :: NAME)] pub name : String , # [specta (rename_from_path = crate :: prisma :: node :: platform :: NAME)] pub platform : i32 , # [specta (rename_from_path = crate :: prisma :: node :: version :: NAME)] pub version : Option < String > , # [specta (rename_from_path = crate :: prisma :: node :: last_seen :: NAME)] pub last_seen : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: node :: timezone :: NAME)] pub timezone : Option < String > , # [specta (rename_from_path = crate :: prisma :: node :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: prisma :: node :: $ field :: NAME)] pub $ field : crate :: prisma :: node :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (platform) , stringify ! (version) , stringify ! (last_seen) , stringify ! (timezone) , stringify ! (date_created)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: node :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: node :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: node :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (crate :: prisma :: node :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: node :: platform :: NAME , & self . platform) ? ; state . serialize_field (crate :: prisma :: node :: version :: NAME , & self . version) ? ; state . serialize_field (crate :: prisma :: node :: last_seen :: NAME , & self . last_seen) ? ; state . serialize_field (crate :: prisma :: node :: timezone :: NAME , & self . timezone) ? ; state . serialize_field (crate :: prisma :: node :: date_created :: NAME , & self . date_created) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , platform , version , last_seen , timezone , date_created } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: node :: $ field :: NAME) , + , crate :: prisma :: node :: id :: NAME , crate :: prisma :: node :: pub_id :: NAME , crate :: prisma :: node :: name :: NAME , crate :: prisma :: node :: platform :: NAME , crate :: prisma :: node :: version :: NAME , crate :: prisma :: node :: last_seen :: NAME , crate :: prisma :: node :: timezone :: NAME , crate :: prisma :: node :: date_created :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: node :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: node :: id :: NAME => Ok (Field :: id) , crate :: prisma :: node :: pub_id :: NAME => Ok (Field :: pub_id) , crate :: prisma :: node :: name :: NAME => Ok (Field :: name) , crate :: prisma :: node :: platform :: NAME => Ok (Field :: platform) , crate :: prisma :: node :: version :: NAME => Ok (Field :: version) , crate :: prisma :: node :: last_seen :: NAME => Ok (Field :: last_seen) , crate :: prisma :: node :: timezone :: NAME => Ok (Field :: timezone) , crate :: prisma :: node :: date_created :: NAME => Ok (Field :: date_created) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut platform = None ; let mut version = None ; let mut last_seen = None ; let mut timezone = None ; let mut date_created = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: platform => { if platform . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: platform :: NAME)) ; } platform = Some (map . next_value () ?) ; } Field :: version => { if version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: version :: NAME)) ; } version = Some (map . next_value () ?) ; } Field :: last_seen => { if last_seen . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: last_seen :: NAME)) ; } last_seen = Some (map . next_value () ?) ; } Field :: timezone => { if timezone . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: timezone :: NAME)) ; } timezone = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: node :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: name :: NAME)) ? ; let platform = platform . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: platform :: NAME)) ? ; let version = version . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: version :: NAME)) ? ; let last_seen = last_seen . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: last_seen :: NAME)) ? ; let timezone = timezone . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: timezone :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: node :: date_created :: NAME)) ? ; Ok (Data { id , pub_id , name , platform , version , last_seen , timezone , date_created , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "platform" , "version" , "last_seen" , "timezone" , "date_created" , "jobs" , "Location" , "OwnedOperation" , "SharedOperation"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: node :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < jobs :: Data > } ; (@ field_type ; jobs) => { Vec < crate :: prisma :: job :: Data > } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < location :: Data > } ; (@ field_type ; location) => { Vec < crate :: prisma :: location :: Data > } ; (@ field_type ; owned_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < owned_operation :: Data > } ; (@ field_type ; owned_operation) => { Vec < crate :: prisma :: owned_operation :: Data > } ; (@ field_type ; shared_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < shared_operation :: Data > } ; (@ field_type ; shared_operation) => { Vec < crate :: prisma :: shared_operation :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Node" , available relations are "jobs, location, owned_operation, shared_operation")) } ; (@ field_module ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: job :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; owned_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: owned_operation :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; shared_operation : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: shared_operation :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: node :: IncludeParam > :: into (crate :: prisma :: node :: jobs :: Include :: $ selection_mode (crate :: prisma :: job :: ManyArgs :: new (crate :: prisma :: job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: node :: IncludeParam > :: into (crate :: prisma :: node :: jobs :: Include :: Fetch (crate :: prisma :: job :: ManyArgs :: new (crate :: prisma :: job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: node :: IncludeParam > :: into (crate :: prisma :: node :: location :: Include :: $ selection_mode (crate :: prisma :: location :: ManyArgs :: new (crate :: prisma :: location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: node :: IncludeParam > :: into (crate :: prisma :: node :: location :: Include :: Fetch (crate :: prisma :: location :: ManyArgs :: new (crate :: prisma :: location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; owned_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: node :: IncludeParam > :: into (crate :: prisma :: node :: owned_operation :: Include :: $ selection_mode (crate :: prisma :: owned_operation :: ManyArgs :: new (crate :: prisma :: owned_operation :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: owned_operation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; owned_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: node :: IncludeParam > :: into (crate :: prisma :: node :: owned_operation :: Include :: Fetch (crate :: prisma :: owned_operation :: ManyArgs :: new (crate :: prisma :: owned_operation :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; shared_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: node :: IncludeParam > :: into (crate :: prisma :: node :: shared_operation :: Include :: $ selection_mode (crate :: prisma :: shared_operation :: ManyArgs :: new (crate :: prisma :: shared_operation :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: shared_operation :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; shared_operation $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: node :: IncludeParam > :: into (crate :: prisma :: node :: shared_operation :: Include :: Fetch (crate :: prisma :: shared_operation :: ManyArgs :: new (crate :: prisma :: shared_operation :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: node :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; platform) => { "platform" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; last_seen) => { "last_seen" } ; (@ field_serde_name ; timezone) => { "timezone" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; jobs) => { "jobs" } ; (@ field_serde_name ; location) => { "Location" } ; (@ field_serde_name ; owned_operation) => { "OwnedOperation" } ; (@ field_serde_name ; shared_operation) => { "SharedOperation" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_node as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		Platform(platform::Include),
		Version(version::Include),
		LastSeen(last_seen::Include),
		Timezone(timezone::Include),
		DateCreated(date_created::Include),
		Jobs(jobs::Include),
		Location(location::Include),
		OwnedOperation(owned_operation::Include),
		SharedOperation(shared_operation::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Platform(data) => data.to_selection(),
				Self::Version(data) => data.to_selection(),
				Self::LastSeen(data) => data.to_selection(),
				Self::Timezone(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::Jobs(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::OwnedOperation(data) => data.to_selection(),
				Self::SharedOperation(data) => data.to_selection(),
			}
		}
	}
	pub mod location {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "Location";
		pub fn some(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationSome(value)
		}
		pub fn every(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationEvery(value)
		}
		pub fn none(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationNone(value)
		}
		pub struct Order(Vec<location::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<location::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Location(v)
			}
		}
		pub struct Fetch(pub location::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<location::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: location::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: location::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Location(v)
			}
		}
		pub fn fetch(params: Vec<location::WhereParam>) -> Fetch {
			Fetch(location::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<location::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLocation(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<location::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<location::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectLocation(params)
		}
		pub fn set(params: Vec<location::UniqueWhereParam>) -> SetParam {
			SetParam::SetLocation(params)
		}
		pub enum Select {
			Select(location::ManyArgs, Vec<location::SelectParam>),
			Include(location::ManyArgs, Vec<location::IncludeParam>),
			Fetch(location::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Location(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: location::ManyArgs,
				nested_selections: Vec<location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: location::ManyArgs,
				nested_selections: Vec<location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(location::ManyArgs, Vec<location::SelectParam>),
			Include(location::ManyArgs, Vec<location::IncludeParam>),
			Fetch(location::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Location(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = < location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: location::ManyArgs,
				nested_selections: Vec<location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: location::ManyArgs,
				nested_selections: Vec<location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod owned_operation {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "OwnedOperation";
		pub fn some(value: Vec<owned_operation::WhereParam>) -> WhereParam {
			WhereParam::OwnedOperationSome(value)
		}
		pub fn every(value: Vec<owned_operation::WhereParam>) -> WhereParam {
			WhereParam::OwnedOperationEvery(value)
		}
		pub fn none(value: Vec<owned_operation::WhereParam>) -> WhereParam {
			WhereParam::OwnedOperationNone(value)
		}
		pub struct Order(Vec<owned_operation::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<owned_operation::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::OwnedOperation(v)
			}
		}
		pub struct Fetch(pub owned_operation::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<owned_operation::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: owned_operation::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: owned_operation::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::OwnedOperation(v)
			}
		}
		pub fn fetch(params: Vec<owned_operation::WhereParam>) -> Fetch {
			Fetch(owned_operation::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<owned_operation::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectOwnedOperation(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<owned_operation::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<owned_operation::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectOwnedOperation(params)
		}
		pub fn set(params: Vec<owned_operation::UniqueWhereParam>) -> SetParam {
			SetParam::SetOwnedOperation(params)
		}
		pub enum Select {
			Select(owned_operation::ManyArgs, Vec<owned_operation::SelectParam>),
			Include(
				owned_operation::ManyArgs,
				Vec<owned_operation::IncludeParam>,
			),
			Fetch(owned_operation::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::OwnedOperation(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < owned_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: owned_operation::ManyArgs,
				nested_selections: Vec<owned_operation::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: owned_operation::ManyArgs,
				nested_selections: Vec<owned_operation::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(owned_operation::ManyArgs, Vec<owned_operation::SelectParam>),
			Include(
				owned_operation::ManyArgs,
				Vec<owned_operation::IncludeParam>,
			),
			Fetch(owned_operation::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::OwnedOperation(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < owned_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < owned_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: owned_operation::ManyArgs,
				nested_selections: Vec<owned_operation::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: owned_operation::ManyArgs,
				nested_selections: Vec<owned_operation::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod shared_operation {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "SharedOperation";
		pub fn some(value: Vec<shared_operation::WhereParam>) -> WhereParam {
			WhereParam::SharedOperationSome(value)
		}
		pub fn every(value: Vec<shared_operation::WhereParam>) -> WhereParam {
			WhereParam::SharedOperationEvery(value)
		}
		pub fn none(value: Vec<shared_operation::WhereParam>) -> WhereParam {
			WhereParam::SharedOperationNone(value)
		}
		pub struct Order(Vec<shared_operation::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<shared_operation::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::SharedOperation(v)
			}
		}
		pub struct Fetch(pub shared_operation::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<shared_operation::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: shared_operation::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: shared_operation::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::SharedOperation(v)
			}
		}
		pub fn fetch(params: Vec<shared_operation::WhereParam>) -> Fetch {
			Fetch(shared_operation::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<shared_operation::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectSharedOperation(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<shared_operation::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<shared_operation::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectSharedOperation(params)
		}
		pub fn set(params: Vec<shared_operation::UniqueWhereParam>) -> SetParam {
			SetParam::SetSharedOperation(params)
		}
		pub enum Select {
			Select(
				shared_operation::ManyArgs,
				Vec<shared_operation::SelectParam>,
			),
			Include(
				shared_operation::ManyArgs,
				Vec<shared_operation::IncludeParam>,
			),
			Fetch(shared_operation::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SharedOperation(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: shared_operation::ManyArgs,
				nested_selections: Vec<shared_operation::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: shared_operation::ManyArgs,
				nested_selections: Vec<shared_operation::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(
				shared_operation::ManyArgs,
				Vec<shared_operation::SelectParam>,
			),
			Include(
				shared_operation::ManyArgs,
				Vec<shared_operation::IncludeParam>,
			),
			Fetch(shared_operation::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SharedOperation(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < shared_operation :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: shared_operation::ManyArgs,
				nested_selections: Vec<shared_operation::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: shared_operation::ManyArgs,
				nested_selections: Vec<shared_operation::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod jobs {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "jobs";
		pub fn some(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::JobsSome(value)
		}
		pub fn every(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::JobsEvery(value)
		}
		pub fn none(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::JobsNone(value)
		}
		pub struct Order(Vec<job::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<job::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Jobs(v)
			}
		}
		pub struct Fetch(pub job::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<job::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: job::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: job::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Jobs(v)
			}
		}
		pub fn fetch(params: Vec<job::WhereParam>) -> Fetch {
			Fetch(job::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<job::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectJobs(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<job::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<job::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectJobs(params)
		}
		pub fn set(params: Vec<job::UniqueWhereParam>) -> SetParam {
			SetParam::SetJobs(params)
		}
		pub enum Select {
			Select(job::ManyArgs, Vec<job::SelectParam>),
			Include(job::ManyArgs, Vec<job::IncludeParam>),
			Fetch(job::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Jobs(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(args: job::ManyArgs, nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(args: job::ManyArgs, nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(job::ManyArgs, Vec<job::SelectParam>),
			Include(job::ManyArgs, Vec<job::IncludeParam>),
			Fetch(job::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Jobs(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections =
							<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(args: job::ManyArgs, nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(args: job::ManyArgs, nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod last_seen {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "last_seen";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			LastSeen,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LastSeen(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LastSeen(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::LastSeen(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LastSeen(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LastSeen(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LastSeen(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LastSeen(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod platform {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "platform";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::Platform(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			Platform,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Platform(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Platform(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Platform(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Platform(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Platform(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Platform(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Platform(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod timezone {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "timezone";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Timezone(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Timezone,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Timezone(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Timezone(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Timezone(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Timezone(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Timezone(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Timezone(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Timezone(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod version {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "version";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Version,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Version(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Version(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Version(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Version(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Version(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Version(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Version(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub name: String,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.node().create(self.pub_id, self.name, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([pub_id::set(self.pub_id), name::set(self.name)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, name: String, _params: Vec<SetParam>) -> Create {
		Create {
			pub_id,
			name,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub name: String,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.node()
				.create_unchecked(self.pub_id, self.name, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([pub_id::set(self.pub_id), name::set(self.name)]);
			self._params
		}
	}
	pub fn create_unchecked(
		pub_id: Vec<u8>,
		name: String,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			pub_id,
			name,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(platform::NAME),
				::prisma_client_rust::sel(version::NAME),
				::prisma_client_rust::sel(last_seen::NAME),
				::prisma_client_rust::sel(timezone::NAME),
				::prisma_client_rust::sel(date_created::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Node", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pub_id")]
		pub pub_id: Vec<u8>,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "platform")]
		pub platform: i32,
		#[serde(rename = "version")]
		pub version: Option<String>,
		#[serde(rename = "last_seen")]
		pub last_seen:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "timezone")]
		pub timezone: Option<String>,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "jobs")]
		#[specta(skip)]
		pub jobs: Option<Vec<super::job::Data>>,
		#[serde(rename = "Location")]
		#[specta(skip)]
		pub location: Option<Vec<super::location::Data>>,
		#[serde(rename = "OwnedOperation")]
		#[specta(skip)]
		pub owned_operation: Option<Vec<super::owned_operation::Data>>,
		#[serde(rename = "SharedOperation")]
		#[specta(skip)]
		pub shared_operation: Option<Vec<super::shared_operation::Data>>,
	}
	impl Data {
		pub fn jobs(
			&self,
		) -> Result<&Vec<super::job::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.jobs
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(jobs),
				))
		}
		pub fn location(
			&self,
		) -> Result<&Vec<super::location::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.location
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(location),
				))
		}
		pub fn owned_operation(
			&self,
		) -> Result<&Vec<super::owned_operation::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.owned_operation
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(owned_operation),
				))
		}
		pub fn shared_operation(
			&self,
		) -> Result<
			&Vec<super::shared_operation::Data>,
			::prisma_client_rust::RelationNotFetchedError,
		> {
			self.shared_operation.as_ref().ok_or(
				::prisma_client_rust::RelationNotFetchedError::new(stringify!(shared_operation)),
			)
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_node { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: node struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] pub name : String , # [serde (rename = "platform")] pub platform : i32 , # [serde (rename = "version")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub version : Option < String > , # [serde (rename = "last_seen")] pub last_seen : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "timezone")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub timezone : Option < String > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_node as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			pub_id: Vec<u8>,
			name: String,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id), name::set(name)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			name: String,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id), name::set(name)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod volume {
	use super::_prisma::*;
	pub const NAME: &str = "Volume";
	pub fn node_id_mount_point_name<T: From<UniqueWhereParam>>(
		node_id: i32,
		mount_point: String,
		name: String,
	) -> T {
		UniqueWhereParam::NodeIdMountPointNameEquals(node_id, mount_point, name).into()
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		NodeIdMountPointNameEquals(i32, String, String),
		Id(super::_prisma::read_filters::IntFilter),
		NodeId(super::_prisma::read_filters::IntFilter),
		Name(super::_prisma::read_filters::StringFilter),
		MountPoint(super::_prisma::read_filters::StringFilter),
		TotalBytesCapacity(super::_prisma::read_filters::StringFilter),
		TotalBytesAvailable(super::_prisma::read_filters::StringFilter),
		DiskType(super::_prisma::read_filters::StringNullableFilter),
		Filesystem(super::_prisma::read_filters::StringNullableFilter),
		IsSystem(super::_prisma::read_filters::BooleanFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::NodeIdMountPointNameEquals(node_id, mount_point, name) => (
					"node_id_mount_point_name",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							node_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(node_id as i64),
						),
						(
							mount_point::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(mount_point),
						),
						(
							name::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(name),
						),
					]),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::MountPoint(value) => (mount_point::NAME, value.into()),
				Self::TotalBytesCapacity(value) => (total_bytes_capacity::NAME, value.into()),
				Self::TotalBytesAvailable(value) => (total_bytes_available::NAME, value.into()),
				Self::DiskType(value) => (disk_type::NAME, value.into()),
				Self::Filesystem(value) => (filesystem::NAME, value.into()),
				Self::IsSystem(value) => (is_system::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		NodeIdMountPointNameEquals(i32, String, String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::NodeIdMountPointNameEquals(node_id, mount_point, name) => {
					Self::NodeIdMountPointNameEquals(node_id, mount_point, name)
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		NodeId(super::SortOrder),
		Name(super::SortOrder),
		MountPoint(super::SortOrder),
		TotalBytesCapacity(super::SortOrder),
		TotalBytesAvailable(super::SortOrder),
		DiskType(super::SortOrder),
		Filesystem(super::SortOrder),
		IsSystem(super::SortOrder),
		DateModified(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::NodeId(param) => ("node_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::MountPoint(param) => ("mount_point", param.into()),
				Self::TotalBytesCapacity(param) => ("total_bytes_capacity", param.into()),
				Self::TotalBytesAvailable(param) => ("total_bytes_available", param.into()),
				Self::DiskType(param) => ("disk_type", param.into()),
				Self::Filesystem(param) => ("filesystem", param.into()),
				Self::IsSystem(param) => ("is_system", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		NodeId(super::_prisma::write_params::IntParam),
		Name(super::_prisma::write_params::StringParam),
		MountPoint(super::_prisma::write_params::StringParam),
		TotalBytesCapacity(super::_prisma::write_params::StringParam),
		TotalBytesAvailable(super::_prisma::write_params::StringParam),
		DiskType(super::_prisma::write_params::StringNullableParam),
		Filesystem(super::_prisma::write_params::StringNullableParam),
		IsSystem(super::_prisma::write_params::BooleanParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::MountPoint(value) => (mount_point::NAME, value.into()),
				Self::TotalBytesCapacity(value) => (total_bytes_capacity::NAME, value.into()),
				Self::TotalBytesAvailable(value) => (total_bytes_available::NAME, value.into()),
				Self::DiskType(value) => (disk_type::NAME, value.into()),
				Self::Filesystem(value) => (filesystem::NAME, value.into()),
				Self::IsSystem(value) => (is_system::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		NodeId(super::_prisma::write_params::IntParam),
		Name(super::_prisma::write_params::StringParam),
		MountPoint(super::_prisma::write_params::StringParam),
		TotalBytesCapacity(super::_prisma::write_params::StringParam),
		TotalBytesAvailable(super::_prisma::write_params::StringParam),
		DiskType(super::_prisma::write_params::StringNullableParam),
		Filesystem(super::_prisma::write_params::StringNullableParam),
		IsSystem(super::_prisma::write_params::BooleanParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::NodeId(value) => ("node_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::MountPoint(value) => ("mount_point", value.into()),
				Self::TotalBytesCapacity(value) => ("total_bytes_capacity", value.into()),
				Self::TotalBytesAvailable(value) => ("total_bytes_available", value.into()),
				Self::DiskType(value) => ("disk_type", value.into()),
				Self::Filesystem(value) => ("filesystem", value.into()),
				Self::IsSystem(value) => ("is_system", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_volume { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: volume :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: volume :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: volume :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: volume :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: volume :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: volume :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , node_id , name , mount_point , total_bytes_capacity , total_bytes_available , disk_type , filesystem , is_system , date_modified } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: volume :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: volume :: $ field :: NAME)] pub $ field : crate :: prisma :: volume :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: volume :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: volume :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: volume :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "node_id" , "name" , "mount_point" , "total_bytes_capacity" , "total_bytes_available" , "disk_type" , "filesystem" , "is_system" , "date_modified"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: volume :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; node_id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; mount_point) => { String } ; (@ field_type ; total_bytes_capacity) => { String } ; (@ field_type ; total_bytes_available) => { String } ; (@ field_type ; disk_type) => { Option < String > } ; (@ field_type ; filesystem) => { Option < String > } ; (@ field_type ; is_system) => { bool } ; (@ field_type ; date_modified) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Volume" , available relations are "id, node_id, name, mount_point, total_bytes_capacity, total_bytes_available, disk_type, filesystem, is_system, date_modified")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: id :: Select) } ; (@ selection_field_to_selection_param ; node_id) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: node_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: name :: Select) } ; (@ selection_field_to_selection_param ; mount_point) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: mount_point :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_capacity) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: total_bytes_capacity :: Select) } ; (@ selection_field_to_selection_param ; total_bytes_available) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: total_bytes_available :: Select) } ; (@ selection_field_to_selection_param ; disk_type) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: disk_type :: Select) } ; (@ selection_field_to_selection_param ; filesystem) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: filesystem :: Select) } ; (@ selection_field_to_selection_param ; is_system) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: is_system :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < crate :: prisma :: volume :: SelectParam > :: into (crate :: prisma :: volume :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: volume :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; mount_point) => { "mount_point" } ; (@ field_serde_name ; total_bytes_capacity) => { "total_bytes_capacity" } ; (@ field_serde_name ; total_bytes_available) => { "total_bytes_available" } ; (@ field_serde_name ; disk_type) => { "disk_type" } ; (@ field_serde_name ; filesystem) => { "filesystem" } ; (@ field_serde_name ; is_system) => { "is_system" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_volume as select;
	pub enum SelectParam {
		Id(id::Select),
		NodeId(node_id::Select),
		Name(name::Select),
		MountPoint(mount_point::Select),
		TotalBytesCapacity(total_bytes_capacity::Select),
		TotalBytesAvailable(total_bytes_available::Select),
		DiskType(disk_type::Select),
		Filesystem(filesystem::Select),
		IsSystem(is_system::Select),
		DateModified(date_modified::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::MountPoint(data) => data.to_selection(),
				Self::TotalBytesCapacity(data) => data.to_selection(),
				Self::TotalBytesAvailable(data) => data.to_selection(),
				Self::DiskType(data) => data.to_selection(),
				Self::Filesystem(data) => data.to_selection(),
				Self::IsSystem(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_volume { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: volume :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: volume :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: volume :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: volume :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: volume :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: volume :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: volume :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: volume :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: volume :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: volume :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: volume :: node_id :: NAME)] pub node_id : i32 , # [specta (rename_from_path = crate :: prisma :: volume :: name :: NAME)] pub name : String , # [specta (rename_from_path = crate :: prisma :: volume :: mount_point :: NAME)] pub mount_point : String , # [specta (rename_from_path = crate :: prisma :: volume :: total_bytes_capacity :: NAME)] pub total_bytes_capacity : String , # [specta (rename_from_path = crate :: prisma :: volume :: total_bytes_available :: NAME)] pub total_bytes_available : String , # [specta (rename_from_path = crate :: prisma :: volume :: disk_type :: NAME)] pub disk_type : Option < String > , # [specta (rename_from_path = crate :: prisma :: volume :: filesystem :: NAME)] pub filesystem : Option < String > , # [specta (rename_from_path = crate :: prisma :: volume :: is_system :: NAME)] pub is_system : bool , # [specta (rename_from_path = crate :: prisma :: volume :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: prisma :: volume :: $ field :: NAME)] pub $ field : crate :: prisma :: volume :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (node_id) , stringify ! (name) , stringify ! (mount_point) , stringify ! (total_bytes_capacity) , stringify ! (total_bytes_available) , stringify ! (disk_type) , stringify ! (filesystem) , stringify ! (is_system) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: volume :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: volume :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: volume :: node_id :: NAME , & self . node_id) ? ; state . serialize_field (crate :: prisma :: volume :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: volume :: mount_point :: NAME , & self . mount_point) ? ; state . serialize_field (crate :: prisma :: volume :: total_bytes_capacity :: NAME , & self . total_bytes_capacity) ? ; state . serialize_field (crate :: prisma :: volume :: total_bytes_available :: NAME , & self . total_bytes_available) ? ; state . serialize_field (crate :: prisma :: volume :: disk_type :: NAME , & self . disk_type) ? ; state . serialize_field (crate :: prisma :: volume :: filesystem :: NAME , & self . filesystem) ? ; state . serialize_field (crate :: prisma :: volume :: is_system :: NAME , & self . is_system) ? ; state . serialize_field (crate :: prisma :: volume :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , node_id , name , mount_point , total_bytes_capacity , total_bytes_available , disk_type , filesystem , is_system , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: volume :: $ field :: NAME) , + , crate :: prisma :: volume :: id :: NAME , crate :: prisma :: volume :: node_id :: NAME , crate :: prisma :: volume :: name :: NAME , crate :: prisma :: volume :: mount_point :: NAME , crate :: prisma :: volume :: total_bytes_capacity :: NAME , crate :: prisma :: volume :: total_bytes_available :: NAME , crate :: prisma :: volume :: disk_type :: NAME , crate :: prisma :: volume :: filesystem :: NAME , crate :: prisma :: volume :: is_system :: NAME , crate :: prisma :: volume :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: volume :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: volume :: id :: NAME => Ok (Field :: id) , crate :: prisma :: volume :: node_id :: NAME => Ok (Field :: node_id) , crate :: prisma :: volume :: name :: NAME => Ok (Field :: name) , crate :: prisma :: volume :: mount_point :: NAME => Ok (Field :: mount_point) , crate :: prisma :: volume :: total_bytes_capacity :: NAME => Ok (Field :: total_bytes_capacity) , crate :: prisma :: volume :: total_bytes_available :: NAME => Ok (Field :: total_bytes_available) , crate :: prisma :: volume :: disk_type :: NAME => Ok (Field :: disk_type) , crate :: prisma :: volume :: filesystem :: NAME => Ok (Field :: filesystem) , crate :: prisma :: volume :: is_system :: NAME => Ok (Field :: is_system) , crate :: prisma :: volume :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut node_id = None ; let mut name = None ; let mut mount_point = None ; let mut total_bytes_capacity = None ; let mut total_bytes_available = None ; let mut disk_type = None ; let mut filesystem = None ; let mut is_system = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: node_id => { if node_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: node_id :: NAME)) ; } node_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: mount_point => { if mount_point . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: mount_point :: NAME)) ; } mount_point = Some (map . next_value () ?) ; } Field :: total_bytes_capacity => { if total_bytes_capacity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: total_bytes_capacity :: NAME)) ; } total_bytes_capacity = Some (map . next_value () ?) ; } Field :: total_bytes_available => { if total_bytes_available . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: total_bytes_available :: NAME)) ; } total_bytes_available = Some (map . next_value () ?) ; } Field :: disk_type => { if disk_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: disk_type :: NAME)) ; } disk_type = Some (map . next_value () ?) ; } Field :: filesystem => { if filesystem . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: filesystem :: NAME)) ; } filesystem = Some (map . next_value () ?) ; } Field :: is_system => { if is_system . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: is_system :: NAME)) ; } is_system = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: volume :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: id :: NAME)) ? ; let node_id = node_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: node_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: name :: NAME)) ? ; let mount_point = mount_point . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: mount_point :: NAME)) ? ; let total_bytes_capacity = total_bytes_capacity . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: total_bytes_capacity :: NAME)) ? ; let total_bytes_available = total_bytes_available . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: total_bytes_available :: NAME)) ? ; let disk_type = disk_type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: disk_type :: NAME)) ? ; let filesystem = filesystem . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: filesystem :: NAME)) ? ; let is_system = is_system . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: is_system :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: volume :: date_modified :: NAME)) ? ; Ok (Data { id , node_id , name , mount_point , total_bytes_capacity , total_bytes_available , disk_type , filesystem , is_system , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "node_id" , "name" , "mount_point" , "total_bytes_capacity" , "total_bytes_available" , "disk_type" , "filesystem" , "is_system" , "date_modified"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: volume :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Volume" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: volume :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; mount_point) => { "mount_point" } ; (@ field_serde_name ; total_bytes_capacity) => { "total_bytes_capacity" } ; (@ field_serde_name ; total_bytes_available) => { "total_bytes_available" } ; (@ field_serde_name ; disk_type) => { "disk_type" } ; (@ field_serde_name ; filesystem) => { "filesystem" } ; (@ field_serde_name ; is_system) => { "is_system" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_volume as include;
	pub enum IncludeParam {
		Id(id::Include),
		NodeId(node_id::Include),
		Name(name::Include),
		MountPoint(mount_point::Include),
		TotalBytesCapacity(total_bytes_capacity::Include),
		TotalBytesAvailable(total_bytes_available::Include),
		DiskType(disk_type::Include),
		Filesystem(filesystem::Include),
		IsSystem(is_system::Include),
		DateModified(date_modified::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::MountPoint(data) => data.to_selection(),
				Self::TotalBytesCapacity(data) => data.to_selection(),
				Self::TotalBytesAvailable(data) => data.to_selection(),
				Self::DiskType(data) => data.to_selection(),
				Self::Filesystem(data) => data.to_selection(),
				Self::IsSystem(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod disk_type {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "disk_type";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::DiskType(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			DiskType,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DiskType(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DiskType(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DiskType(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DiskType(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DiskType(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DiskType(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DiskType(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod filesystem {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "filesystem";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Filesystem(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Filesystem,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Filesystem(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Filesystem(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Filesystem(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Filesystem(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Filesystem(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Filesystem(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Filesystem(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod is_system {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "is_system";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::IsSystem(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			IsSystem,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IsSystem(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsSystem(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsSystem(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsSystem(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsSystem(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsSystem(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsSystem(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod mount_point {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "mount_point";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::MountPoint(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			MountPoint,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::MountPoint(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MountPoint(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::MountPoint(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::MountPoint(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MountPoint(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::MountPoint(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::MountPoint(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod node_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodeId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, NodeId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeId(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NodeId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NodeId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_available {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_available";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesAvailable(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesAvailable,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesAvailable(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesAvailable(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesAvailable(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesAvailable(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesAvailable(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesAvailable(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesAvailable(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_bytes_capacity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_bytes_capacity";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::TotalBytesCapacity(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			TotalBytesCapacity,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesCapacity(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalBytesCapacity(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalBytesCapacity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalBytesCapacity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalBytesCapacity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub node_id: i32,
		pub name: String,
		pub mount_point: String,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.volume()
				.create(self.node_id, self.name, self.mount_point, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				node_id::set(self.node_id),
				name::set(self.name),
				mount_point::set(self.mount_point),
			]);
			self._params
		}
	}
	pub fn create(
		node_id: i32,
		name: String,
		mount_point: String,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			node_id,
			name,
			mount_point,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub node_id: i32,
		pub name: String,
		pub mount_point: String,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.volume().create_unchecked(
				self.node_id,
				self.name,
				self.mount_point,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				node_id::set(self.node_id),
				name::set(self.name),
				mount_point::set(self.mount_point),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		node_id: i32,
		name: String,
		mount_point: String,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			node_id,
			name,
			mount_point,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(node_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(mount_point::NAME),
				::prisma_client_rust::sel(total_bytes_capacity::NAME),
				::prisma_client_rust::sel(total_bytes_available::NAME),
				::prisma_client_rust::sel(disk_type::NAME),
				::prisma_client_rust::sel(filesystem::NAME),
				::prisma_client_rust::sel(is_system::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Volume", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "node_id")]
		pub node_id: i32,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "mount_point")]
		pub mount_point: String,
		#[serde(rename = "total_bytes_capacity")]
		pub total_bytes_capacity: String,
		#[serde(rename = "total_bytes_available")]
		pub total_bytes_available: String,
		#[serde(rename = "disk_type")]
		pub disk_type: Option<String>,
		#[serde(rename = "filesystem")]
		pub filesystem: Option<String>,
		#[serde(rename = "is_system")]
		pub is_system: bool,
		#[serde(rename = "date_modified")]
		pub date_modified:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
	}
	impl Data {}
	#[macro_export]
	macro_rules ! _partial_unchecked_volume { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: volume struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "node_id")] pub node_id : i32 , # [serde (rename = "name")] pub name : String , # [serde (rename = "mount_point")] pub mount_point : String , # [serde (rename = "total_bytes_capacity")] pub total_bytes_capacity : String , # [serde (rename = "total_bytes_available")] pub total_bytes_available : String , # [serde (rename = "disk_type")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub disk_type : Option < String > , # [serde (rename = "filesystem")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub filesystem : Option < String > , # [serde (rename = "is_system")] pub is_system : bool , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_volume as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			node_id: i32,
			name: String,
			mount_point: String,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				node_id::set(node_id),
				name::set(name),
				mount_point::set(mount_point),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			node_id: i32,
			name: String,
			mount_point: String,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				node_id::set(node_id),
				name::set(name),
				mount_point::set(mount_point),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod location {
	use super::_prisma::*;
	pub const NAME: &str = "Location";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		NodeId(super::_prisma::read_filters::IntFilter),
		Name(super::_prisma::read_filters::StringFilter),
		Path(super::_prisma::read_filters::StringFilter),
		TotalCapacity(super::_prisma::read_filters::IntNullableFilter),
		AvailableCapacity(super::_prisma::read_filters::IntNullableFilter),
		IsArchived(super::_prisma::read_filters::BooleanFilter),
		GeneratePreviewMedia(super::_prisma::read_filters::BooleanFilter),
		SyncPreviewMedia(super::_prisma::read_filters::BooleanFilter),
		Hidden(super::_prisma::read_filters::BooleanFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		NodeIs(Vec<super::node::WhereParam>),
		NodeIsNot(Vec<super::node::WhereParam>),
		FilePathsSome(Vec<super::file_path::WhereParam>),
		FilePathsEvery(Vec<super::file_path::WhereParam>),
		FilePathsNone(Vec<super::file_path::WhereParam>),
		IndexerRulesSome(Vec<super::indexer_rules_in_location::WhereParam>),
		IndexerRulesEvery(Vec<super::indexer_rules_in_location::WhereParam>),
		IndexerRulesNone(Vec<super::indexer_rules_in_location::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Path(value) => (path::NAME, value.into()),
				Self::TotalCapacity(value) => (total_capacity::NAME, value.into()),
				Self::AvailableCapacity(value) => (available_capacity::NAME, value.into()),
				Self::IsArchived(value) => (is_archived::NAME, value.into()),
				Self::GeneratePreviewMedia(value) => (generate_preview_media::NAME, value.into()),
				Self::SyncPreviewMedia(value) => (sync_preview_media::NAME, value.into()),
				Self::Hidden(value) => (hidden::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::NodeIs(where_params) => (
					node::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::NodeIsNot(where_params) => (
					node::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsSome(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsEvery(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsNone(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRulesSome(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRulesEvery(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRulesNone(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		NodeId(super::SortOrder),
		Name(super::SortOrder),
		Path(super::SortOrder),
		TotalCapacity(super::SortOrder),
		AvailableCapacity(super::SortOrder),
		IsArchived(super::SortOrder),
		GeneratePreviewMedia(super::SortOrder),
		SyncPreviewMedia(super::SortOrder),
		Hidden(super::SortOrder),
		DateCreated(super::SortOrder),
		Node(Vec<super::node::OrderByWithRelationParam>),
		FilePaths(Vec<super::file_path::OrderByRelationAggregateParam>),
		IndexerRules(Vec<super::indexer_rules_in_location::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::NodeId(param) => ("node_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Path(param) => ("path", param.into()),
				Self::TotalCapacity(param) => ("total_capacity", param.into()),
				Self::AvailableCapacity(param) => ("available_capacity", param.into()),
				Self::IsArchived(param) => ("is_archived", param.into()),
				Self::GeneratePreviewMedia(param) => ("generate_preview_media", param.into()),
				Self::SyncPreviewMedia(param) => ("sync_preview_media", param.into()),
				Self::Hidden(param) => ("hidden", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::Node(param) => (
					"node",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::FilePaths(param) => (
					"file_paths",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::IndexerRules(param) => (
					"indexer_rules",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Node(super::node::UniqueArgs),
		FilePaths(super::file_path::ManyArgs),
		IndexerRules(super::indexer_rules_in_location::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Node(args) => {
					let mut selections =
						<super::node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(node::NAME, None, [], selections)
				}
				Self::FilePaths(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						file_paths::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::IndexerRules(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						indexer_rules::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		NodeId(super::_prisma::write_params::IntParam),
		Name(super::_prisma::write_params::StringParam),
		Path(super::_prisma::write_params::StringParam),
		TotalCapacity(super::_prisma::write_params::IntNullableParam),
		AvailableCapacity(super::_prisma::write_params::IntNullableParam),
		IsArchived(super::_prisma::write_params::BooleanParam),
		GeneratePreviewMedia(super::_prisma::write_params::BooleanParam),
		SyncPreviewMedia(super::_prisma::write_params::BooleanParam),
		Hidden(super::_prisma::write_params::BooleanParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		ConnectNode(super::node::UniqueWhereParam),
		ConnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		DisconnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		SetFilePaths(Vec<super::file_path::UniqueWhereParam>),
		ConnectIndexerRules(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
		DisconnectIndexerRules(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
		SetIndexerRules(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Path(value) => (path::NAME, value.into()),
				Self::TotalCapacity(value) => (total_capacity::NAME, value.into()),
				Self::AvailableCapacity(value) => (available_capacity::NAME, value.into()),
				Self::IsArchived(value) => (is_archived::NAME, value.into()),
				Self::GeneratePreviewMedia(value) => (generate_preview_media::NAME, value.into()),
				Self::SyncPreviewMedia(value) => (sync_preview_media::NAME, value.into()),
				Self::Hidden(value) => (hidden::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::ConnectNode(where_param) => (
					node::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::node::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ConnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectIndexerRules(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectIndexerRules(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetIndexerRules(where_params) => (
					indexer_rules::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		NodeId(super::_prisma::write_params::IntParam),
		Name(super::_prisma::write_params::StringParam),
		Path(super::_prisma::write_params::StringParam),
		TotalCapacity(super::_prisma::write_params::IntNullableParam),
		AvailableCapacity(super::_prisma::write_params::IntNullableParam),
		IsArchived(super::_prisma::write_params::BooleanParam),
		GeneratePreviewMedia(super::_prisma::write_params::BooleanParam),
		SyncPreviewMedia(super::_prisma::write_params::BooleanParam),
		Hidden(super::_prisma::write_params::BooleanParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::NodeId(value) => ("node_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Path(value) => ("path", value.into()),
				Self::TotalCapacity(value) => ("total_capacity", value.into()),
				Self::AvailableCapacity(value) => ("available_capacity", value.into()),
				Self::IsArchived(value) => ("is_archived", value.into()),
				Self::GeneratePreviewMedia(value) => ("generate_preview_media", value.into()),
				Self::SyncPreviewMedia(value) => ("sync_preview_media", value.into()),
				Self::Hidden(value) => ("hidden", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: location :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: location :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , node_id , name , path , total_capacity , available_capacity , is_archived , generate_preview_media , sync_preview_media , hidden , date_created , node , file_paths , indexer_rules } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: location :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: location :: $ field :: NAME)] pub $ field : crate :: prisma :: location :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: location :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: location :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: location :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "node_id" , "name" , "path" , "total_capacity" , "available_capacity" , "is_archived" , "generate_preview_media" , "sync_preview_media" , "hidden" , "date_created" , "node" , "file_paths" , "indexer_rules"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pub_id) => { Vec < u8 > } ; (@ field_type ; node_id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; path) => { String } ; (@ field_type ; total_capacity) => { Option < i32 > } ; (@ field_type ; available_capacity) => { Option < i32 > } ; (@ field_type ; is_archived) => { bool } ; (@ field_type ; generate_preview_media) => { bool } ; (@ field_type ; sync_preview_media) => { bool } ; (@ field_type ; hidden) => { bool } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { node :: Data } ; (@ field_type ; node) => { crate :: prisma :: node :: Data } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; file_paths) => { Vec < crate :: prisma :: file_path :: Data > } ; (@ field_type ; indexer_rules : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < indexer_rules :: Data > } ; (@ field_type ; indexer_rules) => { Vec < crate :: prisma :: indexer_rules_in_location :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Location" , available relations are "id, pub_id, node_id, name, path, total_capacity, available_capacity, is_archived, generate_preview_media, sync_preview_media, hidden, date_created, node, file_paths, indexer_rules")) } ; (@ field_module ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: node :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: file_path :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; indexer_rules : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: indexer_rules_in_location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; node_id) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: node_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: name :: Select) } ; (@ selection_field_to_selection_param ; path) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: path :: Select) } ; (@ selection_field_to_selection_param ; total_capacity) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: total_capacity :: Select) } ; (@ selection_field_to_selection_param ; available_capacity) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: available_capacity :: Select) } ; (@ selection_field_to_selection_param ; is_archived) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: is_archived :: Select) } ; (@ selection_field_to_selection_param ; generate_preview_media) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: generate_preview_media :: Select) } ; (@ selection_field_to_selection_param ; sync_preview_media) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: sync_preview_media :: Select) } ; (@ selection_field_to_selection_param ; hidden) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: hidden :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: date_created :: Select) } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: node :: Select :: $ selection_mode (crate :: prisma :: node :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: node :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: file_paths :: Select :: $ selection_mode (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: file_paths :: Select :: Fetch (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; indexer_rules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: indexer_rules :: Select :: $ selection_mode (crate :: prisma :: indexer_rules_in_location :: ManyArgs :: new (crate :: prisma :: indexer_rules_in_location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; indexer_rules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: SelectParam > :: into (crate :: prisma :: location :: indexer_rules :: Select :: Fetch (crate :: prisma :: indexer_rules_in_location :: ManyArgs :: new (crate :: prisma :: indexer_rules_in_location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; total_capacity) => { "total_capacity" } ; (@ field_serde_name ; available_capacity) => { "available_capacity" } ; (@ field_serde_name ; is_archived) => { "is_archived" } ; (@ field_serde_name ; generate_preview_media) => { "generate_preview_media" } ; (@ field_serde_name ; sync_preview_media) => { "sync_preview_media" } ; (@ field_serde_name ; hidden) => { "hidden" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; node) => { "node" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ field_serde_name ; indexer_rules) => { "indexer_rules" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_location as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		NodeId(node_id::Select),
		Name(name::Select),
		Path(path::Select),
		TotalCapacity(total_capacity::Select),
		AvailableCapacity(available_capacity::Select),
		IsArchived(is_archived::Select),
		GeneratePreviewMedia(generate_preview_media::Select),
		SyncPreviewMedia(sync_preview_media::Select),
		Hidden(hidden::Select),
		DateCreated(date_created::Select),
		Node(node::Select),
		FilePaths(file_paths::Select),
		IndexerRules(indexer_rules::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Path(data) => data.to_selection(),
				Self::TotalCapacity(data) => data.to_selection(),
				Self::AvailableCapacity(data) => data.to_selection(),
				Self::IsArchived(data) => data.to_selection(),
				Self::GeneratePreviewMedia(data) => data.to_selection(),
				Self::SyncPreviewMedia(data) => data.to_selection(),
				Self::Hidden(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::Node(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
				Self::IndexerRules(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: location :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: location :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { node , file_paths , indexer_rules } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: location :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: location :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: location :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: location :: node_id :: NAME)] pub node_id : i32 , # [specta (rename_from_path = crate :: prisma :: location :: name :: NAME)] pub name : String , # [specta (rename_from_path = crate :: prisma :: location :: path :: NAME)] pub path : String , # [specta (rename_from_path = crate :: prisma :: location :: total_capacity :: NAME)] pub total_capacity : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: location :: available_capacity :: NAME)] pub available_capacity : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: location :: is_archived :: NAME)] pub is_archived : bool , # [specta (rename_from_path = crate :: prisma :: location :: generate_preview_media :: NAME)] pub generate_preview_media : bool , # [specta (rename_from_path = crate :: prisma :: location :: sync_preview_media :: NAME)] pub sync_preview_media : bool , # [specta (rename_from_path = crate :: prisma :: location :: hidden :: NAME)] pub hidden : bool , # [specta (rename_from_path = crate :: prisma :: location :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: prisma :: location :: $ field :: NAME)] pub $ field : crate :: prisma :: location :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (node_id) , stringify ! (name) , stringify ! (path) , stringify ! (total_capacity) , stringify ! (available_capacity) , stringify ! (is_archived) , stringify ! (generate_preview_media) , stringify ! (sync_preview_media) , stringify ! (hidden) , stringify ! (date_created)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: location :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: location :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: location :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (crate :: prisma :: location :: node_id :: NAME , & self . node_id) ? ; state . serialize_field (crate :: prisma :: location :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: location :: path :: NAME , & self . path) ? ; state . serialize_field (crate :: prisma :: location :: total_capacity :: NAME , & self . total_capacity) ? ; state . serialize_field (crate :: prisma :: location :: available_capacity :: NAME , & self . available_capacity) ? ; state . serialize_field (crate :: prisma :: location :: is_archived :: NAME , & self . is_archived) ? ; state . serialize_field (crate :: prisma :: location :: generate_preview_media :: NAME , & self . generate_preview_media) ? ; state . serialize_field (crate :: prisma :: location :: sync_preview_media :: NAME , & self . sync_preview_media) ? ; state . serialize_field (crate :: prisma :: location :: hidden :: NAME , & self . hidden) ? ; state . serialize_field (crate :: prisma :: location :: date_created :: NAME , & self . date_created) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , node_id , name , path , total_capacity , available_capacity , is_archived , generate_preview_media , sync_preview_media , hidden , date_created } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: location :: $ field :: NAME) , + , crate :: prisma :: location :: id :: NAME , crate :: prisma :: location :: pub_id :: NAME , crate :: prisma :: location :: node_id :: NAME , crate :: prisma :: location :: name :: NAME , crate :: prisma :: location :: path :: NAME , crate :: prisma :: location :: total_capacity :: NAME , crate :: prisma :: location :: available_capacity :: NAME , crate :: prisma :: location :: is_archived :: NAME , crate :: prisma :: location :: generate_preview_media :: NAME , crate :: prisma :: location :: sync_preview_media :: NAME , crate :: prisma :: location :: hidden :: NAME , crate :: prisma :: location :: date_created :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: location :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: location :: id :: NAME => Ok (Field :: id) , crate :: prisma :: location :: pub_id :: NAME => Ok (Field :: pub_id) , crate :: prisma :: location :: node_id :: NAME => Ok (Field :: node_id) , crate :: prisma :: location :: name :: NAME => Ok (Field :: name) , crate :: prisma :: location :: path :: NAME => Ok (Field :: path) , crate :: prisma :: location :: total_capacity :: NAME => Ok (Field :: total_capacity) , crate :: prisma :: location :: available_capacity :: NAME => Ok (Field :: available_capacity) , crate :: prisma :: location :: is_archived :: NAME => Ok (Field :: is_archived) , crate :: prisma :: location :: generate_preview_media :: NAME => Ok (Field :: generate_preview_media) , crate :: prisma :: location :: sync_preview_media :: NAME => Ok (Field :: sync_preview_media) , crate :: prisma :: location :: hidden :: NAME => Ok (Field :: hidden) , crate :: prisma :: location :: date_created :: NAME => Ok (Field :: date_created) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut node_id = None ; let mut name = None ; let mut path = None ; let mut total_capacity = None ; let mut available_capacity = None ; let mut is_archived = None ; let mut generate_preview_media = None ; let mut sync_preview_media = None ; let mut hidden = None ; let mut date_created = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: node_id => { if node_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: node_id :: NAME)) ; } node_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: path => { if path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: path :: NAME)) ; } path = Some (map . next_value () ?) ; } Field :: total_capacity => { if total_capacity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: total_capacity :: NAME)) ; } total_capacity = Some (map . next_value () ?) ; } Field :: available_capacity => { if available_capacity . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: available_capacity :: NAME)) ; } available_capacity = Some (map . next_value () ?) ; } Field :: is_archived => { if is_archived . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: is_archived :: NAME)) ; } is_archived = Some (map . next_value () ?) ; } Field :: generate_preview_media => { if generate_preview_media . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: generate_preview_media :: NAME)) ; } generate_preview_media = Some (map . next_value () ?) ; } Field :: sync_preview_media => { if sync_preview_media . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: sync_preview_media :: NAME)) ; } sync_preview_media = Some (map . next_value () ?) ; } Field :: hidden => { if hidden . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: hidden :: NAME)) ; } hidden = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: pub_id :: NAME)) ? ; let node_id = node_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: node_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: name :: NAME)) ? ; let path = path . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: path :: NAME)) ? ; let total_capacity = total_capacity . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: total_capacity :: NAME)) ? ; let available_capacity = available_capacity . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: available_capacity :: NAME)) ? ; let is_archived = is_archived . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: is_archived :: NAME)) ? ; let generate_preview_media = generate_preview_media . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: generate_preview_media :: NAME)) ? ; let sync_preview_media = sync_preview_media . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: sync_preview_media :: NAME)) ? ; let hidden = hidden . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: hidden :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: location :: date_created :: NAME)) ? ; Ok (Data { id , pub_id , node_id , name , path , total_capacity , available_capacity , is_archived , generate_preview_media , sync_preview_media , hidden , date_created , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "node_id" , "name" , "path" , "total_capacity" , "available_capacity" , "is_archived" , "generate_preview_media" , "sync_preview_media" , "hidden" , "date_created" , "node" , "file_paths" , "indexer_rules"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { node :: Data } ; (@ field_type ; node) => { crate :: prisma :: node :: Data } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; file_paths) => { Vec < crate :: prisma :: file_path :: Data > } ; (@ field_type ; indexer_rules : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < indexer_rules :: Data > } ; (@ field_type ; indexer_rules) => { Vec < crate :: prisma :: indexer_rules_in_location :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Location" , available relations are "node, file_paths, indexer_rules")) } ; (@ field_module ; node : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: node :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: file_path :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; indexer_rules : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: indexer_rules_in_location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: node :: Include :: $ selection_mode (crate :: prisma :: node :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; node $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: node :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: file_paths :: Include :: $ selection_mode (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: file_paths :: Include :: Fetch (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; indexer_rules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: indexer_rules :: Include :: $ selection_mode (crate :: prisma :: indexer_rules_in_location :: ManyArgs :: new (crate :: prisma :: indexer_rules_in_location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; indexer_rules $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: location :: IncludeParam > :: into (crate :: prisma :: location :: indexer_rules :: Include :: Fetch (crate :: prisma :: indexer_rules_in_location :: ManyArgs :: new (crate :: prisma :: indexer_rules_in_location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; total_capacity) => { "total_capacity" } ; (@ field_serde_name ; available_capacity) => { "available_capacity" } ; (@ field_serde_name ; is_archived) => { "is_archived" } ; (@ field_serde_name ; generate_preview_media) => { "generate_preview_media" } ; (@ field_serde_name ; sync_preview_media) => { "sync_preview_media" } ; (@ field_serde_name ; hidden) => { "hidden" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; node) => { "node" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ field_serde_name ; indexer_rules) => { "indexer_rules" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_location as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		NodeId(node_id::Include),
		Name(name::Include),
		Path(path::Include),
		TotalCapacity(total_capacity::Include),
		AvailableCapacity(available_capacity::Include),
		IsArchived(is_archived::Include),
		GeneratePreviewMedia(generate_preview_media::Include),
		SyncPreviewMedia(sync_preview_media::Include),
		Hidden(hidden::Include),
		DateCreated(date_created::Include),
		Node(node::Include),
		FilePaths(file_paths::Include),
		IndexerRules(indexer_rules::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Path(data) => data.to_selection(),
				Self::TotalCapacity(data) => data.to_selection(),
				Self::AvailableCapacity(data) => data.to_selection(),
				Self::IsArchived(data) => data.to_selection(),
				Self::GeneratePreviewMedia(data) => data.to_selection(),
				Self::SyncPreviewMedia(data) => data.to_selection(),
				Self::Hidden(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::Node(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
				Self::IndexerRules(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod available_capacity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "available_capacity";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::AvailableCapacity(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			AvailableCapacity,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::AvailableCapacity(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::AvailableCapacity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::AvailableCapacity(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::AvailableCapacity(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::AvailableCapacity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::AvailableCapacity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::AvailableCapacity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod file_paths {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "file_paths";
		pub fn some(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsSome(value)
		}
		pub fn every(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsEvery(value)
		}
		pub fn none(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsNone(value)
		}
		pub struct Order(Vec<file_path::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<file_path::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::FilePaths(v)
			}
		}
		pub struct Fetch(pub file_path::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: file_path::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: file_path::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::FilePaths(v)
			}
		}
		pub fn fetch(params: Vec<file_path::WhereParam>) -> Fetch {
			Fetch(file_path::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<file_path::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectFilePaths(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<file_path::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectFilePaths(params)
		}
		pub fn set(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::SetFilePaths(params)
		}
		pub enum Select {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::FilePaths(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::FilePaths(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = < file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod generate_preview_media {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "generate_preview_media";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::GeneratePreviewMedia(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			GeneratePreviewMedia,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::GeneratePreviewMedia(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::GeneratePreviewMedia(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::GeneratePreviewMedia(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::GeneratePreviewMedia(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::GeneratePreviewMedia(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::GeneratePreviewMedia(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::GeneratePreviewMedia(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod hidden {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "hidden";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::Hidden(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			Hidden,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Hidden(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Hidden(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Hidden(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Hidden(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Hidden(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Hidden(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Hidden(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod indexer_rules {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "indexer_rules";
		pub fn some(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::IndexerRulesSome(value)
		}
		pub fn every(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::IndexerRulesEvery(value)
		}
		pub fn none(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::IndexerRulesNone(value)
		}
		pub struct Order(Vec<indexer_rules_in_location::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(
			v: Vec<indexer_rules_in_location::OrderByRelationAggregateParam>,
		) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IndexerRules(v)
			}
		}
		pub struct Fetch(pub indexer_rules_in_location::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<indexer_rules_in_location::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(
				mut self,
				param: indexer_rules_in_location::OrderByWithRelationParam,
			) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: indexer_rules_in_location::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::IndexerRules(v)
			}
		}
		pub fn fetch(params: Vec<indexer_rules_in_location::WhereParam>) -> Fetch {
			Fetch(indexer_rules_in_location::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<indexer_rules_in_location::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectIndexerRules(v)
			}
		}
		pub fn connect<T: From<Connect>>(
			params: Vec<indexer_rules_in_location::UniqueWhereParam>,
		) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectIndexerRules(params)
		}
		pub fn set(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
			SetParam::SetIndexerRules(params)
		}
		pub enum Select {
			Select(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::SelectParam>,
			),
			Include(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::IncludeParam>,
			),
			Fetch(indexer_rules_in_location::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IndexerRules(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::SelectParam>,
			),
			Include(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::IncludeParam>,
			),
			Fetch(indexer_rules_in_location::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IndexerRules(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod is_archived {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "is_archived";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::IsArchived(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			IsArchived,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IsArchived(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsArchived(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsArchived(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsArchived(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsArchived(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsArchived(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsArchived(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod node {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node";
		pub fn is(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIs(value)
		}
		pub fn is_not(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodeIsNot(value)
		}
		pub struct Order(Vec<node::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<node::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Node(v)
			}
		}
		pub struct Fetch(pub node::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<node::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Node(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(node::UniqueArgs::new())
		}
		pub struct Connect(node::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectNode(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: node::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<node::SelectParam>),
			Include(Vec<node::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Node(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("node", None, [], selections)
			}
			pub fn select(nested_selections: Vec<node::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<node::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<node::SelectParam>),
			Include(Vec<node::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Node(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("node", None, [], selections)
			}
			pub fn select(nested_selections: Vec<node::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<node::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod node_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodeId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, NodeId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NodeId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NodeId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod path {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "path";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Path(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Path, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Path(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Path(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Path(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Path(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Path(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Path(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Path(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod sync_preview_media {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "sync_preview_media";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::SyncPreviewMedia(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			SyncPreviewMedia,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::SyncPreviewMedia(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SyncPreviewMedia(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::SyncPreviewMedia(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::SyncPreviewMedia(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SyncPreviewMedia(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SyncPreviewMedia(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SyncPreviewMedia(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod total_capacity {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_capacity";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::TotalCapacity(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			TotalCapacity,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalCapacity(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalCapacity(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalCapacity(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalCapacity(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalCapacity(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalCapacity(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalCapacity(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub name: String,
		pub path: String,
		pub node: super::node::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.location()
				.create(self.pub_id, self.name, self.path, self.node, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				pub_id::set(self.pub_id),
				name::set(self.name),
				path::set(self.path),
				node::connect(self.node),
			]);
			self._params
		}
	}
	pub fn create(
		pub_id: Vec<u8>,
		name: String,
		path: String,
		node: super::node::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			pub_id,
			name,
			path,
			node,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub node_id: i32,
		pub name: String,
		pub path: String,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.location().create_unchecked(
				self.pub_id,
				self.node_id,
				self.name,
				self.path,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				pub_id::set(self.pub_id),
				node_id::set(self.node_id),
				name::set(self.name),
				path::set(self.path),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		pub_id: Vec<u8>,
		node_id: i32,
		name: String,
		path: String,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			pub_id,
			node_id,
			name,
			path,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(node_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(path::NAME),
				::prisma_client_rust::sel(total_capacity::NAME),
				::prisma_client_rust::sel(available_capacity::NAME),
				::prisma_client_rust::sel(is_archived::NAME),
				::prisma_client_rust::sel(generate_preview_media::NAME),
				::prisma_client_rust::sel(sync_preview_media::NAME),
				::prisma_client_rust::sel(hidden::NAME),
				::prisma_client_rust::sel(date_created::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Location", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pub_id")]
		pub pub_id: Vec<u8>,
		#[serde(rename = "node_id")]
		pub node_id: i32,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "path")]
		pub path: String,
		#[serde(rename = "total_capacity")]
		pub total_capacity: Option<i32>,
		#[serde(rename = "available_capacity")]
		pub available_capacity: Option<i32>,
		#[serde(rename = "is_archived")]
		pub is_archived: bool,
		#[serde(rename = "generate_preview_media")]
		pub generate_preview_media: bool,
		#[serde(rename = "sync_preview_media")]
		pub sync_preview_media: bool,
		#[serde(rename = "hidden")]
		pub hidden: bool,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "node")]
		#[specta(skip)]
		pub node: Option<Box<super::node::Data>>,
		#[serde(rename = "file_paths")]
		#[specta(skip)]
		pub file_paths: Option<Vec<super::file_path::Data>>,
		#[serde(rename = "indexer_rules")]
		#[specta(skip)]
		pub indexer_rules: Option<Vec<super::indexer_rules_in_location::Data>>,
	}
	impl Data {
		pub fn node(
			&self,
		) -> Result<&super::node::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.node
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(node),
				))
				.map(|v| v.as_ref())
		}
		pub fn file_paths(
			&self,
		) -> Result<&Vec<super::file_path::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.file_paths
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(file_paths),
				))
		}
		pub fn indexer_rules(
			&self,
		) -> Result<
			&Vec<super::indexer_rules_in_location::Data>,
			::prisma_client_rust::RelationNotFetchedError,
		> {
			self.indexer_rules
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(indexer_rules),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_location { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: location struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "node_id")] pub node_id : i32 , # [serde (rename = "name")] pub name : String , # [serde (rename = "path")] pub path : String , # [serde (rename = "total_capacity")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub total_capacity : Option < i32 > , # [serde (rename = "available_capacity")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub available_capacity : Option < i32 > , # [serde (rename = "is_archived")] pub is_archived : bool , # [serde (rename = "generate_preview_media")] pub generate_preview_media : bool , # [serde (rename = "sync_preview_media")] pub sync_preview_media : bool , # [serde (rename = "hidden")] pub hidden : bool , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_location as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			pub_id: Vec<u8>,
			name: String,
			path: String,
			node: super::node::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				pub_id::set(pub_id),
				name::set(name),
				path::set(path),
				node::connect(node),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			node_id: i32,
			name: String,
			path: String,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				pub_id::set(pub_id),
				node_id::set(node_id),
				name::set(name),
				path::set(path),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod file_path {
	use super::_prisma::*;
	pub const NAME: &str = "FilePath";
	pub fn location_id_materialized_path_name_extension<T: From<UniqueWhereParam>>(
		location_id: i32,
		materialized_path: String,
		name: String,
		extension: String,
	) -> T {
		UniqueWhereParam::LocationIdMaterializedPathNameExtensionEquals(
			location_id,
			materialized_path,
			name,
			extension,
		)
		.into()
	}
	pub fn location_id_inode_device<T: From<UniqueWhereParam>>(
		location_id: i32,
		inode: Vec<u8>,
		device: Vec<u8>,
	) -> T {
		UniqueWhereParam::LocationIdInodeDeviceEquals(location_id, inode, device).into()
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LocationIdMaterializedPathNameExtensionEquals(i32, String, String, String),
		LocationIdInodeDeviceEquals(i32, Vec<u8>, Vec<u8>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		IsDir(super::_prisma::read_filters::BooleanFilter),
		CasId(super::_prisma::read_filters::StringNullableFilter),
		IntegrityChecksum(super::_prisma::read_filters::StringNullableFilter),
		LocationId(super::_prisma::read_filters::IntFilter),
		LocationIs(Vec<super::location::WhereParam>),
		LocationIsNot(Vec<super::location::WhereParam>),
		MaterializedPath(super::_prisma::read_filters::StringFilter),
		Name(super::_prisma::read_filters::StringFilter),
		Extension(super::_prisma::read_filters::StringFilter),
		SizeInBytes(super::_prisma::read_filters::StringFilter),
		Inode(super::_prisma::read_filters::BytesFilter),
		Device(super::_prisma::read_filters::BytesFilter),
		ObjectId(super::_prisma::read_filters::IntNullableFilter),
		ObjectIsNull,
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
		KeyId(super::_prisma::read_filters::IntNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
		DateIndexed(super::_prisma::read_filters::DateTimeFilter),
		KeyIsNull,
		KeyIs(Vec<super::key::WhereParam>),
		KeyIsNot(Vec<super::key::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::LocationIdMaterializedPathNameExtensionEquals(
					location_id,
					materialized_path,
					name,
					extension,
				) => (
					"location_id_materialized_path_name_extension",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							location_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(location_id as i64),
						),
						(
							materialized_path::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(materialized_path),
						),
						(
							name::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(name),
						),
						(
							extension::NAME.to_string(),
							::prisma_client_rust::PrismaValue::String(extension),
						),
					]),
				),
				Self::LocationIdInodeDeviceEquals(location_id, inode, device) => (
					"location_id_inode_device",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							location_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(location_id as i64),
						),
						(
							inode::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Bytes(inode),
						),
						(
							device::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Bytes(device),
						),
					]),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::IsDir(value) => (is_dir::NAME, value.into()),
				Self::CasId(value) => (cas_id::NAME, value.into()),
				Self::IntegrityChecksum(value) => (integrity_checksum::NAME, value.into()),
				Self::LocationId(value) => (location_id::NAME, value.into()),
				Self::LocationIs(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationIsNot(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::MaterializedPath(value) => (materialized_path::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Extension(value) => (extension::NAME, value.into()),
				Self::SizeInBytes(value) => (size_in_bytes::NAME, value.into()),
				Self::Inode(value) => (inode::NAME, value.into()),
				Self::Device(value) => (device::NAME, value.into()),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIsNull => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::KeyId(value) => (key_id::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::DateIndexed(value) => (date_indexed::NAME, value.into()),
				Self::KeyIsNull => (
					key::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::KeyIs(where_params) => (
					key::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::KeyIsNot(where_params) => (
					key::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IntegrityChecksumEquals(String),
		LocationIdMaterializedPathNameExtensionEquals(i32, String, String, String),
		LocationIdInodeDeviceEquals(i32, Vec<u8>, Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IntegrityChecksumEquals(value) => Self::IntegrityChecksum(
					super::_prisma::read_filters::StringNullableFilter::Equals(Some(value)),
				),
				UniqueWhereParam::LocationIdMaterializedPathNameExtensionEquals(
					location_id,
					materialized_path,
					name,
					extension,
				) => Self::LocationIdMaterializedPathNameExtensionEquals(
					location_id,
					materialized_path,
					name,
					extension,
				),
				UniqueWhereParam::LocationIdInodeDeviceEquals(location_id, inode, device) => {
					Self::LocationIdInodeDeviceEquals(location_id, inode, device)
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl ::prisma_client_rust::FromOptionalUniqueArg<integrity_checksum::Set> for WhereParam {
		type Arg = Option<String>;
		fn from_arg(arg: Self::Arg) -> Self
		where
			Self: Sized,
		{
			Self::IntegrityChecksum(super::_prisma::read_filters::StringNullableFilter::Equals(
				arg,
			))
		}
	}
	impl ::prisma_client_rust::FromOptionalUniqueArg<integrity_checksum::Set> for UniqueWhereParam {
		type Arg = String;
		fn from_arg(arg: Self::Arg) -> Self
		where
			Self: Sized,
		{
			Self::IntegrityChecksumEquals(arg)
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		IsDir(super::SortOrder),
		CasId(super::SortOrder),
		IntegrityChecksum(super::SortOrder),
		LocationId(super::SortOrder),
		MaterializedPath(super::SortOrder),
		Name(super::SortOrder),
		Extension(super::SortOrder),
		SizeInBytes(super::SortOrder),
		Inode(super::SortOrder),
		Device(super::SortOrder),
		ObjectId(super::SortOrder),
		KeyId(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		DateIndexed(super::SortOrder),
		Location(Vec<super::location::OrderByWithRelationParam>),
		Object(Vec<super::object::OrderByWithRelationParam>),
		Key(Vec<super::key::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::IsDir(param) => ("is_dir", param.into()),
				Self::CasId(param) => ("cas_id", param.into()),
				Self::IntegrityChecksum(param) => ("integrity_checksum", param.into()),
				Self::LocationId(param) => ("location_id", param.into()),
				Self::MaterializedPath(param) => ("materialized_path", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Extension(param) => ("extension", param.into()),
				Self::SizeInBytes(param) => ("size_in_bytes", param.into()),
				Self::Inode(param) => ("inode", param.into()),
				Self::Device(param) => ("device", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::KeyId(param) => ("key_id", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::DateIndexed(param) => ("date_indexed", param.into()),
				Self::Location(param) => (
					"location",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Key(param) => (
					"key",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Location(super::location::UniqueArgs),
		Object(super::object::UniqueArgs),
		Key(super::key::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Location(args) => {
					let mut selections = < super :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(location::NAME, None, [], selections)
				}
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
				Self::Key(args) => {
					let mut selections =
						<super::key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(key::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		IsDir(super::_prisma::write_params::BooleanParam),
		CasId(super::_prisma::write_params::StringNullableParam),
		IntegrityChecksum(super::_prisma::write_params::StringNullableParam),
		LocationId(super::_prisma::write_params::IntParam),
		ConnectLocation(super::location::UniqueWhereParam),
		MaterializedPath(super::_prisma::write_params::StringParam),
		Name(super::_prisma::write_params::StringParam),
		Extension(super::_prisma::write_params::StringParam),
		SizeInBytes(super::_prisma::write_params::StringParam),
		Inode(super::_prisma::write_params::BytesParam),
		Device(super::_prisma::write_params::BytesParam),
		ObjectId(super::_prisma::write_params::IntNullableParam),
		ConnectObject(super::object::UniqueWhereParam),
		DisconnectObject,
		KeyId(super::_prisma::write_params::IntNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		DateIndexed(super::_prisma::write_params::DateTimeParam),
		ConnectKey(super::key::UniqueWhereParam),
		DisconnectKey,
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::IsDir(value) => (is_dir::NAME, value.into()),
				Self::CasId(value) => (cas_id::NAME, value.into()),
				Self::IntegrityChecksum(value) => (integrity_checksum::NAME, value.into()),
				Self::LocationId(value) => (location_id::NAME, value.into()),
				Self::ConnectLocation(where_param) => (
					location::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::MaterializedPath(value) => (materialized_path::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Extension(value) => (extension::NAME, value.into()),
				Self::SizeInBytes(value) => (size_in_bytes::NAME, value.into()),
				Self::Inode(value) => (inode::NAME, value.into()),
				Self::Device(value) => (device::NAME, value.into()),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectObject => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
				Self::KeyId(value) => (key_id::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::DateIndexed(value) => (date_indexed::NAME, value.into()),
				Self::ConnectKey(where_param) => (
					key::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::key::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectKey => (
					key::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		IsDir(super::_prisma::write_params::BooleanParam),
		CasId(super::_prisma::write_params::StringNullableParam),
		IntegrityChecksum(super::_prisma::write_params::StringNullableParam),
		LocationId(super::_prisma::write_params::IntParam),
		MaterializedPath(super::_prisma::write_params::StringParam),
		Name(super::_prisma::write_params::StringParam),
		Extension(super::_prisma::write_params::StringParam),
		SizeInBytes(super::_prisma::write_params::StringParam),
		Inode(super::_prisma::write_params::BytesParam),
		Device(super::_prisma::write_params::BytesParam),
		ObjectId(super::_prisma::write_params::IntNullableParam),
		KeyId(super::_prisma::write_params::IntNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		DateIndexed(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::IsDir(value) => ("is_dir", value.into()),
				Self::CasId(value) => ("cas_id", value.into()),
				Self::IntegrityChecksum(value) => ("integrity_checksum", value.into()),
				Self::LocationId(value) => ("location_id", value.into()),
				Self::MaterializedPath(value) => ("materialized_path", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Extension(value) => ("extension", value.into()),
				Self::SizeInBytes(value) => ("size_in_bytes", value.into()),
				Self::Inode(value) => ("inode", value.into()),
				Self::Device(value) => ("device", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
				Self::KeyId(value) => ("key_id", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
				Self::DateIndexed(value) => ("date_indexed", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_file_path { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: file_path :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: file_path :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: file_path :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: file_path :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , is_dir , cas_id , integrity_checksum , location_id , location , materialized_path , name , extension , size_in_bytes , inode , device , object_id , object , key_id , date_created , date_modified , date_indexed , key } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: file_path :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: file_path :: $ field :: NAME)] pub $ field : crate :: prisma :: file_path :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: file_path :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: file_path :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: file_path :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "is_dir" , "cas_id" , "integrity_checksum" , "location_id" , "location" , "materialized_path" , "name" , "extension" , "size_in_bytes" , "inode" , "device" , "object_id" , "object" , "key_id" , "date_created" , "date_modified" , "date_indexed" , "key"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: file_path :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pub_id) => { Vec < u8 > } ; (@ field_type ; is_dir) => { bool } ; (@ field_type ; cas_id) => { Option < String > } ; (@ field_type ; integrity_checksum) => { Option < String > } ; (@ field_type ; location_id) => { i32 } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { location :: Data } ; (@ field_type ; location) => { crate :: prisma :: location :: Data } ; (@ field_type ; materialized_path) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; extension) => { String } ; (@ field_type ; size_in_bytes) => { String } ; (@ field_type ; inode) => { Vec < u8 > } ; (@ field_type ; device) => { Vec < u8 > } ; (@ field_type ; object_id) => { Option < i32 > } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; object) => { Option < crate :: prisma :: object :: Data > } ; (@ field_type ; key_id) => { Option < i32 > } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_modified) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_indexed) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < key :: Data > } ; (@ field_type ; key) => { Option < crate :: prisma :: key :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FilePath" , available relations are "id, pub_id, is_dir, cas_id, integrity_checksum, location_id, location, materialized_path, name, extension, size_in_bytes, inode, device, object_id, object, key_id, date_created, date_modified, date_indexed, key")) } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: key :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; is_dir) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: is_dir :: Select) } ; (@ selection_field_to_selection_param ; cas_id) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: cas_id :: Select) } ; (@ selection_field_to_selection_param ; integrity_checksum) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: integrity_checksum :: Select) } ; (@ selection_field_to_selection_param ; location_id) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: location_id :: Select) } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: location :: Select :: $ selection_mode (crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: location :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; materialized_path) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: materialized_path :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: name :: Select) } ; (@ selection_field_to_selection_param ; extension) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: extension :: Select) } ; (@ selection_field_to_selection_param ; size_in_bytes) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: size_in_bytes :: Select) } ; (@ selection_field_to_selection_param ; inode) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: inode :: Select) } ; (@ selection_field_to_selection_param ; device) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: device :: Select) } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: object :: Select :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; key_id) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: key_id :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; date_indexed) => { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: date_indexed :: Select) } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: key :: Select :: $ selection_mode (crate :: prisma :: key :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: file_path :: SelectParam > :: into (crate :: prisma :: file_path :: key :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: file_path :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; is_dir) => { "is_dir" } ; (@ field_serde_name ; cas_id) => { "cas_id" } ; (@ field_serde_name ; integrity_checksum) => { "integrity_checksum" } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; location) => { "location" } ; (@ field_serde_name ; materialized_path) => { "materialized_path" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; extension) => { "extension" } ; (@ field_serde_name ; size_in_bytes) => { "size_in_bytes" } ; (@ field_serde_name ; inode) => { "inode" } ; (@ field_serde_name ; device) => { "device" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ field_serde_name ; key_id) => { "key_id" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; date_indexed) => { "date_indexed" } ; (@ field_serde_name ; key) => { "key" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_file_path as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		IsDir(is_dir::Select),
		CasId(cas_id::Select),
		IntegrityChecksum(integrity_checksum::Select),
		LocationId(location_id::Select),
		Location(location::Select),
		MaterializedPath(materialized_path::Select),
		Name(name::Select),
		Extension(extension::Select),
		SizeInBytes(size_in_bytes::Select),
		Inode(inode::Select),
		Device(device::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
		KeyId(key_id::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		DateIndexed(date_indexed::Select),
		Key(key::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::IsDir(data) => data.to_selection(),
				Self::CasId(data) => data.to_selection(),
				Self::IntegrityChecksum(data) => data.to_selection(),
				Self::LocationId(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::MaterializedPath(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Extension(data) => data.to_selection(),
				Self::SizeInBytes(data) => data.to_selection(),
				Self::Inode(data) => data.to_selection(),
				Self::Device(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
				Self::KeyId(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::DateIndexed(data) => data.to_selection(),
				Self::Key(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_file_path { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: file_path :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: file_path :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: file_path :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: file_path :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: file_path :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { location , object , key } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: file_path :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: file_path :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: file_path :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: file_path :: is_dir :: NAME)] pub is_dir : bool , # [specta (rename_from_path = crate :: prisma :: file_path :: cas_id :: NAME)] pub cas_id : Option < String > , # [specta (rename_from_path = crate :: prisma :: file_path :: integrity_checksum :: NAME)] pub integrity_checksum : Option < String > , # [specta (rename_from_path = crate :: prisma :: file_path :: location_id :: NAME)] pub location_id : i32 , # [specta (rename_from_path = crate :: prisma :: file_path :: materialized_path :: NAME)] pub materialized_path : String , # [specta (rename_from_path = crate :: prisma :: file_path :: name :: NAME)] pub name : String , # [specta (rename_from_path = crate :: prisma :: file_path :: extension :: NAME)] pub extension : String , # [specta (rename_from_path = crate :: prisma :: file_path :: size_in_bytes :: NAME)] pub size_in_bytes : String , # [specta (rename_from_path = crate :: prisma :: file_path :: inode :: NAME)] pub inode : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: file_path :: device :: NAME)] pub device : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: file_path :: object_id :: NAME)] pub object_id : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: file_path :: key_id :: NAME)] pub key_id : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: file_path :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: file_path :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: file_path :: date_indexed :: NAME)] pub date_indexed : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: prisma :: file_path :: $ field :: NAME)] pub $ field : crate :: prisma :: file_path :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (is_dir) , stringify ! (cas_id) , stringify ! (integrity_checksum) , stringify ! (location_id) , stringify ! (materialized_path) , stringify ! (name) , stringify ! (extension) , stringify ! (size_in_bytes) , stringify ! (inode) , stringify ! (device) , stringify ! (object_id) , stringify ! (key_id) , stringify ! (date_created) , stringify ! (date_modified) , stringify ! (date_indexed)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: file_path :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: file_path :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: file_path :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (crate :: prisma :: file_path :: is_dir :: NAME , & self . is_dir) ? ; state . serialize_field (crate :: prisma :: file_path :: cas_id :: NAME , & self . cas_id) ? ; state . serialize_field (crate :: prisma :: file_path :: integrity_checksum :: NAME , & self . integrity_checksum) ? ; state . serialize_field (crate :: prisma :: file_path :: location_id :: NAME , & self . location_id) ? ; state . serialize_field (crate :: prisma :: file_path :: materialized_path :: NAME , & self . materialized_path) ? ; state . serialize_field (crate :: prisma :: file_path :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: file_path :: extension :: NAME , & self . extension) ? ; state . serialize_field (crate :: prisma :: file_path :: size_in_bytes :: NAME , & self . size_in_bytes) ? ; state . serialize_field (crate :: prisma :: file_path :: inode :: NAME , & self . inode) ? ; state . serialize_field (crate :: prisma :: file_path :: device :: NAME , & self . device) ? ; state . serialize_field (crate :: prisma :: file_path :: object_id :: NAME , & self . object_id) ? ; state . serialize_field (crate :: prisma :: file_path :: key_id :: NAME , & self . key_id) ? ; state . serialize_field (crate :: prisma :: file_path :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: file_path :: date_modified :: NAME , & self . date_modified) ? ; state . serialize_field (crate :: prisma :: file_path :: date_indexed :: NAME , & self . date_indexed) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , is_dir , cas_id , integrity_checksum , location_id , materialized_path , name , extension , size_in_bytes , inode , device , object_id , key_id , date_created , date_modified , date_indexed } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: file_path :: $ field :: NAME) , + , crate :: prisma :: file_path :: id :: NAME , crate :: prisma :: file_path :: pub_id :: NAME , crate :: prisma :: file_path :: is_dir :: NAME , crate :: prisma :: file_path :: cas_id :: NAME , crate :: prisma :: file_path :: integrity_checksum :: NAME , crate :: prisma :: file_path :: location_id :: NAME , crate :: prisma :: file_path :: materialized_path :: NAME , crate :: prisma :: file_path :: name :: NAME , crate :: prisma :: file_path :: extension :: NAME , crate :: prisma :: file_path :: size_in_bytes :: NAME , crate :: prisma :: file_path :: inode :: NAME , crate :: prisma :: file_path :: device :: NAME , crate :: prisma :: file_path :: object_id :: NAME , crate :: prisma :: file_path :: key_id :: NAME , crate :: prisma :: file_path :: date_created :: NAME , crate :: prisma :: file_path :: date_modified :: NAME , crate :: prisma :: file_path :: date_indexed :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: file_path :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: file_path :: id :: NAME => Ok (Field :: id) , crate :: prisma :: file_path :: pub_id :: NAME => Ok (Field :: pub_id) , crate :: prisma :: file_path :: is_dir :: NAME => Ok (Field :: is_dir) , crate :: prisma :: file_path :: cas_id :: NAME => Ok (Field :: cas_id) , crate :: prisma :: file_path :: integrity_checksum :: NAME => Ok (Field :: integrity_checksum) , crate :: prisma :: file_path :: location_id :: NAME => Ok (Field :: location_id) , crate :: prisma :: file_path :: materialized_path :: NAME => Ok (Field :: materialized_path) , crate :: prisma :: file_path :: name :: NAME => Ok (Field :: name) , crate :: prisma :: file_path :: extension :: NAME => Ok (Field :: extension) , crate :: prisma :: file_path :: size_in_bytes :: NAME => Ok (Field :: size_in_bytes) , crate :: prisma :: file_path :: inode :: NAME => Ok (Field :: inode) , crate :: prisma :: file_path :: device :: NAME => Ok (Field :: device) , crate :: prisma :: file_path :: object_id :: NAME => Ok (Field :: object_id) , crate :: prisma :: file_path :: key_id :: NAME => Ok (Field :: key_id) , crate :: prisma :: file_path :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: file_path :: date_modified :: NAME => Ok (Field :: date_modified) , crate :: prisma :: file_path :: date_indexed :: NAME => Ok (Field :: date_indexed) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut is_dir = None ; let mut cas_id = None ; let mut integrity_checksum = None ; let mut location_id = None ; let mut materialized_path = None ; let mut name = None ; let mut extension = None ; let mut size_in_bytes = None ; let mut inode = None ; let mut device = None ; let mut object_id = None ; let mut key_id = None ; let mut date_created = None ; let mut date_modified = None ; let mut date_indexed = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: is_dir => { if is_dir . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: is_dir :: NAME)) ; } is_dir = Some (map . next_value () ?) ; } Field :: cas_id => { if cas_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: cas_id :: NAME)) ; } cas_id = Some (map . next_value () ?) ; } Field :: integrity_checksum => { if integrity_checksum . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: integrity_checksum :: NAME)) ; } integrity_checksum = Some (map . next_value () ?) ; } Field :: location_id => { if location_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: location_id :: NAME)) ; } location_id = Some (map . next_value () ?) ; } Field :: materialized_path => { if materialized_path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: materialized_path :: NAME)) ; } materialized_path = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: extension => { if extension . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: extension :: NAME)) ; } extension = Some (map . next_value () ?) ; } Field :: size_in_bytes => { if size_in_bytes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: size_in_bytes :: NAME)) ; } size_in_bytes = Some (map . next_value () ?) ; } Field :: inode => { if inode . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: inode :: NAME)) ; } inode = Some (map . next_value () ?) ; } Field :: device => { if device . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: device :: NAME)) ; } device = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } Field :: key_id => { if key_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: key_id :: NAME)) ; } key_id = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } Field :: date_indexed => { if date_indexed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: date_indexed :: NAME)) ; } date_indexed = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_path :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: pub_id :: NAME)) ? ; let is_dir = is_dir . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: is_dir :: NAME)) ? ; let cas_id = cas_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: cas_id :: NAME)) ? ; let integrity_checksum = integrity_checksum . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: integrity_checksum :: NAME)) ? ; let location_id = location_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: location_id :: NAME)) ? ; let materialized_path = materialized_path . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: materialized_path :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: name :: NAME)) ? ; let extension = extension . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: extension :: NAME)) ? ; let size_in_bytes = size_in_bytes . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: size_in_bytes :: NAME)) ? ; let inode = inode . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: inode :: NAME)) ? ; let device = device . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: device :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: object_id :: NAME)) ? ; let key_id = key_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: key_id :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: date_modified :: NAME)) ? ; let date_indexed = date_indexed . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_path :: date_indexed :: NAME)) ? ; Ok (Data { id , pub_id , is_dir , cas_id , integrity_checksum , location_id , materialized_path , name , extension , size_in_bytes , inode , device , object_id , key_id , date_created , date_modified , date_indexed , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "is_dir" , "cas_id" , "integrity_checksum" , "location_id" , "location" , "materialized_path" , "name" , "extension" , "size_in_bytes" , "inode" , "device" , "object_id" , "object" , "key_id" , "date_created" , "date_modified" , "date_indexed" , "key"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: file_path :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { location :: Data } ; (@ field_type ; location) => { crate :: prisma :: location :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; object) => { Option < crate :: prisma :: object :: Data > } ; (@ field_type ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < key :: Data > } ; (@ field_type ; key) => { Option < crate :: prisma :: key :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FilePath" , available relations are "location, object, key")) } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: key :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: file_path :: IncludeParam > :: into (crate :: prisma :: file_path :: location :: Include :: $ selection_mode (crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: file_path :: IncludeParam > :: into (crate :: prisma :: file_path :: location :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: file_path :: IncludeParam > :: into (crate :: prisma :: file_path :: object :: Include :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: file_path :: IncludeParam > :: into (crate :: prisma :: file_path :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: file_path :: IncludeParam > :: into (crate :: prisma :: file_path :: key :: Include :: $ selection_mode (crate :: prisma :: key :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: file_path :: IncludeParam > :: into (crate :: prisma :: file_path :: key :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: file_path :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; is_dir) => { "is_dir" } ; (@ field_serde_name ; cas_id) => { "cas_id" } ; (@ field_serde_name ; integrity_checksum) => { "integrity_checksum" } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; location) => { "location" } ; (@ field_serde_name ; materialized_path) => { "materialized_path" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; extension) => { "extension" } ; (@ field_serde_name ; size_in_bytes) => { "size_in_bytes" } ; (@ field_serde_name ; inode) => { "inode" } ; (@ field_serde_name ; device) => { "device" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ field_serde_name ; key_id) => { "key_id" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; date_indexed) => { "date_indexed" } ; (@ field_serde_name ; key) => { "key" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_file_path as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		IsDir(is_dir::Include),
		CasId(cas_id::Include),
		IntegrityChecksum(integrity_checksum::Include),
		LocationId(location_id::Include),
		Location(location::Include),
		MaterializedPath(materialized_path::Include),
		Name(name::Include),
		Extension(extension::Include),
		SizeInBytes(size_in_bytes::Include),
		Inode(inode::Include),
		Device(device::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
		KeyId(key_id::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		DateIndexed(date_indexed::Include),
		Key(key::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::IsDir(data) => data.to_selection(),
				Self::CasId(data) => data.to_selection(),
				Self::IntegrityChecksum(data) => data.to_selection(),
				Self::LocationId(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::MaterializedPath(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Extension(data) => data.to_selection(),
				Self::SizeInBytes(data) => data.to_selection(),
				Self::Inode(data) => data.to_selection(),
				Self::Device(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
				Self::KeyId(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::DateIndexed(data) => data.to_selection(),
				Self::Key(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod cas_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "cas_id";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::CasId(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			CasId,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::CasId(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CasId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::CasId(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::CasId(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CasId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CasId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CasId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_indexed {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_indexed";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateIndexed(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateIndexed,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateIndexed(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateIndexed(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateIndexed(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateIndexed(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateIndexed(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateIndexed(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateIndexed(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod device {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "device";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::Device(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			Device,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Device(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Device(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Device(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Device(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Device(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Device(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Device(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod extension {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "extension";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Extension(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			Extension,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Extension(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Extension(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Extension(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Extension(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Extension(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Extension(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Extension(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod inode {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "inode";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::Inode(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Inode, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Inode(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Inode(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Inode(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Inode(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Inode(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Inode(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Inode(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod integrity_checksum {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "integrity_checksum";
		pub fn equals<A, T: ::prisma_client_rust::FromOptionalUniqueArg<Set, Arg = A>>(
			value: A,
		) -> T {
			T::from_arg(value)
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			IntegrityChecksum,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IntegrityChecksum(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IntegrityChecksum(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IntegrityChecksum(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IntegrityChecksum(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IntegrityChecksum(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IntegrityChecksum(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IntegrityChecksum(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod is_dir {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "is_dir";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::IsDir(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			IsDir,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IsDir(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsDir(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsDir(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsDir(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsDir(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsDir(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsDir(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod key {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key";
		pub fn is(value: Vec<key::WhereParam>) -> WhereParam {
			WhereParam::KeyIs(value)
		}
		pub fn is_not(value: Vec<key::WhereParam>) -> WhereParam {
			WhereParam::KeyIsNot(value)
		}
		pub struct Order(Vec<key::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<key::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Key(v)
			}
		}
		pub struct Fetch(pub key::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<key::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Key(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(key::UniqueArgs::new())
		}
		pub struct Connect(key::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectKey(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: key::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectKey
		}
		pub fn is_null() -> WhereParam {
			WhereParam::KeyIsNull
		}
		pub enum Select {
			Select(Vec<key::SelectParam>),
			Include(Vec<key::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Key(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("key", None, [], selections)
			}
			pub fn select(nested_selections: Vec<key::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<key::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<key::SelectParam>),
			Include(Vec<key::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Key(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("key", None, [], selections)
			}
			pub fn select(nested_selections: Vec<key::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<key::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod key_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key_id";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::KeyId(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			KeyId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::KeyId(v)
			}
		}
		pub struct Set(pub Option<i32>);
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::KeyId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::KeyId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod location {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "location";
		pub fn is(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIs(value)
		}
		pub fn is_not(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIsNot(value)
		}
		pub struct Order(Vec<location::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<location::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Location(v)
			}
		}
		pub struct Fetch(pub location::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<location::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Location(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(location::UniqueArgs::new())
		}
		pub struct Connect(location::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLocation(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: location::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<location::SelectParam>),
			Include(Vec<location::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Location(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("location", None, [], selections)
			}
			pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<location::SelectParam>),
			Include(Vec<location::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Location(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = < location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("location", None, [], selections)
			}
			pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod location_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "location_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::LocationId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			LocationId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LocationId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LocationId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LocationId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LocationId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LocationId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod materialized_path {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "materialized_path";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::MaterializedPath(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			MaterializedPath,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::MaterializedPath(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MaterializedPath(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::MaterializedPath(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::MaterializedPath(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MaterializedPath(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::MaterializedPath(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::MaterializedPath(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectObject
		}
		pub fn is_null() -> WhereParam {
			WhereParam::ObjectIsNull
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub Option<i32>);
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod size_in_bytes {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "size_in_bytes";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::SizeInBytes(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			SizeInBytes,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::SizeInBytes(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SizeInBytes(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::SizeInBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::SizeInBytes(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SizeInBytes(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SizeInBytes(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SizeInBytes(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub location: super::location::UniqueWhereParam,
		pub materialized_path: String,
		pub name: String,
		pub extension: String,
		pub inode: Vec<u8>,
		pub device: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.file_path().create(
				self.pub_id,
				self.location,
				self.materialized_path,
				self.name,
				self.extension,
				self.inode,
				self.device,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				pub_id::set(self.pub_id),
				location::connect(self.location),
				materialized_path::set(self.materialized_path),
				name::set(self.name),
				extension::set(self.extension),
				inode::set(self.inode),
				device::set(self.device),
			]);
			self._params
		}
	}
	pub fn create(
		pub_id: Vec<u8>,
		location: super::location::UniqueWhereParam,
		materialized_path: String,
		name: String,
		extension: String,
		inode: Vec<u8>,
		device: Vec<u8>,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			pub_id,
			location,
			materialized_path,
			name,
			extension,
			inode,
			device,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub location_id: i32,
		pub materialized_path: String,
		pub name: String,
		pub extension: String,
		pub inode: Vec<u8>,
		pub device: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.file_path().create_unchecked(
				self.pub_id,
				self.location_id,
				self.materialized_path,
				self.name,
				self.extension,
				self.inode,
				self.device,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				pub_id::set(self.pub_id),
				location_id::set(self.location_id),
				materialized_path::set(self.materialized_path),
				name::set(self.name),
				extension::set(self.extension),
				inode::set(self.inode),
				device::set(self.device),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		pub_id: Vec<u8>,
		location_id: i32,
		materialized_path: String,
		name: String,
		extension: String,
		inode: Vec<u8>,
		device: Vec<u8>,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			pub_id,
			location_id,
			materialized_path,
			name,
			extension,
			inode,
			device,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(is_dir::NAME),
				::prisma_client_rust::sel(cas_id::NAME),
				::prisma_client_rust::sel(integrity_checksum::NAME),
				::prisma_client_rust::sel(location_id::NAME),
				::prisma_client_rust::sel(materialized_path::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(extension::NAME),
				::prisma_client_rust::sel(size_in_bytes::NAME),
				::prisma_client_rust::sel(inode::NAME),
				::prisma_client_rust::sel(device::NAME),
				::prisma_client_rust::sel(object_id::NAME),
				::prisma_client_rust::sel(key_id::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
				::prisma_client_rust::sel(date_indexed::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "FilePath", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pub_id")]
		pub pub_id: Vec<u8>,
		#[serde(rename = "is_dir")]
		pub is_dir: bool,
		#[serde(rename = "cas_id")]
		pub cas_id: Option<String>,
		#[serde(rename = "integrity_checksum")]
		pub integrity_checksum: Option<String>,
		#[serde(rename = "location_id")]
		pub location_id: i32,
		#[serde(rename = "location")]
		#[specta(skip)]
		pub location: Option<Box<super::location::Data>>,
		#[serde(rename = "materialized_path")]
		pub materialized_path: String,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "extension")]
		pub extension: String,
		#[serde(rename = "size_in_bytes")]
		pub size_in_bytes: String,
		#[serde(rename = "inode")]
		pub inode: Vec<u8>,
		#[serde(rename = "device")]
		pub device: Vec<u8>,
		#[serde(rename = "object_id")]
		pub object_id: Option<i32>,
		#[serde(
			rename = "object",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub object: Option<Option<Box<super::object::Data>>>,
		#[serde(rename = "key_id")]
		pub key_id: Option<i32>,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_modified")]
		pub date_modified:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_indexed")]
		pub date_indexed:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(
			rename = "key",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub key: Option<Option<Box<super::key::Data>>>,
	}
	impl Data {
		pub fn location(
			&self,
		) -> Result<&super::location::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.location
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(location),
				))
				.map(|v| v.as_ref())
		}
		pub fn object(
			&self,
		) -> Result<Option<&super::object::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
		pub fn key(
			&self,
		) -> Result<Option<&super::key::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.key
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(key),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_file_path { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: file_path struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "is_dir")] pub is_dir : bool , # [serde (rename = "cas_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub cas_id : Option < String > , # [serde (rename = "integrity_checksum")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub integrity_checksum : Option < String > , # [serde (rename = "location_id")] pub location_id : i32 , # [serde (rename = "materialized_path")] pub materialized_path : String , # [serde (rename = "name")] pub name : String , # [serde (rename = "extension")] pub extension : String , # [serde (rename = "size_in_bytes")] pub size_in_bytes : String , # [serde (rename = "inode")] pub inode : Vec < u8 > , # [serde (rename = "device")] pub device : Vec < u8 > , # [serde (rename = "object_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub object_id : Option < i32 > , # [serde (rename = "key_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub key_id : Option < i32 > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_indexed")] pub date_indexed : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_file_path as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			pub_id: Vec<u8>,
			location: super::location::UniqueWhereParam,
			materialized_path: String,
			name: String,
			extension: String,
			inode: Vec<u8>,
			device: Vec<u8>,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				pub_id::set(pub_id),
				location::connect(location),
				materialized_path::set(materialized_path),
				name::set(name),
				extension::set(extension),
				inode::set(inode),
				device::set(device),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			location_id: i32,
			materialized_path: String,
			name: String,
			extension: String,
			inode: Vec<u8>,
			device: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				pub_id::set(pub_id),
				location_id::set(location_id),
				materialized_path::set(materialized_path),
				name::set(name),
				extension::set(extension),
				inode::set(inode),
				device::set(device),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod object {
	use super::_prisma::*;
	pub const NAME: &str = "Object";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Kind(super::_prisma::read_filters::IntFilter),
		KeyId(super::_prisma::read_filters::IntNullableFilter),
		Hidden(super::_prisma::read_filters::BooleanFilter),
		Favorite(super::_prisma::read_filters::BooleanFilter),
		Important(super::_prisma::read_filters::BooleanFilter),
		HasThumbnail(super::_prisma::read_filters::BooleanFilter),
		HasThumbstrip(super::_prisma::read_filters::BooleanFilter),
		HasVideoPreview(super::_prisma::read_filters::BooleanFilter),
		IpfsId(super::_prisma::read_filters::StringNullableFilter),
		Note(super::_prisma::read_filters::StringNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateAccessed(super::_prisma::read_filters::DateTimeNullableFilter),
		TagsSome(Vec<super::tag_on_object::WhereParam>),
		TagsEvery(Vec<super::tag_on_object::WhereParam>),
		TagsNone(Vec<super::tag_on_object::WhereParam>),
		LabelsSome(Vec<super::label_on_object::WhereParam>),
		LabelsEvery(Vec<super::label_on_object::WhereParam>),
		LabelsNone(Vec<super::label_on_object::WhereParam>),
		AlbumsSome(Vec<super::object_in_album::WhereParam>),
		AlbumsEvery(Vec<super::object_in_album::WhereParam>),
		AlbumsNone(Vec<super::object_in_album::WhereParam>),
		SpacesSome(Vec<super::object_in_space::WhereParam>),
		SpacesEvery(Vec<super::object_in_space::WhereParam>),
		SpacesNone(Vec<super::object_in_space::WhereParam>),
		FilePathsSome(Vec<super::file_path::WhereParam>),
		FilePathsEvery(Vec<super::file_path::WhereParam>),
		FilePathsNone(Vec<super::file_path::WhereParam>),
		CommentsSome(Vec<super::comment::WhereParam>),
		CommentsEvery(Vec<super::comment::WhereParam>),
		CommentsNone(Vec<super::comment::WhereParam>),
		MediaDataIsNull,
		MediaDataIs(Vec<super::media_data::WhereParam>),
		MediaDataIsNot(Vec<super::media_data::WhereParam>),
		KeyIsNull,
		KeyIs(Vec<super::key::WhereParam>),
		KeyIsNot(Vec<super::key::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Kind(value) => (kind::NAME, value.into()),
				Self::KeyId(value) => (key_id::NAME, value.into()),
				Self::Hidden(value) => (hidden::NAME, value.into()),
				Self::Favorite(value) => (favorite::NAME, value.into()),
				Self::Important(value) => (important::NAME, value.into()),
				Self::HasThumbnail(value) => (has_thumbnail::NAME, value.into()),
				Self::HasThumbstrip(value) => (has_thumbstrip::NAME, value.into()),
				Self::HasVideoPreview(value) => (has_video_preview::NAME, value.into()),
				Self::IpfsId(value) => (ipfs_id::NAME, value.into()),
				Self::Note(value) => (note::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateAccessed(value) => (date_accessed::NAME, value.into()),
				Self::TagsSome(where_params) => (
					tags::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagsEvery(where_params) => (
					tags::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagsNone(where_params) => (
					tags::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelsSome(where_params) => (
					labels::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelsEvery(where_params) => (
					labels::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelsNone(where_params) => (
					labels::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::AlbumsSome(where_params) => (
					albums::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::AlbumsEvery(where_params) => (
					albums::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::AlbumsNone(where_params) => (
					albums::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SpacesSome(where_params) => (
					spaces::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SpacesEvery(where_params) => (
					spaces::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SpacesNone(where_params) => (
					spaces::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsSome(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsEvery(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsNone(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CommentsSome(where_params) => (
					comments::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CommentsEvery(where_params) => (
					comments::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::CommentsNone(where_params) => (
					comments::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::MediaDataIsNull => (
					media_data::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::MediaDataIs(where_params) => (
					media_data::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::MediaDataIsNot(where_params) => (
					media_data::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::KeyIsNull => (
					key::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::KeyIs(where_params) => (
					key::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::KeyIsNot(where_params) => (
					key::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Kind(super::SortOrder),
		KeyId(super::SortOrder),
		Hidden(super::SortOrder),
		Favorite(super::SortOrder),
		Important(super::SortOrder),
		HasThumbnail(super::SortOrder),
		HasThumbstrip(super::SortOrder),
		HasVideoPreview(super::SortOrder),
		IpfsId(super::SortOrder),
		Note(super::SortOrder),
		DateCreated(super::SortOrder),
		DateAccessed(super::SortOrder),
		Tags(Vec<super::tag_on_object::OrderByRelationAggregateParam>),
		Labels(Vec<super::label_on_object::OrderByRelationAggregateParam>),
		Albums(Vec<super::object_in_album::OrderByRelationAggregateParam>),
		Spaces(Vec<super::object_in_space::OrderByRelationAggregateParam>),
		FilePaths(Vec<super::file_path::OrderByRelationAggregateParam>),
		Comments(Vec<super::comment::OrderByRelationAggregateParam>),
		MediaData(Vec<super::media_data::OrderByWithRelationParam>),
		Key(Vec<super::key::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Kind(param) => ("kind", param.into()),
				Self::KeyId(param) => ("key_id", param.into()),
				Self::Hidden(param) => ("hidden", param.into()),
				Self::Favorite(param) => ("favorite", param.into()),
				Self::Important(param) => ("important", param.into()),
				Self::HasThumbnail(param) => ("has_thumbnail", param.into()),
				Self::HasThumbstrip(param) => ("has_thumbstrip", param.into()),
				Self::HasVideoPreview(param) => ("has_video_preview", param.into()),
				Self::IpfsId(param) => ("ipfs_id", param.into()),
				Self::Note(param) => ("note", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateAccessed(param) => ("date_accessed", param.into()),
				Self::Tags(param) => (
					"tags",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Labels(param) => (
					"labels",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Albums(param) => (
					"albums",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Spaces(param) => (
					"spaces",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::FilePaths(param) => (
					"file_paths",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Comments(param) => (
					"comments",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::MediaData(param) => (
					"media_data",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Key(param) => (
					"key",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Tags(super::tag_on_object::ManyArgs),
		Labels(super::label_on_object::ManyArgs),
		Albums(super::object_in_album::ManyArgs),
		Spaces(super::object_in_space::ManyArgs),
		FilePaths(super::file_path::ManyArgs),
		Comments(super::comment::ManyArgs),
		MediaData(super::media_data::UniqueArgs),
		Key(super::key::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Tags(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						tags::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::Labels(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						labels::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::Albums(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						albums::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::Spaces(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						spaces::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::FilePaths(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						file_paths::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::Comments(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: comment :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						comments::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::MediaData(args) => {
					let mut selections = < super :: media_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(media_data::NAME, None, [], selections)
				}
				Self::Key(args) => {
					let mut selections =
						<super::key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(key::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Kind(super::_prisma::write_params::IntParam),
		KeyId(super::_prisma::write_params::IntNullableParam),
		Hidden(super::_prisma::write_params::BooleanParam),
		Favorite(super::_prisma::write_params::BooleanParam),
		Important(super::_prisma::write_params::BooleanParam),
		HasThumbnail(super::_prisma::write_params::BooleanParam),
		HasThumbstrip(super::_prisma::write_params::BooleanParam),
		HasVideoPreview(super::_prisma::write_params::BooleanParam),
		IpfsId(super::_prisma::write_params::StringNullableParam),
		Note(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateAccessed(super::_prisma::write_params::DateTimeNullableParam),
		ConnectTags(Vec<super::tag_on_object::UniqueWhereParam>),
		DisconnectTags(Vec<super::tag_on_object::UniqueWhereParam>),
		SetTags(Vec<super::tag_on_object::UniqueWhereParam>),
		ConnectLabels(Vec<super::label_on_object::UniqueWhereParam>),
		DisconnectLabels(Vec<super::label_on_object::UniqueWhereParam>),
		SetLabels(Vec<super::label_on_object::UniqueWhereParam>),
		ConnectAlbums(Vec<super::object_in_album::UniqueWhereParam>),
		DisconnectAlbums(Vec<super::object_in_album::UniqueWhereParam>),
		SetAlbums(Vec<super::object_in_album::UniqueWhereParam>),
		ConnectSpaces(Vec<super::object_in_space::UniqueWhereParam>),
		DisconnectSpaces(Vec<super::object_in_space::UniqueWhereParam>),
		SetSpaces(Vec<super::object_in_space::UniqueWhereParam>),
		ConnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		DisconnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		SetFilePaths(Vec<super::file_path::UniqueWhereParam>),
		ConnectComments(Vec<super::comment::UniqueWhereParam>),
		DisconnectComments(Vec<super::comment::UniqueWhereParam>),
		SetComments(Vec<super::comment::UniqueWhereParam>),
		ConnectMediaData(super::media_data::UniqueWhereParam),
		DisconnectMediaData,
		ConnectKey(super::key::UniqueWhereParam),
		DisconnectKey,
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Kind(value) => (kind::NAME, value.into()),
				Self::KeyId(value) => (key_id::NAME, value.into()),
				Self::Hidden(value) => (hidden::NAME, value.into()),
				Self::Favorite(value) => (favorite::NAME, value.into()),
				Self::Important(value) => (important::NAME, value.into()),
				Self::HasThumbnail(value) => (has_thumbnail::NAME, value.into()),
				Self::HasThumbstrip(value) => (has_thumbstrip::NAME, value.into()),
				Self::HasVideoPreview(value) => (has_video_preview::NAME, value.into()),
				Self::IpfsId(value) => (ipfs_id::NAME, value.into()),
				Self::Note(value) => (note::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateAccessed(value) => (date_accessed::NAME, value.into()),
				Self::ConnectTags(where_params) => (
					tags::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectTags(where_params) => (
					tags::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetTags(where_params) => (
					tags::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectLabels(where_params) => (
					labels::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectLabels(where_params) => (
					labels::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetLabels(where_params) => (
					labels::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectAlbums(where_params) => (
					albums::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_album::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectAlbums(where_params) => (
					albums::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_album::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetAlbums(where_params) => (
					albums::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_album::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectSpaces(where_params) => (
					spaces::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectSpaces(where_params) => (
					spaces::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetSpaces(where_params) => (
					spaces::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectComments(where_params) => (
					comments::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectComments(where_params) => (
					comments::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetComments(where_params) => (
					comments::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::comment::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectMediaData(where_param) => (
					media_data::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::media_data::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectMediaData => (
					media_data::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
				Self::ConnectKey(where_param) => (
					key::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::key::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectKey => (
					key::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Kind(super::_prisma::write_params::IntParam),
		KeyId(super::_prisma::write_params::IntNullableParam),
		Hidden(super::_prisma::write_params::BooleanParam),
		Favorite(super::_prisma::write_params::BooleanParam),
		Important(super::_prisma::write_params::BooleanParam),
		HasThumbnail(super::_prisma::write_params::BooleanParam),
		HasThumbstrip(super::_prisma::write_params::BooleanParam),
		HasVideoPreview(super::_prisma::write_params::BooleanParam),
		IpfsId(super::_prisma::write_params::StringNullableParam),
		Note(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateAccessed(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Kind(value) => ("kind", value.into()),
				Self::KeyId(value) => ("key_id", value.into()),
				Self::Hidden(value) => ("hidden", value.into()),
				Self::Favorite(value) => ("favorite", value.into()),
				Self::Important(value) => ("important", value.into()),
				Self::HasThumbnail(value) => ("has_thumbnail", value.into()),
				Self::HasThumbstrip(value) => ("has_thumbstrip", value.into()),
				Self::HasVideoPreview(value) => ("has_video_preview", value.into()),
				Self::IpfsId(value) => ("ipfs_id", value.into()),
				Self::Note(value) => ("note", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateAccessed(value) => ("date_accessed", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: object :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: object :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , kind , key_id , hidden , favorite , important , has_thumbnail , has_thumbstrip , has_video_preview , ipfs_id , note , date_created , date_accessed , tags , labels , albums , spaces , file_paths , comments , media_data , key } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: object :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: object :: $ field :: NAME)] pub $ field : crate :: prisma :: object :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: object :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: object :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: object :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "kind" , "key_id" , "hidden" , "favorite" , "important" , "has_thumbnail" , "has_thumbstrip" , "has_video_preview" , "ipfs_id" , "note" , "date_created" , "date_accessed" , "tags" , "labels" , "albums" , "spaces" , "file_paths" , "comments" , "media_data" , "key"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pub_id) => { Vec < u8 > } ; (@ field_type ; kind) => { i32 } ; (@ field_type ; key_id) => { Option < i32 > } ; (@ field_type ; hidden) => { bool } ; (@ field_type ; favorite) => { bool } ; (@ field_type ; important) => { bool } ; (@ field_type ; has_thumbnail) => { bool } ; (@ field_type ; has_thumbstrip) => { bool } ; (@ field_type ; has_video_preview) => { bool } ; (@ field_type ; ipfs_id) => { Option < String > } ; (@ field_type ; note) => { Option < String > } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_accessed) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tags :: Data > } ; (@ field_type ; tags) => { Vec < crate :: prisma :: tag_on_object :: Data > } ; (@ field_type ; labels : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < labels :: Data > } ; (@ field_type ; labels) => { Vec < crate :: prisma :: label_on_object :: Data > } ; (@ field_type ; albums : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < albums :: Data > } ; (@ field_type ; albums) => { Vec < crate :: prisma :: object_in_album :: Data > } ; (@ field_type ; spaces : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < spaces :: Data > } ; (@ field_type ; spaces) => { Vec < crate :: prisma :: object_in_space :: Data > } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; file_paths) => { Vec < crate :: prisma :: file_path :: Data > } ; (@ field_type ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < comments :: Data > } ; (@ field_type ; comments) => { Vec < crate :: prisma :: comment :: Data > } ; (@ field_type ; media_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < media_data :: Data > } ; (@ field_type ; media_data) => { Option < crate :: prisma :: media_data :: Data > } ; (@ field_type ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < key :: Data > } ; (@ field_type ; key) => { Option < crate :: prisma :: key :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Object" , available relations are "id, pub_id, kind, key_id, hidden, favorite, important, has_thumbnail, has_thumbstrip, has_video_preview, ipfs_id, note, date_created, date_accessed, tags, labels, albums, spaces, file_paths, comments, media_data, key")) } ; (@ field_module ; tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: tag_on_object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; labels : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: label_on_object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; albums : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object_in_album :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; spaces : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object_in_space :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: file_path :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: comment :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; media_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: media_data :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: key :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; kind) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: kind :: Select) } ; (@ selection_field_to_selection_param ; key_id) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: key_id :: Select) } ; (@ selection_field_to_selection_param ; hidden) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: hidden :: Select) } ; (@ selection_field_to_selection_param ; favorite) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: favorite :: Select) } ; (@ selection_field_to_selection_param ; important) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: important :: Select) } ; (@ selection_field_to_selection_param ; has_thumbnail) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: has_thumbnail :: Select) } ; (@ selection_field_to_selection_param ; has_thumbstrip) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: has_thumbstrip :: Select) } ; (@ selection_field_to_selection_param ; has_video_preview) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: has_video_preview :: Select) } ; (@ selection_field_to_selection_param ; ipfs_id) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: ipfs_id :: Select) } ; (@ selection_field_to_selection_param ; note) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: note :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_accessed) => { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: date_accessed :: Select) } ; (@ selection_field_to_selection_param ; tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: tags :: Select :: $ selection_mode (crate :: prisma :: tag_on_object :: ManyArgs :: new (crate :: prisma :: tag_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: tags :: Select :: Fetch (crate :: prisma :: tag_on_object :: ManyArgs :: new (crate :: prisma :: tag_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; labels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: labels :: Select :: $ selection_mode (crate :: prisma :: label_on_object :: ManyArgs :: new (crate :: prisma :: label_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: label_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; labels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: labels :: Select :: Fetch (crate :: prisma :: label_on_object :: ManyArgs :: new (crate :: prisma :: label_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; albums $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: albums :: Select :: $ selection_mode (crate :: prisma :: object_in_album :: ManyArgs :: new (crate :: prisma :: object_in_album :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object_in_album :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; albums $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: albums :: Select :: Fetch (crate :: prisma :: object_in_album :: ManyArgs :: new (crate :: prisma :: object_in_album :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; spaces $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: spaces :: Select :: $ selection_mode (crate :: prisma :: object_in_space :: ManyArgs :: new (crate :: prisma :: object_in_space :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object_in_space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; spaces $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: spaces :: Select :: Fetch (crate :: prisma :: object_in_space :: ManyArgs :: new (crate :: prisma :: object_in_space :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: file_paths :: Select :: $ selection_mode (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: file_paths :: Select :: Fetch (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: comments :: Select :: $ selection_mode (crate :: prisma :: comment :: ManyArgs :: new (crate :: prisma :: comment :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: comment :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: comments :: Select :: Fetch (crate :: prisma :: comment :: ManyArgs :: new (crate :: prisma :: comment :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; media_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: media_data :: Select :: $ selection_mode (crate :: prisma :: media_data :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; media_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: media_data :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: key :: Select :: $ selection_mode (crate :: prisma :: key :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: SelectParam > :: into (crate :: prisma :: object :: key :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; key_id) => { "key_id" } ; (@ field_serde_name ; hidden) => { "hidden" } ; (@ field_serde_name ; favorite) => { "favorite" } ; (@ field_serde_name ; important) => { "important" } ; (@ field_serde_name ; has_thumbnail) => { "has_thumbnail" } ; (@ field_serde_name ; has_thumbstrip) => { "has_thumbstrip" } ; (@ field_serde_name ; has_video_preview) => { "has_video_preview" } ; (@ field_serde_name ; ipfs_id) => { "ipfs_id" } ; (@ field_serde_name ; note) => { "note" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_accessed) => { "date_accessed" } ; (@ field_serde_name ; tags) => { "tags" } ; (@ field_serde_name ; labels) => { "labels" } ; (@ field_serde_name ; albums) => { "albums" } ; (@ field_serde_name ; spaces) => { "spaces" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ field_serde_name ; comments) => { "comments" } ; (@ field_serde_name ; media_data) => { "media_data" } ; (@ field_serde_name ; key) => { "key" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_object as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Kind(kind::Select),
		KeyId(key_id::Select),
		Hidden(hidden::Select),
		Favorite(favorite::Select),
		Important(important::Select),
		HasThumbnail(has_thumbnail::Select),
		HasThumbstrip(has_thumbstrip::Select),
		HasVideoPreview(has_video_preview::Select),
		IpfsId(ipfs_id::Select),
		Note(note::Select),
		DateCreated(date_created::Select),
		DateAccessed(date_accessed::Select),
		Tags(tags::Select),
		Labels(labels::Select),
		Albums(albums::Select),
		Spaces(spaces::Select),
		FilePaths(file_paths::Select),
		Comments(comments::Select),
		MediaData(media_data::Select),
		Key(key::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Kind(data) => data.to_selection(),
				Self::KeyId(data) => data.to_selection(),
				Self::Hidden(data) => data.to_selection(),
				Self::Favorite(data) => data.to_selection(),
				Self::Important(data) => data.to_selection(),
				Self::HasThumbnail(data) => data.to_selection(),
				Self::HasThumbstrip(data) => data.to_selection(),
				Self::HasVideoPreview(data) => data.to_selection(),
				Self::IpfsId(data) => data.to_selection(),
				Self::Note(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateAccessed(data) => data.to_selection(),
				Self::Tags(data) => data.to_selection(),
				Self::Labels(data) => data.to_selection(),
				Self::Albums(data) => data.to_selection(),
				Self::Spaces(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
				Self::Comments(data) => data.to_selection(),
				Self::MediaData(data) => data.to_selection(),
				Self::Key(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: object :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: object :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { tags , labels , albums , spaces , file_paths , comments , media_data , key } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: object :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: object :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: object :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: object :: kind :: NAME)] pub kind : i32 , # [specta (rename_from_path = crate :: prisma :: object :: key_id :: NAME)] pub key_id : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: object :: hidden :: NAME)] pub hidden : bool , # [specta (rename_from_path = crate :: prisma :: object :: favorite :: NAME)] pub favorite : bool , # [specta (rename_from_path = crate :: prisma :: object :: important :: NAME)] pub important : bool , # [specta (rename_from_path = crate :: prisma :: object :: has_thumbnail :: NAME)] pub has_thumbnail : bool , # [specta (rename_from_path = crate :: prisma :: object :: has_thumbstrip :: NAME)] pub has_thumbstrip : bool , # [specta (rename_from_path = crate :: prisma :: object :: has_video_preview :: NAME)] pub has_video_preview : bool , # [specta (rename_from_path = crate :: prisma :: object :: ipfs_id :: NAME)] pub ipfs_id : Option < String > , # [specta (rename_from_path = crate :: prisma :: object :: note :: NAME)] pub note : Option < String > , # [specta (rename_from_path = crate :: prisma :: object :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: object :: date_accessed :: NAME)] pub date_accessed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (# [specta (rename_from_path = crate :: prisma :: object :: $ field :: NAME)] pub $ field : crate :: prisma :: object :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (kind) , stringify ! (key_id) , stringify ! (hidden) , stringify ! (favorite) , stringify ! (important) , stringify ! (has_thumbnail) , stringify ! (has_thumbstrip) , stringify ! (has_video_preview) , stringify ! (ipfs_id) , stringify ! (note) , stringify ! (date_created) , stringify ! (date_accessed)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: object :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: object :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: object :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (crate :: prisma :: object :: kind :: NAME , & self . kind) ? ; state . serialize_field (crate :: prisma :: object :: key_id :: NAME , & self . key_id) ? ; state . serialize_field (crate :: prisma :: object :: hidden :: NAME , & self . hidden) ? ; state . serialize_field (crate :: prisma :: object :: favorite :: NAME , & self . favorite) ? ; state . serialize_field (crate :: prisma :: object :: important :: NAME , & self . important) ? ; state . serialize_field (crate :: prisma :: object :: has_thumbnail :: NAME , & self . has_thumbnail) ? ; state . serialize_field (crate :: prisma :: object :: has_thumbstrip :: NAME , & self . has_thumbstrip) ? ; state . serialize_field (crate :: prisma :: object :: has_video_preview :: NAME , & self . has_video_preview) ? ; state . serialize_field (crate :: prisma :: object :: ipfs_id :: NAME , & self . ipfs_id) ? ; state . serialize_field (crate :: prisma :: object :: note :: NAME , & self . note) ? ; state . serialize_field (crate :: prisma :: object :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: object :: date_accessed :: NAME , & self . date_accessed) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , kind , key_id , hidden , favorite , important , has_thumbnail , has_thumbstrip , has_video_preview , ipfs_id , note , date_created , date_accessed } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: object :: $ field :: NAME) , + , crate :: prisma :: object :: id :: NAME , crate :: prisma :: object :: pub_id :: NAME , crate :: prisma :: object :: kind :: NAME , crate :: prisma :: object :: key_id :: NAME , crate :: prisma :: object :: hidden :: NAME , crate :: prisma :: object :: favorite :: NAME , crate :: prisma :: object :: important :: NAME , crate :: prisma :: object :: has_thumbnail :: NAME , crate :: prisma :: object :: has_thumbstrip :: NAME , crate :: prisma :: object :: has_video_preview :: NAME , crate :: prisma :: object :: ipfs_id :: NAME , crate :: prisma :: object :: note :: NAME , crate :: prisma :: object :: date_created :: NAME , crate :: prisma :: object :: date_accessed :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: object :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: object :: id :: NAME => Ok (Field :: id) , crate :: prisma :: object :: pub_id :: NAME => Ok (Field :: pub_id) , crate :: prisma :: object :: kind :: NAME => Ok (Field :: kind) , crate :: prisma :: object :: key_id :: NAME => Ok (Field :: key_id) , crate :: prisma :: object :: hidden :: NAME => Ok (Field :: hidden) , crate :: prisma :: object :: favorite :: NAME => Ok (Field :: favorite) , crate :: prisma :: object :: important :: NAME => Ok (Field :: important) , crate :: prisma :: object :: has_thumbnail :: NAME => Ok (Field :: has_thumbnail) , crate :: prisma :: object :: has_thumbstrip :: NAME => Ok (Field :: has_thumbstrip) , crate :: prisma :: object :: has_video_preview :: NAME => Ok (Field :: has_video_preview) , crate :: prisma :: object :: ipfs_id :: NAME => Ok (Field :: ipfs_id) , crate :: prisma :: object :: note :: NAME => Ok (Field :: note) , crate :: prisma :: object :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: object :: date_accessed :: NAME => Ok (Field :: date_accessed) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut kind = None ; let mut key_id = None ; let mut hidden = None ; let mut favorite = None ; let mut important = None ; let mut has_thumbnail = None ; let mut has_thumbstrip = None ; let mut has_video_preview = None ; let mut ipfs_id = None ; let mut note = None ; let mut date_created = None ; let mut date_accessed = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: kind => { if kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: kind :: NAME)) ; } kind = Some (map . next_value () ?) ; } Field :: key_id => { if key_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: key_id :: NAME)) ; } key_id = Some (map . next_value () ?) ; } Field :: hidden => { if hidden . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: hidden :: NAME)) ; } hidden = Some (map . next_value () ?) ; } Field :: favorite => { if favorite . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: favorite :: NAME)) ; } favorite = Some (map . next_value () ?) ; } Field :: important => { if important . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: important :: NAME)) ; } important = Some (map . next_value () ?) ; } Field :: has_thumbnail => { if has_thumbnail . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: has_thumbnail :: NAME)) ; } has_thumbnail = Some (map . next_value () ?) ; } Field :: has_thumbstrip => { if has_thumbstrip . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: has_thumbstrip :: NAME)) ; } has_thumbstrip = Some (map . next_value () ?) ; } Field :: has_video_preview => { if has_video_preview . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: has_video_preview :: NAME)) ; } has_video_preview = Some (map . next_value () ?) ; } Field :: ipfs_id => { if ipfs_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: ipfs_id :: NAME)) ; } ipfs_id = Some (map . next_value () ?) ; } Field :: note => { if note . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: note :: NAME)) ; } note = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_accessed => { if date_accessed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: date_accessed :: NAME)) ; } date_accessed = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: pub_id :: NAME)) ? ; let kind = kind . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: kind :: NAME)) ? ; let key_id = key_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: key_id :: NAME)) ? ; let hidden = hidden . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: hidden :: NAME)) ? ; let favorite = favorite . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: favorite :: NAME)) ? ; let important = important . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: important :: NAME)) ? ; let has_thumbnail = has_thumbnail . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: has_thumbnail :: NAME)) ? ; let has_thumbstrip = has_thumbstrip . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: has_thumbstrip :: NAME)) ? ; let has_video_preview = has_video_preview . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: has_video_preview :: NAME)) ? ; let ipfs_id = ipfs_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: ipfs_id :: NAME)) ? ; let note = note . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: note :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: date_created :: NAME)) ? ; let date_accessed = date_accessed . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object :: date_accessed :: NAME)) ? ; Ok (Data { id , pub_id , kind , key_id , hidden , favorite , important , has_thumbnail , has_thumbstrip , has_video_preview , ipfs_id , note , date_created , date_accessed , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "kind" , "key_id" , "hidden" , "favorite" , "important" , "has_thumbnail" , "has_thumbstrip" , "has_video_preview" , "ipfs_id" , "note" , "date_created" , "date_accessed" , "tags" , "labels" , "albums" , "spaces" , "file_paths" , "comments" , "media_data" , "key"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tags :: Data > } ; (@ field_type ; tags) => { Vec < crate :: prisma :: tag_on_object :: Data > } ; (@ field_type ; labels : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < labels :: Data > } ; (@ field_type ; labels) => { Vec < crate :: prisma :: label_on_object :: Data > } ; (@ field_type ; albums : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < albums :: Data > } ; (@ field_type ; albums) => { Vec < crate :: prisma :: object_in_album :: Data > } ; (@ field_type ; spaces : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < spaces :: Data > } ; (@ field_type ; spaces) => { Vec < crate :: prisma :: object_in_space :: Data > } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; file_paths) => { Vec < crate :: prisma :: file_path :: Data > } ; (@ field_type ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < comments :: Data > } ; (@ field_type ; comments) => { Vec < crate :: prisma :: comment :: Data > } ; (@ field_type ; media_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < media_data :: Data > } ; (@ field_type ; media_data) => { Option < crate :: prisma :: media_data :: Data > } ; (@ field_type ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < key :: Data > } ; (@ field_type ; key) => { Option < crate :: prisma :: key :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Object" , available relations are "tags, labels, albums, spaces, file_paths, comments, media_data, key")) } ; (@ field_module ; tags : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: tag_on_object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; labels : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: label_on_object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; albums : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object_in_album :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; spaces : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object_in_space :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: file_path :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; comments : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: comment :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; media_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: media_data :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; key : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: key :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: tags :: Include :: $ selection_mode (crate :: prisma :: tag_on_object :: ManyArgs :: new (crate :: prisma :: tag_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tags $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: tags :: Include :: Fetch (crate :: prisma :: tag_on_object :: ManyArgs :: new (crate :: prisma :: tag_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; labels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: labels :: Include :: $ selection_mode (crate :: prisma :: label_on_object :: ManyArgs :: new (crate :: prisma :: label_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: label_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; labels $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: labels :: Include :: Fetch (crate :: prisma :: label_on_object :: ManyArgs :: new (crate :: prisma :: label_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; albums $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: albums :: Include :: $ selection_mode (crate :: prisma :: object_in_album :: ManyArgs :: new (crate :: prisma :: object_in_album :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object_in_album :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; albums $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: albums :: Include :: Fetch (crate :: prisma :: object_in_album :: ManyArgs :: new (crate :: prisma :: object_in_album :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; spaces $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: spaces :: Include :: $ selection_mode (crate :: prisma :: object_in_space :: ManyArgs :: new (crate :: prisma :: object_in_space :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object_in_space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; spaces $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: spaces :: Include :: Fetch (crate :: prisma :: object_in_space :: ManyArgs :: new (crate :: prisma :: object_in_space :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: file_paths :: Include :: $ selection_mode (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: file_paths :: Include :: Fetch (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: comments :: Include :: $ selection_mode (crate :: prisma :: comment :: ManyArgs :: new (crate :: prisma :: comment :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: comment :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; comments $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: comments :: Include :: Fetch (crate :: prisma :: comment :: ManyArgs :: new (crate :: prisma :: comment :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; media_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: media_data :: Include :: $ selection_mode (crate :: prisma :: media_data :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; media_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: media_data :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: key :: Include :: $ selection_mode (crate :: prisma :: key :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; key $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object :: IncludeParam > :: into (crate :: prisma :: object :: key :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; key_id) => { "key_id" } ; (@ field_serde_name ; hidden) => { "hidden" } ; (@ field_serde_name ; favorite) => { "favorite" } ; (@ field_serde_name ; important) => { "important" } ; (@ field_serde_name ; has_thumbnail) => { "has_thumbnail" } ; (@ field_serde_name ; has_thumbstrip) => { "has_thumbstrip" } ; (@ field_serde_name ; has_video_preview) => { "has_video_preview" } ; (@ field_serde_name ; ipfs_id) => { "ipfs_id" } ; (@ field_serde_name ; note) => { "note" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_accessed) => { "date_accessed" } ; (@ field_serde_name ; tags) => { "tags" } ; (@ field_serde_name ; labels) => { "labels" } ; (@ field_serde_name ; albums) => { "albums" } ; (@ field_serde_name ; spaces) => { "spaces" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ field_serde_name ; comments) => { "comments" } ; (@ field_serde_name ; media_data) => { "media_data" } ; (@ field_serde_name ; key) => { "key" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_object as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Kind(kind::Include),
		KeyId(key_id::Include),
		Hidden(hidden::Include),
		Favorite(favorite::Include),
		Important(important::Include),
		HasThumbnail(has_thumbnail::Include),
		HasThumbstrip(has_thumbstrip::Include),
		HasVideoPreview(has_video_preview::Include),
		IpfsId(ipfs_id::Include),
		Note(note::Include),
		DateCreated(date_created::Include),
		DateAccessed(date_accessed::Include),
		Tags(tags::Include),
		Labels(labels::Include),
		Albums(albums::Include),
		Spaces(spaces::Include),
		FilePaths(file_paths::Include),
		Comments(comments::Include),
		MediaData(media_data::Include),
		Key(key::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Kind(data) => data.to_selection(),
				Self::KeyId(data) => data.to_selection(),
				Self::Hidden(data) => data.to_selection(),
				Self::Favorite(data) => data.to_selection(),
				Self::Important(data) => data.to_selection(),
				Self::HasThumbnail(data) => data.to_selection(),
				Self::HasThumbstrip(data) => data.to_selection(),
				Self::HasVideoPreview(data) => data.to_selection(),
				Self::IpfsId(data) => data.to_selection(),
				Self::Note(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateAccessed(data) => data.to_selection(),
				Self::Tags(data) => data.to_selection(),
				Self::Labels(data) => data.to_selection(),
				Self::Albums(data) => data.to_selection(),
				Self::Spaces(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
				Self::Comments(data) => data.to_selection(),
				Self::MediaData(data) => data.to_selection(),
				Self::Key(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod albums {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "albums";
		pub fn some(value: Vec<object_in_album::WhereParam>) -> WhereParam {
			WhereParam::AlbumsSome(value)
		}
		pub fn every(value: Vec<object_in_album::WhereParam>) -> WhereParam {
			WhereParam::AlbumsEvery(value)
		}
		pub fn none(value: Vec<object_in_album::WhereParam>) -> WhereParam {
			WhereParam::AlbumsNone(value)
		}
		pub struct Order(Vec<object_in_album::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<object_in_album::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Albums(v)
			}
		}
		pub struct Fetch(pub object_in_album::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object_in_album::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: object_in_album::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: object_in_album::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Albums(v)
			}
		}
		pub fn fetch(params: Vec<object_in_album::WhereParam>) -> Fetch {
			Fetch(object_in_album::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<object_in_album::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectAlbums(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<object_in_album::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<object_in_album::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectAlbums(params)
		}
		pub fn set(params: Vec<object_in_album::UniqueWhereParam>) -> SetParam {
			SetParam::SetAlbums(params)
		}
		pub enum Select {
			Select(object_in_album::ManyArgs, Vec<object_in_album::SelectParam>),
			Include(
				object_in_album::ManyArgs,
				Vec<object_in_album::IncludeParam>,
			),
			Fetch(object_in_album::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Albums(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_album::ManyArgs,
				nested_selections: Vec<object_in_album::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_album::ManyArgs,
				nested_selections: Vec<object_in_album::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(object_in_album::ManyArgs, Vec<object_in_album::SelectParam>),
			Include(
				object_in_album::ManyArgs,
				Vec<object_in_album::IncludeParam>,
			),
			Fetch(object_in_album::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Albums(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_album::ManyArgs,
				nested_selections: Vec<object_in_album::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_album::ManyArgs,
				nested_selections: Vec<object_in_album::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod comments {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "comments";
		pub fn some(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentsSome(value)
		}
		pub fn every(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentsEvery(value)
		}
		pub fn none(value: Vec<comment::WhereParam>) -> WhereParam {
			WhereParam::CommentsNone(value)
		}
		pub struct Order(Vec<comment::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<comment::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Comments(v)
			}
		}
		pub struct Fetch(pub comment::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<comment::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: comment::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: comment::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Comments(v)
			}
		}
		pub fn fetch(params: Vec<comment::WhereParam>) -> Fetch {
			Fetch(comment::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<comment::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectComments(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<comment::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<comment::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectComments(params)
		}
		pub fn set(params: Vec<comment::UniqueWhereParam>) -> SetParam {
			SetParam::SetComments(params)
		}
		pub enum Select {
			Select(comment::ManyArgs, Vec<comment::SelectParam>),
			Include(comment::ManyArgs, Vec<comment::IncludeParam>),
			Fetch(comment::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Comments(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<comment::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(comment::ManyArgs, Vec<comment::SelectParam>),
			Include(comment::ManyArgs, Vec<comment::IncludeParam>),
			Fetch(comment::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Comments(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections =
							<comment::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<comment::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: comment::ManyArgs,
				nested_selections: Vec<comment::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod date_accessed {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_accessed";
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateAccessed(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateAccessed,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateAccessed(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateAccessed(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateAccessed(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateAccessed(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateAccessed(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateAccessed(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateAccessed(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod favorite {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "favorite";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::Favorite(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			Favorite,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Favorite(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Favorite(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Favorite(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Favorite(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Favorite(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Favorite(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Favorite(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod file_paths {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "file_paths";
		pub fn some(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsSome(value)
		}
		pub fn every(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsEvery(value)
		}
		pub fn none(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsNone(value)
		}
		pub struct Order(Vec<file_path::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<file_path::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::FilePaths(v)
			}
		}
		pub struct Fetch(pub file_path::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: file_path::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: file_path::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::FilePaths(v)
			}
		}
		pub fn fetch(params: Vec<file_path::WhereParam>) -> Fetch {
			Fetch(file_path::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<file_path::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectFilePaths(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<file_path::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectFilePaths(params)
		}
		pub fn set(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::SetFilePaths(params)
		}
		pub enum Select {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::FilePaths(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::FilePaths(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = < file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod has_thumbnail {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "has_thumbnail";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::HasThumbnail(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			HasThumbnail,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::HasThumbnail(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::HasThumbnail(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::HasThumbnail(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::HasThumbnail(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::HasThumbnail(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::HasThumbnail(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::HasThumbnail(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod has_thumbstrip {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "has_thumbstrip";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::HasThumbstrip(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			HasThumbstrip,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::HasThumbstrip(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::HasThumbstrip(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::HasThumbstrip(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::HasThumbstrip(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::HasThumbstrip(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::HasThumbstrip(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::HasThumbstrip(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod has_video_preview {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "has_video_preview";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::HasVideoPreview(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			HasVideoPreview,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::HasVideoPreview(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::HasVideoPreview(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::HasVideoPreview(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::HasVideoPreview(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::HasVideoPreview(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::HasVideoPreview(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::HasVideoPreview(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod hidden {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "hidden";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::Hidden(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			Hidden,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Hidden(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Hidden(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Hidden(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Hidden(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Hidden(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Hidden(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Hidden(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod important {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "important";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::Important(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			Important,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Important(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Important(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Important(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Important(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Important(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Important(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Important(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod ipfs_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "ipfs_id";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::IpfsId(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			IpfsId,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IpfsId(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IpfsId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IpfsId(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IpfsId(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IpfsId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IpfsId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IpfsId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod key {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key";
		pub fn is(value: Vec<key::WhereParam>) -> WhereParam {
			WhereParam::KeyIs(value)
		}
		pub fn is_not(value: Vec<key::WhereParam>) -> WhereParam {
			WhereParam::KeyIsNot(value)
		}
		pub struct Order(Vec<key::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<key::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Key(v)
			}
		}
		pub struct Fetch(pub key::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<key::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Key(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(key::UniqueArgs::new())
		}
		pub struct Connect(key::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectKey(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: key::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectKey
		}
		pub fn is_null() -> WhereParam {
			WhereParam::KeyIsNull
		}
		pub enum Select {
			Select(Vec<key::SelectParam>),
			Include(Vec<key::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Key(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("key", None, [], selections)
			}
			pub fn select(nested_selections: Vec<key::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<key::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<key::SelectParam>),
			Include(Vec<key::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Key(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<key::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("key", None, [], selections)
			}
			pub fn select(nested_selections: Vec<key::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<key::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod key_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key_id";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::KeyId(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			KeyId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::KeyId(v)
			}
		}
		pub struct Set(pub Option<i32>);
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::KeyId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::KeyId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod kind {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "kind";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::Kind(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Kind, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Kind(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Kind(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Kind(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Kind(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Kind(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Kind(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Kind(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod labels {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "labels";
		pub fn some(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelsSome(value)
		}
		pub fn every(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelsEvery(value)
		}
		pub fn none(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelsNone(value)
		}
		pub struct Order(Vec<label_on_object::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<label_on_object::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Labels(v)
			}
		}
		pub struct Fetch(pub label_on_object::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<label_on_object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: label_on_object::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: label_on_object::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Labels(v)
			}
		}
		pub fn fetch(params: Vec<label_on_object::WhereParam>) -> Fetch {
			Fetch(label_on_object::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<label_on_object::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLabels(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<label_on_object::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<label_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectLabels(params)
		}
		pub fn set(params: Vec<label_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::SetLabels(params)
		}
		pub enum Select {
			Select(label_on_object::ManyArgs, Vec<label_on_object::SelectParam>),
			Include(
				label_on_object::ManyArgs,
				Vec<label_on_object::IncludeParam>,
			),
			Fetch(label_on_object::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Labels(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(label_on_object::ManyArgs, Vec<label_on_object::SelectParam>),
			Include(
				label_on_object::ManyArgs,
				Vec<label_on_object::IncludeParam>,
			),
			Fetch(label_on_object::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Labels(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod media_data {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "media_data";
		pub fn is(value: Vec<media_data::WhereParam>) -> WhereParam {
			WhereParam::MediaDataIs(value)
		}
		pub fn is_not(value: Vec<media_data::WhereParam>) -> WhereParam {
			WhereParam::MediaDataIsNot(value)
		}
		pub struct Order(Vec<media_data::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<media_data::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::MediaData(v)
			}
		}
		pub struct Fetch(pub media_data::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<media_data::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::MediaData(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(media_data::UniqueArgs::new())
		}
		pub struct Connect(media_data::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectMediaData(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: media_data::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectMediaData
		}
		pub fn is_null() -> WhereParam {
			WhereParam::MediaDataIsNull
		}
		pub enum Select {
			Select(Vec<media_data::SelectParam>),
			Include(Vec<media_data::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::MediaData(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<media_data::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("media_data", None, [], selections)
			}
			pub fn select(nested_selections: Vec<media_data::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<media_data::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<media_data::SelectParam>),
			Include(Vec<media_data::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::MediaData(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = < media_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<media_data::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("media_data", None, [], selections)
			}
			pub fn select(nested_selections: Vec<media_data::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<media_data::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod note {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "note";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Note(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Note,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Note(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Note(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Note(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Note(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Note(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Note(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Note(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod spaces {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "spaces";
		pub fn some(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::SpacesSome(value)
		}
		pub fn every(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::SpacesEvery(value)
		}
		pub fn none(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::SpacesNone(value)
		}
		pub struct Order(Vec<object_in_space::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<object_in_space::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Spaces(v)
			}
		}
		pub struct Fetch(pub object_in_space::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object_in_space::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: object_in_space::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: object_in_space::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Spaces(v)
			}
		}
		pub fn fetch(params: Vec<object_in_space::WhereParam>) -> Fetch {
			Fetch(object_in_space::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<object_in_space::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectSpaces(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<object_in_space::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<object_in_space::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectSpaces(params)
		}
		pub fn set(params: Vec<object_in_space::UniqueWhereParam>) -> SetParam {
			SetParam::SetSpaces(params)
		}
		pub enum Select {
			Select(object_in_space::ManyArgs, Vec<object_in_space::SelectParam>),
			Include(
				object_in_space::ManyArgs,
				Vec<object_in_space::IncludeParam>,
			),
			Fetch(object_in_space::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Spaces(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(object_in_space::ManyArgs, Vec<object_in_space::SelectParam>),
			Include(
				object_in_space::ManyArgs,
				Vec<object_in_space::IncludeParam>,
			),
			Fetch(object_in_space::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Spaces(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod tags {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "tags";
		pub fn some(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagsSome(value)
		}
		pub fn every(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagsEvery(value)
		}
		pub fn none(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagsNone(value)
		}
		pub struct Order(Vec<tag_on_object::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<tag_on_object::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Tags(v)
			}
		}
		pub struct Fetch(pub tag_on_object::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<tag_on_object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: tag_on_object::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: tag_on_object::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Tags(v)
			}
		}
		pub fn fetch(params: Vec<tag_on_object::WhereParam>) -> Fetch {
			Fetch(tag_on_object::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<tag_on_object::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectTags(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<tag_on_object::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<tag_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectTags(params)
		}
		pub fn set(params: Vec<tag_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::SetTags(params)
		}
		pub enum Select {
			Select(tag_on_object::ManyArgs, Vec<tag_on_object::SelectParam>),
			Include(tag_on_object::ManyArgs, Vec<tag_on_object::IncludeParam>),
			Fetch(tag_on_object::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Tags(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(tag_on_object::ManyArgs, Vec<tag_on_object::SelectParam>),
			Include(tag_on_object::ManyArgs, Vec<tag_on_object::IncludeParam>),
			Fetch(tag_on_object::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Tags(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.object().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.object().create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(kind::NAME),
				::prisma_client_rust::sel(key_id::NAME),
				::prisma_client_rust::sel(hidden::NAME),
				::prisma_client_rust::sel(favorite::NAME),
				::prisma_client_rust::sel(important::NAME),
				::prisma_client_rust::sel(has_thumbnail::NAME),
				::prisma_client_rust::sel(has_thumbstrip::NAME),
				::prisma_client_rust::sel(has_video_preview::NAME),
				::prisma_client_rust::sel(ipfs_id::NAME),
				::prisma_client_rust::sel(note::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_accessed::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Object", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pub_id")]
		pub pub_id: Vec<u8>,
		#[serde(rename = "kind")]
		pub kind: i32,
		#[serde(rename = "key_id")]
		pub key_id: Option<i32>,
		#[serde(rename = "hidden")]
		pub hidden: bool,
		#[serde(rename = "favorite")]
		pub favorite: bool,
		#[serde(rename = "important")]
		pub important: bool,
		#[serde(rename = "has_thumbnail")]
		pub has_thumbnail: bool,
		#[serde(rename = "has_thumbstrip")]
		pub has_thumbstrip: bool,
		#[serde(rename = "has_video_preview")]
		pub has_video_preview: bool,
		#[serde(rename = "ipfs_id")]
		pub ipfs_id: Option<String>,
		#[serde(rename = "note")]
		pub note: Option<String>,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_accessed")]
		pub date_accessed: Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>,
		#[serde(rename = "tags")]
		#[specta(skip)]
		pub tags: Option<Vec<super::tag_on_object::Data>>,
		#[serde(rename = "labels")]
		#[specta(skip)]
		pub labels: Option<Vec<super::label_on_object::Data>>,
		#[serde(rename = "albums")]
		#[specta(skip)]
		pub albums: Option<Vec<super::object_in_album::Data>>,
		#[serde(rename = "spaces")]
		#[specta(skip)]
		pub spaces: Option<Vec<super::object_in_space::Data>>,
		#[serde(rename = "file_paths")]
		#[specta(skip)]
		pub file_paths: Option<Vec<super::file_path::Data>>,
		#[serde(rename = "comments")]
		#[specta(skip)]
		pub comments: Option<Vec<super::comment::Data>>,
		#[serde(
			rename = "media_data",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub media_data: Option<Option<Box<super::media_data::Data>>>,
		#[serde(
			rename = "key",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub key: Option<Option<Box<super::key::Data>>>,
	}
	impl Data {
		pub fn tags(
			&self,
		) -> Result<&Vec<super::tag_on_object::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.tags
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(tags),
				))
		}
		pub fn labels(
			&self,
		) -> Result<&Vec<super::label_on_object::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.labels
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(labels),
				))
		}
		pub fn albums(
			&self,
		) -> Result<&Vec<super::object_in_album::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.albums
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(albums),
				))
		}
		pub fn spaces(
			&self,
		) -> Result<&Vec<super::object_in_space::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.spaces
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(spaces),
				))
		}
		pub fn file_paths(
			&self,
		) -> Result<&Vec<super::file_path::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.file_paths
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(file_paths),
				))
		}
		pub fn comments(
			&self,
		) -> Result<&Vec<super::comment::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.comments
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(comments),
				))
		}
		pub fn media_data(
			&self,
		) -> Result<Option<&super::media_data::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.media_data
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(media_data),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
		pub fn key(
			&self,
		) -> Result<Option<&super::key::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.key
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(key),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_object { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: object struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "kind")] pub kind : i32 , # [serde (rename = "key_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub key_id : Option < i32 > , # [serde (rename = "hidden")] pub hidden : bool , # [serde (rename = "favorite")] pub favorite : bool , # [serde (rename = "important")] pub important : bool , # [serde (rename = "has_thumbnail")] pub has_thumbnail : bool , # [serde (rename = "has_thumbstrip")] pub has_thumbstrip : bool , # [serde (rename = "has_video_preview")] pub has_video_preview : bool , # [serde (rename = "ipfs_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub ipfs_id : Option < String > , # [serde (rename = "note")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub note : Option < String > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_accessed")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_accessed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_object as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod file_conflict {
	use super::_prisma::*;
	pub const NAME: &str = "FileConflict";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		OriginalObjectId(super::_prisma::read_filters::IntFilter),
		DetactchedObjectId(super::_prisma::read_filters::IntFilter),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::OriginalObjectId(value) => (original_object_id::NAME, value.into()),
				Self::DetactchedObjectId(value) => (detactched_object_id::NAME, value.into()),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		OriginalObjectIdEquals(i32),
		DetactchedObjectIdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::OriginalObjectIdEquals(value) => {
					Self::OriginalObjectId(super::_prisma::read_filters::IntFilter::Equals(value))
				}
				UniqueWhereParam::DetactchedObjectIdEquals(value) => {
					Self::DetactchedObjectId(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		OriginalObjectId(super::SortOrder),
		DetactchedObjectId(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::OriginalObjectId(param) => ("original_object_id", param.into()),
				Self::DetactchedObjectId(param) => ("detactched_object_id", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		OriginalObjectId(super::_prisma::write_params::IntParam),
		DetactchedObjectId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::OriginalObjectId(value) => (original_object_id::NAME, value.into()),
				Self::DetactchedObjectId(value) => (detactched_object_id::NAME, value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		OriginalObjectId(super::_prisma::write_params::IntParam),
		DetactchedObjectId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::OriginalObjectId(value) => ("original_object_id", value.into()),
				Self::DetactchedObjectId(value) => ("detactched_object_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_file_conflict { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: file_conflict :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: file_conflict :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: file_conflict :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: file_conflict :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: file_conflict :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: file_conflict :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { original_object_id , detactched_object_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: file_conflict :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: file_conflict :: $ field :: NAME)] pub $ field : crate :: prisma :: file_conflict :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: file_conflict :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: file_conflict :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: file_conflict :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_conflict :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_conflict :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["original_object_id" , "detactched_object_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: file_conflict :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; original_object_id) => { i32 } ; (@ field_type ; detactched_object_id) => { i32 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FileConflict" , available relations are "original_object_id, detactched_object_id")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; original_object_id) => { Into :: < crate :: prisma :: file_conflict :: SelectParam > :: into (crate :: prisma :: file_conflict :: original_object_id :: Select) } ; (@ selection_field_to_selection_param ; detactched_object_id) => { Into :: < crate :: prisma :: file_conflict :: SelectParam > :: into (crate :: prisma :: file_conflict :: detactched_object_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: file_conflict :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; original_object_id) => { "original_object_id" } ; (@ field_serde_name ; detactched_object_id) => { "detactched_object_id" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_file_conflict as select;
	pub enum SelectParam {
		OriginalObjectId(original_object_id::Select),
		DetactchedObjectId(detactched_object_id::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::OriginalObjectId(data) => data.to_selection(),
				Self::DetactchedObjectId(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_file_conflict { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: file_conflict :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: file_conflict :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: file_conflict :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: file_conflict :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: file_conflict :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: file_conflict :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: file_conflict :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: file_conflict :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: file_conflict :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: file_conflict :: original_object_id :: NAME)] pub original_object_id : i32 , # [specta (rename_from_path = crate :: prisma :: file_conflict :: detactched_object_id :: NAME)] pub detactched_object_id : i32 , $ (# [specta (rename_from_path = crate :: prisma :: file_conflict :: $ field :: NAME)] pub $ field : crate :: prisma :: file_conflict :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (original_object_id) , stringify ! (detactched_object_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: file_conflict :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: file_conflict :: original_object_id :: NAME , & self . original_object_id) ? ; state . serialize_field (crate :: prisma :: file_conflict :: detactched_object_id :: NAME , & self . detactched_object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , original_object_id , detactched_object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: file_conflict :: $ field :: NAME) , + , crate :: prisma :: file_conflict :: original_object_id :: NAME , crate :: prisma :: file_conflict :: detactched_object_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: file_conflict :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: file_conflict :: original_object_id :: NAME => Ok (Field :: original_object_id) , crate :: prisma :: file_conflict :: detactched_object_id :: NAME => Ok (Field :: detactched_object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut original_object_id = None ; let mut detactched_object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: original_object_id => { if original_object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_conflict :: original_object_id :: NAME)) ; } original_object_id = Some (map . next_value () ?) ; } Field :: detactched_object_id => { if detactched_object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_conflict :: detactched_object_id :: NAME)) ; } detactched_object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: file_conflict :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_conflict :: $ field :: NAME)) ? ;) * let original_object_id = original_object_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_conflict :: original_object_id :: NAME)) ? ; let detactched_object_id = detactched_object_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: file_conflict :: detactched_object_id :: NAME)) ? ; Ok (Data { original_object_id , detactched_object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["original_object_id" , "detactched_object_id"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: file_conflict :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FileConflict" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: file_conflict :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; original_object_id) => { "original_object_id" } ; (@ field_serde_name ; detactched_object_id) => { "detactched_object_id" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_file_conflict as include;
	pub enum IncludeParam {
		OriginalObjectId(original_object_id::Include),
		DetactchedObjectId(detactched_object_id::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::OriginalObjectId(data) => data.to_selection(),
				Self::DetactchedObjectId(data) => data.to_selection(),
			}
		}
	}
	pub mod detactched_object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "detactched_object_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::DetactchedObjectIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			DetactchedObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DetactchedObjectId(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DetactchedObjectId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DetactchedObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DetactchedObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DetactchedObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DetactchedObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DetactchedObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod original_object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "original_object_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::OriginalObjectIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			OriginalObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::OriginalObjectId(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::OriginalObjectId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::OriginalObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::OriginalObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::OriginalObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::OriginalObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::OriginalObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub original_object_id: i32,
		pub detactched_object_id: i32,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.file_conflict().create(
				self.original_object_id,
				self.detactched_object_id,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				original_object_id::set(self.original_object_id),
				detactched_object_id::set(self.detactched_object_id),
			]);
			self._params
		}
	}
	pub fn create(
		original_object_id: i32,
		detactched_object_id: i32,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			original_object_id,
			detactched_object_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub original_object_id: i32,
		pub detactched_object_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.file_conflict().create_unchecked(
				self.original_object_id,
				self.detactched_object_id,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				original_object_id::set(self.original_object_id),
				detactched_object_id::set(self.detactched_object_id),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		original_object_id: i32,
		detactched_object_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			original_object_id,
			detactched_object_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(original_object_id::NAME),
				::prisma_client_rust::sel(detactched_object_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "FileConflict", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "original_object_id")]
		pub original_object_id: i32,
		#[serde(rename = "detactched_object_id")]
		pub detactched_object_id: i32,
	}
	impl Data {}
	#[macro_export]
	macro_rules ! _partial_unchecked_file_conflict { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: file_conflict struct $ struct_name { # [serde (rename = "original_object_id")] pub original_object_id : i32 , # [serde (rename = "detactched_object_id")] pub detactched_object_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_file_conflict as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			original_object_id: i32,
			detactched_object_id: i32,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				original_object_id::set(original_object_id),
				detactched_object_id::set(detactched_object_id),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			original_object_id: i32,
			detactched_object_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				original_object_id::set(original_object_id),
				detactched_object_id::set(detactched_object_id),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod key {
	use super::_prisma::*;
	pub const NAME: &str = "Key";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		Uuid(super::_prisma::read_filters::StringFilter),
		Version(super::_prisma::read_filters::StringFilter),
		KeyType(super::_prisma::read_filters::StringFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		Default(super::_prisma::read_filters::BooleanFilter),
		DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
		Algorithm(super::_prisma::read_filters::StringFilter),
		HashingAlgorithm(super::_prisma::read_filters::StringFilter),
		ContentSalt(super::_prisma::read_filters::BytesFilter),
		MasterKey(super::_prisma::read_filters::BytesFilter),
		MasterKeyNonce(super::_prisma::read_filters::BytesFilter),
		KeyNonce(super::_prisma::read_filters::BytesFilter),
		Key(super::_prisma::read_filters::BytesFilter),
		Salt(super::_prisma::read_filters::BytesFilter),
		Automount(super::_prisma::read_filters::BooleanFilter),
		ObjectsSome(Vec<super::object::WhereParam>),
		ObjectsEvery(Vec<super::object::WhereParam>),
		ObjectsNone(Vec<super::object::WhereParam>),
		FilePathsSome(Vec<super::file_path::WhereParam>),
		FilePathsEvery(Vec<super::file_path::WhereParam>),
		FilePathsNone(Vec<super::file_path::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::Uuid(value) => (uuid::NAME, value.into()),
				Self::Version(value) => (version::NAME, value.into()),
				Self::KeyType(value) => (key_type::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Default(value) => (default::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::Algorithm(value) => (algorithm::NAME, value.into()),
				Self::HashingAlgorithm(value) => (hashing_algorithm::NAME, value.into()),
				Self::ContentSalt(value) => (content_salt::NAME, value.into()),
				Self::MasterKey(value) => (master_key::NAME, value.into()),
				Self::MasterKeyNonce(value) => (master_key_nonce::NAME, value.into()),
				Self::KeyNonce(value) => (key_nonce::NAME, value.into()),
				Self::Key(value) => (key::NAME, value.into()),
				Self::Salt(value) => (salt::NAME, value.into()),
				Self::Automount(value) => (automount::NAME, value.into()),
				Self::ObjectsSome(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectsEvery(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectsNone(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsSome(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsEvery(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::FilePathsNone(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UuidEquals(String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UuidEquals(value) => {
					Self::Uuid(super::_prisma::read_filters::StringFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		Uuid(super::SortOrder),
		Version(super::SortOrder),
		KeyType(super::SortOrder),
		Name(super::SortOrder),
		Default(super::SortOrder),
		DateCreated(super::SortOrder),
		Algorithm(super::SortOrder),
		HashingAlgorithm(super::SortOrder),
		ContentSalt(super::SortOrder),
		MasterKey(super::SortOrder),
		MasterKeyNonce(super::SortOrder),
		KeyNonce(super::SortOrder),
		Key(super::SortOrder),
		Salt(super::SortOrder),
		Automount(super::SortOrder),
		Objects(Vec<super::object::OrderByRelationAggregateParam>),
		FilePaths(Vec<super::file_path::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::Uuid(param) => ("uuid", param.into()),
				Self::Version(param) => ("version", param.into()),
				Self::KeyType(param) => ("key_type", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Default(param) => ("default", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::Algorithm(param) => ("algorithm", param.into()),
				Self::HashingAlgorithm(param) => ("hashing_algorithm", param.into()),
				Self::ContentSalt(param) => ("content_salt", param.into()),
				Self::MasterKey(param) => ("master_key", param.into()),
				Self::MasterKeyNonce(param) => ("master_key_nonce", param.into()),
				Self::KeyNonce(param) => ("key_nonce", param.into()),
				Self::Key(param) => ("key", param.into()),
				Self::Salt(param) => ("salt", param.into()),
				Self::Automount(param) => ("automount", param.into()),
				Self::Objects(param) => (
					"objects",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::FilePaths(param) => (
					"file_paths",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Objects(super::object::ManyArgs),
		FilePaths(super::file_path::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Objects(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						objects::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
				Self::FilePaths(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						file_paths::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		Uuid(super::_prisma::write_params::StringParam),
		Version(super::_prisma::write_params::StringParam),
		KeyType(super::_prisma::write_params::StringParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Default(super::_prisma::write_params::BooleanParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		Algorithm(super::_prisma::write_params::StringParam),
		HashingAlgorithm(super::_prisma::write_params::StringParam),
		ContentSalt(super::_prisma::write_params::BytesParam),
		MasterKey(super::_prisma::write_params::BytesParam),
		MasterKeyNonce(super::_prisma::write_params::BytesParam),
		KeyNonce(super::_prisma::write_params::BytesParam),
		Key(super::_prisma::write_params::BytesParam),
		Salt(super::_prisma::write_params::BytesParam),
		Automount(super::_prisma::write_params::BooleanParam),
		ConnectObjects(Vec<super::object::UniqueWhereParam>),
		DisconnectObjects(Vec<super::object::UniqueWhereParam>),
		SetObjects(Vec<super::object::UniqueWhereParam>),
		ConnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		DisconnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
		SetFilePaths(Vec<super::file_path::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::Uuid(value) => (uuid::NAME, value.into()),
				Self::Version(value) => (version::NAME, value.into()),
				Self::KeyType(value) => (key_type::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Default(value) => (default::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::Algorithm(value) => (algorithm::NAME, value.into()),
				Self::HashingAlgorithm(value) => (hashing_algorithm::NAME, value.into()),
				Self::ContentSalt(value) => (content_salt::NAME, value.into()),
				Self::MasterKey(value) => (master_key::NAME, value.into()),
				Self::MasterKeyNonce(value) => (master_key_nonce::NAME, value.into()),
				Self::KeyNonce(value) => (key_nonce::NAME, value.into()),
				Self::Key(value) => (key::NAME, value.into()),
				Self::Salt(value) => (salt::NAME, value.into()),
				Self::Automount(value) => (automount::NAME, value.into()),
				Self::ConnectObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::ConnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetFilePaths(where_params) => (
					file_paths::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::file_path::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		Uuid(super::_prisma::write_params::StringParam),
		Version(super::_prisma::write_params::StringParam),
		KeyType(super::_prisma::write_params::StringParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Default(super::_prisma::write_params::BooleanParam),
		DateCreated(super::_prisma::write_params::DateTimeNullableParam),
		Algorithm(super::_prisma::write_params::StringParam),
		HashingAlgorithm(super::_prisma::write_params::StringParam),
		ContentSalt(super::_prisma::write_params::BytesParam),
		MasterKey(super::_prisma::write_params::BytesParam),
		MasterKeyNonce(super::_prisma::write_params::BytesParam),
		KeyNonce(super::_prisma::write_params::BytesParam),
		Key(super::_prisma::write_params::BytesParam),
		Salt(super::_prisma::write_params::BytesParam),
		Automount(super::_prisma::write_params::BooleanParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::Uuid(value) => ("uuid", value.into()),
				Self::Version(value) => ("version", value.into()),
				Self::KeyType(value) => ("key_type", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Default(value) => ("default", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::Algorithm(value) => ("algorithm", value.into()),
				Self::HashingAlgorithm(value) => ("hashing_algorithm", value.into()),
				Self::ContentSalt(value) => ("content_salt", value.into()),
				Self::MasterKey(value) => ("master_key", value.into()),
				Self::MasterKeyNonce(value) => ("master_key_nonce", value.into()),
				Self::KeyNonce(value) => ("key_nonce", value.into()),
				Self::Key(value) => ("key", value.into()),
				Self::Salt(value) => ("salt", value.into()),
				Self::Automount(value) => ("automount", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_key { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: key :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: key :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: key :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: key :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: key :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: key :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , uuid , version , key_type , name , default , date_created , algorithm , hashing_algorithm , content_salt , master_key , master_key_nonce , key_nonce , key , salt , automount , objects , file_paths } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: key :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: key :: $ field :: NAME)] pub $ field : crate :: prisma :: key :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: key :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: key :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: key :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "uuid" , "version" , "key_type" , "name" , "default" , "date_created" , "algorithm" , "hashing_algorithm" , "content_salt" , "master_key" , "master_key_nonce" , "key_nonce" , "key" , "salt" , "automount" , "objects" , "file_paths"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: key :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; uuid) => { String } ; (@ field_type ; version) => { String } ; (@ field_type ; key_type) => { String } ; (@ field_type ; name) => { Option < String > } ; (@ field_type ; default) => { bool } ; (@ field_type ; date_created) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; algorithm) => { String } ; (@ field_type ; hashing_algorithm) => { String } ; (@ field_type ; content_salt) => { Vec < u8 > } ; (@ field_type ; master_key) => { Vec < u8 > } ; (@ field_type ; master_key_nonce) => { Vec < u8 > } ; (@ field_type ; key_nonce) => { Vec < u8 > } ; (@ field_type ; key) => { Vec < u8 > } ; (@ field_type ; salt) => { Vec < u8 > } ; (@ field_type ; automount) => { bool } ; (@ field_type ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < objects :: Data > } ; (@ field_type ; objects) => { Vec < crate :: prisma :: object :: Data > } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; file_paths) => { Vec < crate :: prisma :: file_path :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Key" , available relations are "id, uuid, version, key_type, name, default, date_created, algorithm, hashing_algorithm, content_salt, master_key, master_key_nonce, key_nonce, key, salt, automount, objects, file_paths")) } ; (@ field_module ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: file_path :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: id :: Select) } ; (@ selection_field_to_selection_param ; uuid) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: uuid :: Select) } ; (@ selection_field_to_selection_param ; version) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: version :: Select) } ; (@ selection_field_to_selection_param ; key_type) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: key_type :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: name :: Select) } ; (@ selection_field_to_selection_param ; default) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: default :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: date_created :: Select) } ; (@ selection_field_to_selection_param ; algorithm) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: algorithm :: Select) } ; (@ selection_field_to_selection_param ; hashing_algorithm) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: hashing_algorithm :: Select) } ; (@ selection_field_to_selection_param ; content_salt) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: content_salt :: Select) } ; (@ selection_field_to_selection_param ; master_key) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: master_key :: Select) } ; (@ selection_field_to_selection_param ; master_key_nonce) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: master_key_nonce :: Select) } ; (@ selection_field_to_selection_param ; key_nonce) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: key_nonce :: Select) } ; (@ selection_field_to_selection_param ; key) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: key :: Select) } ; (@ selection_field_to_selection_param ; salt) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: salt :: Select) } ; (@ selection_field_to_selection_param ; automount) => { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: automount :: Select) } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: objects :: Select :: $ selection_mode (crate :: prisma :: object :: ManyArgs :: new (crate :: prisma :: object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: objects :: Select :: Fetch (crate :: prisma :: object :: ManyArgs :: new (crate :: prisma :: object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: file_paths :: Select :: $ selection_mode (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: key :: SelectParam > :: into (crate :: prisma :: key :: file_paths :: Select :: Fetch (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: key :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; uuid) => { "uuid" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; key_type) => { "key_type" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; default) => { "default" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; algorithm) => { "algorithm" } ; (@ field_serde_name ; hashing_algorithm) => { "hashing_algorithm" } ; (@ field_serde_name ; content_salt) => { "content_salt" } ; (@ field_serde_name ; master_key) => { "master_key" } ; (@ field_serde_name ; master_key_nonce) => { "master_key_nonce" } ; (@ field_serde_name ; key_nonce) => { "key_nonce" } ; (@ field_serde_name ; key) => { "key" } ; (@ field_serde_name ; salt) => { "salt" } ; (@ field_serde_name ; automount) => { "automount" } ; (@ field_serde_name ; objects) => { "objects" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_key as select;
	pub enum SelectParam {
		Id(id::Select),
		Uuid(uuid::Select),
		Version(version::Select),
		KeyType(key_type::Select),
		Name(name::Select),
		Default(default::Select),
		DateCreated(date_created::Select),
		Algorithm(algorithm::Select),
		HashingAlgorithm(hashing_algorithm::Select),
		ContentSalt(content_salt::Select),
		MasterKey(master_key::Select),
		MasterKeyNonce(master_key_nonce::Select),
		KeyNonce(key_nonce::Select),
		Key(key::Select),
		Salt(salt::Select),
		Automount(automount::Select),
		Objects(objects::Select),
		FilePaths(file_paths::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Uuid(data) => data.to_selection(),
				Self::Version(data) => data.to_selection(),
				Self::KeyType(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Default(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::Algorithm(data) => data.to_selection(),
				Self::HashingAlgorithm(data) => data.to_selection(),
				Self::ContentSalt(data) => data.to_selection(),
				Self::MasterKey(data) => data.to_selection(),
				Self::MasterKeyNonce(data) => data.to_selection(),
				Self::KeyNonce(data) => data.to_selection(),
				Self::Key(data) => data.to_selection(),
				Self::Salt(data) => data.to_selection(),
				Self::Automount(data) => data.to_selection(),
				Self::Objects(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_key { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: key :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: key :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: key :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: key :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: key :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: key :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: key :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: key :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { objects , file_paths } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: key :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: key :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: key :: uuid :: NAME)] pub uuid : String , # [specta (rename_from_path = crate :: prisma :: key :: version :: NAME)] pub version : String , # [specta (rename_from_path = crate :: prisma :: key :: key_type :: NAME)] pub key_type : String , # [specta (rename_from_path = crate :: prisma :: key :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = crate :: prisma :: key :: default :: NAME)] pub default : bool , # [specta (rename_from_path = crate :: prisma :: key :: date_created :: NAME)] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = crate :: prisma :: key :: algorithm :: NAME)] pub algorithm : String , # [specta (rename_from_path = crate :: prisma :: key :: hashing_algorithm :: NAME)] pub hashing_algorithm : String , # [specta (rename_from_path = crate :: prisma :: key :: content_salt :: NAME)] pub content_salt : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: key :: master_key :: NAME)] pub master_key : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: key :: master_key_nonce :: NAME)] pub master_key_nonce : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: key :: key_nonce :: NAME)] pub key_nonce : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: key :: key :: NAME)] pub key : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: key :: salt :: NAME)] pub salt : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: key :: automount :: NAME)] pub automount : bool , $ (# [specta (rename_from_path = crate :: prisma :: key :: $ field :: NAME)] pub $ field : crate :: prisma :: key :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (uuid) , stringify ! (version) , stringify ! (key_type) , stringify ! (name) , stringify ! (default) , stringify ! (date_created) , stringify ! (algorithm) , stringify ! (hashing_algorithm) , stringify ! (content_salt) , stringify ! (master_key) , stringify ! (master_key_nonce) , stringify ! (key_nonce) , stringify ! (key) , stringify ! (salt) , stringify ! (automount)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: key :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: key :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: key :: uuid :: NAME , & self . uuid) ? ; state . serialize_field (crate :: prisma :: key :: version :: NAME , & self . version) ? ; state . serialize_field (crate :: prisma :: key :: key_type :: NAME , & self . key_type) ? ; state . serialize_field (crate :: prisma :: key :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: key :: default :: NAME , & self . default) ? ; state . serialize_field (crate :: prisma :: key :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: key :: algorithm :: NAME , & self . algorithm) ? ; state . serialize_field (crate :: prisma :: key :: hashing_algorithm :: NAME , & self . hashing_algorithm) ? ; state . serialize_field (crate :: prisma :: key :: content_salt :: NAME , & self . content_salt) ? ; state . serialize_field (crate :: prisma :: key :: master_key :: NAME , & self . master_key) ? ; state . serialize_field (crate :: prisma :: key :: master_key_nonce :: NAME , & self . master_key_nonce) ? ; state . serialize_field (crate :: prisma :: key :: key_nonce :: NAME , & self . key_nonce) ? ; state . serialize_field (crate :: prisma :: key :: key :: NAME , & self . key) ? ; state . serialize_field (crate :: prisma :: key :: salt :: NAME , & self . salt) ? ; state . serialize_field (crate :: prisma :: key :: automount :: NAME , & self . automount) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , uuid , version , key_type , name , default , date_created , algorithm , hashing_algorithm , content_salt , master_key , master_key_nonce , key_nonce , key , salt , automount } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: key :: $ field :: NAME) , + , crate :: prisma :: key :: id :: NAME , crate :: prisma :: key :: uuid :: NAME , crate :: prisma :: key :: version :: NAME , crate :: prisma :: key :: key_type :: NAME , crate :: prisma :: key :: name :: NAME , crate :: prisma :: key :: default :: NAME , crate :: prisma :: key :: date_created :: NAME , crate :: prisma :: key :: algorithm :: NAME , crate :: prisma :: key :: hashing_algorithm :: NAME , crate :: prisma :: key :: content_salt :: NAME , crate :: prisma :: key :: master_key :: NAME , crate :: prisma :: key :: master_key_nonce :: NAME , crate :: prisma :: key :: key_nonce :: NAME , crate :: prisma :: key :: key :: NAME , crate :: prisma :: key :: salt :: NAME , crate :: prisma :: key :: automount :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: key :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: key :: id :: NAME => Ok (Field :: id) , crate :: prisma :: key :: uuid :: NAME => Ok (Field :: uuid) , crate :: prisma :: key :: version :: NAME => Ok (Field :: version) , crate :: prisma :: key :: key_type :: NAME => Ok (Field :: key_type) , crate :: prisma :: key :: name :: NAME => Ok (Field :: name) , crate :: prisma :: key :: default :: NAME => Ok (Field :: default) , crate :: prisma :: key :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: key :: algorithm :: NAME => Ok (Field :: algorithm) , crate :: prisma :: key :: hashing_algorithm :: NAME => Ok (Field :: hashing_algorithm) , crate :: prisma :: key :: content_salt :: NAME => Ok (Field :: content_salt) , crate :: prisma :: key :: master_key :: NAME => Ok (Field :: master_key) , crate :: prisma :: key :: master_key_nonce :: NAME => Ok (Field :: master_key_nonce) , crate :: prisma :: key :: key_nonce :: NAME => Ok (Field :: key_nonce) , crate :: prisma :: key :: key :: NAME => Ok (Field :: key) , crate :: prisma :: key :: salt :: NAME => Ok (Field :: salt) , crate :: prisma :: key :: automount :: NAME => Ok (Field :: automount) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut uuid = None ; let mut version = None ; let mut key_type = None ; let mut name = None ; let mut default = None ; let mut date_created = None ; let mut algorithm = None ; let mut hashing_algorithm = None ; let mut content_salt = None ; let mut master_key = None ; let mut master_key_nonce = None ; let mut key_nonce = None ; let mut key = None ; let mut salt = None ; let mut automount = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: uuid => { if uuid . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: uuid :: NAME)) ; } uuid = Some (map . next_value () ?) ; } Field :: version => { if version . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: version :: NAME)) ; } version = Some (map . next_value () ?) ; } Field :: key_type => { if key_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: key_type :: NAME)) ; } key_type = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: default => { if default . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: default :: NAME)) ; } default = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: algorithm => { if algorithm . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: algorithm :: NAME)) ; } algorithm = Some (map . next_value () ?) ; } Field :: hashing_algorithm => { if hashing_algorithm . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: hashing_algorithm :: NAME)) ; } hashing_algorithm = Some (map . next_value () ?) ; } Field :: content_salt => { if content_salt . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: content_salt :: NAME)) ; } content_salt = Some (map . next_value () ?) ; } Field :: master_key => { if master_key . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: master_key :: NAME)) ; } master_key = Some (map . next_value () ?) ; } Field :: master_key_nonce => { if master_key_nonce . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: master_key_nonce :: NAME)) ; } master_key_nonce = Some (map . next_value () ?) ; } Field :: key_nonce => { if key_nonce . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: key_nonce :: NAME)) ; } key_nonce = Some (map . next_value () ?) ; } Field :: key => { if key . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: key :: NAME)) ; } key = Some (map . next_value () ?) ; } Field :: salt => { if salt . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: salt :: NAME)) ; } salt = Some (map . next_value () ?) ; } Field :: automount => { if automount . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: automount :: NAME)) ; } automount = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: key :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: id :: NAME)) ? ; let uuid = uuid . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: uuid :: NAME)) ? ; let version = version . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: version :: NAME)) ? ; let key_type = key_type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: key_type :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: name :: NAME)) ? ; let default = default . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: default :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: date_created :: NAME)) ? ; let algorithm = algorithm . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: algorithm :: NAME)) ? ; let hashing_algorithm = hashing_algorithm . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: hashing_algorithm :: NAME)) ? ; let content_salt = content_salt . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: content_salt :: NAME)) ? ; let master_key = master_key . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: master_key :: NAME)) ? ; let master_key_nonce = master_key_nonce . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: master_key_nonce :: NAME)) ? ; let key_nonce = key_nonce . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: key_nonce :: NAME)) ? ; let key = key . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: key :: NAME)) ? ; let salt = salt . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: salt :: NAME)) ? ; let automount = automount . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: key :: automount :: NAME)) ? ; Ok (Data { id , uuid , version , key_type , name , default , date_created , algorithm , hashing_algorithm , content_salt , master_key , master_key_nonce , key_nonce , key , salt , automount , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "uuid" , "version" , "key_type" , "name" , "default" , "date_created" , "algorithm" , "hashing_algorithm" , "content_salt" , "master_key" , "master_key_nonce" , "key_nonce" , "key" , "salt" , "automount" , "objects" , "file_paths"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: key :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < objects :: Data > } ; (@ field_type ; objects) => { Vec < crate :: prisma :: object :: Data > } ; (@ field_type ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < file_paths :: Data > } ; (@ field_type ; file_paths) => { Vec < crate :: prisma :: file_path :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Key" , available relations are "objects, file_paths")) } ; (@ field_module ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; file_paths : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: file_path :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: key :: IncludeParam > :: into (crate :: prisma :: key :: objects :: Include :: $ selection_mode (crate :: prisma :: object :: ManyArgs :: new (crate :: prisma :: object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: key :: IncludeParam > :: into (crate :: prisma :: key :: objects :: Include :: Fetch (crate :: prisma :: object :: ManyArgs :: new (crate :: prisma :: object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: key :: IncludeParam > :: into (crate :: prisma :: key :: file_paths :: Include :: $ selection_mode (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: file_path :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; file_paths $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: key :: IncludeParam > :: into (crate :: prisma :: key :: file_paths :: Include :: Fetch (crate :: prisma :: file_path :: ManyArgs :: new (crate :: prisma :: file_path :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: key :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; uuid) => { "uuid" } ; (@ field_serde_name ; version) => { "version" } ; (@ field_serde_name ; key_type) => { "key_type" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; default) => { "default" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; algorithm) => { "algorithm" } ; (@ field_serde_name ; hashing_algorithm) => { "hashing_algorithm" } ; (@ field_serde_name ; content_salt) => { "content_salt" } ; (@ field_serde_name ; master_key) => { "master_key" } ; (@ field_serde_name ; master_key_nonce) => { "master_key_nonce" } ; (@ field_serde_name ; key_nonce) => { "key_nonce" } ; (@ field_serde_name ; key) => { "key" } ; (@ field_serde_name ; salt) => { "salt" } ; (@ field_serde_name ; automount) => { "automount" } ; (@ field_serde_name ; objects) => { "objects" } ; (@ field_serde_name ; file_paths) => { "file_paths" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_key as include;
	pub enum IncludeParam {
		Id(id::Include),
		Uuid(uuid::Include),
		Version(version::Include),
		KeyType(key_type::Include),
		Name(name::Include),
		Default(default::Include),
		DateCreated(date_created::Include),
		Algorithm(algorithm::Include),
		HashingAlgorithm(hashing_algorithm::Include),
		ContentSalt(content_salt::Include),
		MasterKey(master_key::Include),
		MasterKeyNonce(master_key_nonce::Include),
		KeyNonce(key_nonce::Include),
		Key(key::Include),
		Salt(salt::Include),
		Automount(automount::Include),
		Objects(objects::Include),
		FilePaths(file_paths::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Uuid(data) => data.to_selection(),
				Self::Version(data) => data.to_selection(),
				Self::KeyType(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Default(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::Algorithm(data) => data.to_selection(),
				Self::HashingAlgorithm(data) => data.to_selection(),
				Self::ContentSalt(data) => data.to_selection(),
				Self::MasterKey(data) => data.to_selection(),
				Self::MasterKeyNonce(data) => data.to_selection(),
				Self::KeyNonce(data) => data.to_selection(),
				Self::Key(data) => data.to_selection(),
				Self::Salt(data) => data.to_selection(),
				Self::Automount(data) => data.to_selection(),
				Self::Objects(data) => data.to_selection(),
				Self::FilePaths(data) => data.to_selection(),
			}
		}
	}
	pub mod algorithm {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "algorithm";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Algorithm(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			Algorithm,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Algorithm(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Algorithm(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Algorithm(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Algorithm(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Algorithm(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Algorithm(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Algorithm(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod automount {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "automount";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::Automount(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			Automount,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Automount(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Automount(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Automount(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Automount(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Automount(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Automount(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Automount(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod content_salt {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "content_salt";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::ContentSalt(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			ContentSalt,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ContentSalt(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ContentSalt(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::ContentSalt(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ContentSalt(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ContentSalt(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ContentSalt(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ContentSalt(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod default {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "default";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::Default(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			Default,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Default(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Default(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Default(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Default(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Default(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Default(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Default(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod file_paths {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "file_paths";
		pub fn some(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsSome(value)
		}
		pub fn every(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsEvery(value)
		}
		pub fn none(value: Vec<file_path::WhereParam>) -> WhereParam {
			WhereParam::FilePathsNone(value)
		}
		pub struct Order(Vec<file_path::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<file_path::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::FilePaths(v)
			}
		}
		pub struct Fetch(pub file_path::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<file_path::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: file_path::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: file_path::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::FilePaths(v)
			}
		}
		pub fn fetch(params: Vec<file_path::WhereParam>) -> Fetch {
			Fetch(file_path::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<file_path::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectFilePaths(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<file_path::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectFilePaths(params)
		}
		pub fn set(params: Vec<file_path::UniqueWhereParam>) -> SetParam {
			SetParam::SetFilePaths(params)
		}
		pub enum Select {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::FilePaths(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(file_path::ManyArgs, Vec<file_path::SelectParam>),
			Include(file_path::ManyArgs, Vec<file_path::IncludeParam>),
			Fetch(file_path::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::FilePaths(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = < file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<file_path::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: file_path::ManyArgs,
				nested_selections: Vec<file_path::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod hashing_algorithm {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "hashing_algorithm";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::HashingAlgorithm(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			HashingAlgorithm,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::HashingAlgorithm(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::HashingAlgorithm(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::HashingAlgorithm(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::HashingAlgorithm(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::HashingAlgorithm(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::HashingAlgorithm(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::HashingAlgorithm(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod key {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::Key(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Key, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Key(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Key(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Key(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Key(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Key(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Key(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Key(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod key_nonce {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key_nonce";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::KeyNonce(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			KeyNonce,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::KeyNonce(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyNonce(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyNonce(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyNonce(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyNonce(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::KeyNonce(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::KeyNonce(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod key_type {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "key_type";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::KeyType(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			KeyType,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::KeyType(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyType(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyType(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::KeyType(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::KeyType(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::KeyType(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::KeyType(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod master_key {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "master_key";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::MasterKey(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			MasterKey,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::MasterKey(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MasterKey(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::MasterKey(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::MasterKey(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MasterKey(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::MasterKey(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::MasterKey(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod master_key_nonce {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "master_key_nonce";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::MasterKeyNonce(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			MasterKeyNonce,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::MasterKeyNonce(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MasterKeyNonce(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::MasterKeyNonce(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::MasterKeyNonce(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::MasterKeyNonce(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::MasterKeyNonce(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::MasterKeyNonce(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod objects {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "objects";
		pub fn some(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectsSome(value)
		}
		pub fn every(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectsEvery(value)
		}
		pub fn none(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectsNone(value)
		}
		pub struct Order(Vec<object::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Objects(v)
			}
		}
		pub struct Fetch(pub object::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: object::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: object::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Objects(v)
			}
		}
		pub fn fetch(params: Vec<object::WhereParam>) -> Fetch {
			Fetch(object::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<object::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObjects(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<object::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<object::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectObjects(params)
		}
		pub fn set(params: Vec<object::UniqueWhereParam>) -> SetParam {
			SetParam::SetObjects(params)
		}
		pub enum Select {
			Select(object::ManyArgs, Vec<object::SelectParam>),
			Include(object::ManyArgs, Vec<object::IncludeParam>),
			Fetch(object::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Objects(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object::ManyArgs,
				nested_selections: Vec<object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object::ManyArgs,
				nested_selections: Vec<object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(object::ManyArgs, Vec<object::SelectParam>),
			Include(object::ManyArgs, Vec<object::IncludeParam>),
			Fetch(object::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Objects(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object::ManyArgs,
				nested_selections: Vec<object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object::ManyArgs,
				nested_selections: Vec<object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod salt {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "salt";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::Salt(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Salt, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Salt(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Salt(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Salt(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Salt(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Salt(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Salt(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Salt(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod uuid {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "uuid";
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UuidEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Uuid, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Uuid(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Uuid(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Uuid(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Uuid(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Uuid(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Uuid(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Uuid(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod version {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "version";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Version(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			Version,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Version(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Version(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Version(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Version(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Version(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Version(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Version(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub uuid: String,
		pub version: String,
		pub key_type: String,
		pub algorithm: String,
		pub hashing_algorithm: String,
		pub content_salt: Vec<u8>,
		pub master_key: Vec<u8>,
		pub master_key_nonce: Vec<u8>,
		pub key_nonce: Vec<u8>,
		pub key: Vec<u8>,
		pub salt: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.key().create(
				self.uuid,
				self.version,
				self.key_type,
				self.algorithm,
				self.hashing_algorithm,
				self.content_salt,
				self.master_key,
				self.master_key_nonce,
				self.key_nonce,
				self.key,
				self.salt,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				uuid::set(self.uuid),
				version::set(self.version),
				key_type::set(self.key_type),
				algorithm::set(self.algorithm),
				hashing_algorithm::set(self.hashing_algorithm),
				content_salt::set(self.content_salt),
				master_key::set(self.master_key),
				master_key_nonce::set(self.master_key_nonce),
				key_nonce::set(self.key_nonce),
				key::set(self.key),
				salt::set(self.salt),
			]);
			self._params
		}
	}
	pub fn create(
		uuid: String,
		version: String,
		key_type: String,
		algorithm: String,
		hashing_algorithm: String,
		content_salt: Vec<u8>,
		master_key: Vec<u8>,
		master_key_nonce: Vec<u8>,
		key_nonce: Vec<u8>,
		key: Vec<u8>,
		salt: Vec<u8>,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			uuid,
			version,
			key_type,
			algorithm,
			hashing_algorithm,
			content_salt,
			master_key,
			master_key_nonce,
			key_nonce,
			key,
			salt,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub uuid: String,
		pub version: String,
		pub key_type: String,
		pub algorithm: String,
		pub hashing_algorithm: String,
		pub content_salt: Vec<u8>,
		pub master_key: Vec<u8>,
		pub master_key_nonce: Vec<u8>,
		pub key_nonce: Vec<u8>,
		pub key: Vec<u8>,
		pub salt: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.key().create_unchecked(
				self.uuid,
				self.version,
				self.key_type,
				self.algorithm,
				self.hashing_algorithm,
				self.content_salt,
				self.master_key,
				self.master_key_nonce,
				self.key_nonce,
				self.key,
				self.salt,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				uuid::set(self.uuid),
				version::set(self.version),
				key_type::set(self.key_type),
				algorithm::set(self.algorithm),
				hashing_algorithm::set(self.hashing_algorithm),
				content_salt::set(self.content_salt),
				master_key::set(self.master_key),
				master_key_nonce::set(self.master_key_nonce),
				key_nonce::set(self.key_nonce),
				key::set(self.key),
				salt::set(self.salt),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		uuid: String,
		version: String,
		key_type: String,
		algorithm: String,
		hashing_algorithm: String,
		content_salt: Vec<u8>,
		master_key: Vec<u8>,
		master_key_nonce: Vec<u8>,
		key_nonce: Vec<u8>,
		key: Vec<u8>,
		salt: Vec<u8>,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			uuid,
			version,
			key_type,
			algorithm,
			hashing_algorithm,
			content_salt,
			master_key,
			master_key_nonce,
			key_nonce,
			key,
			salt,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(uuid::NAME),
				::prisma_client_rust::sel(version::NAME),
				::prisma_client_rust::sel(key_type::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(default::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(algorithm::NAME),
				::prisma_client_rust::sel(hashing_algorithm::NAME),
				::prisma_client_rust::sel(content_salt::NAME),
				::prisma_client_rust::sel(master_key::NAME),
				::prisma_client_rust::sel(master_key_nonce::NAME),
				::prisma_client_rust::sel(key_nonce::NAME),
				::prisma_client_rust::sel(key::NAME),
				::prisma_client_rust::sel(salt::NAME),
				::prisma_client_rust::sel(automount::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Key", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "uuid")]
		pub uuid: String,
		#[serde(rename = "version")]
		pub version: String,
		#[serde(rename = "key_type")]
		pub key_type: String,
		#[serde(rename = "name")]
		pub name: Option<String>,
		#[serde(rename = "default")]
		pub default: bool,
		#[serde(rename = "date_created")]
		pub date_created: Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>,
		#[serde(rename = "algorithm")]
		pub algorithm: String,
		#[serde(rename = "hashing_algorithm")]
		pub hashing_algorithm: String,
		#[serde(rename = "content_salt")]
		pub content_salt: Vec<u8>,
		#[serde(rename = "master_key")]
		pub master_key: Vec<u8>,
		#[serde(rename = "master_key_nonce")]
		pub master_key_nonce: Vec<u8>,
		#[serde(rename = "key_nonce")]
		pub key_nonce: Vec<u8>,
		#[serde(rename = "key")]
		pub key: Vec<u8>,
		#[serde(rename = "salt")]
		pub salt: Vec<u8>,
		#[serde(rename = "automount")]
		pub automount: bool,
		#[serde(rename = "objects")]
		#[specta(skip)]
		pub objects: Option<Vec<super::object::Data>>,
		#[serde(rename = "file_paths")]
		#[specta(skip)]
		pub file_paths: Option<Vec<super::file_path::Data>>,
	}
	impl Data {
		pub fn objects(
			&self,
		) -> Result<&Vec<super::object::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.objects
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(objects),
				))
		}
		pub fn file_paths(
			&self,
		) -> Result<&Vec<super::file_path::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.file_paths
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(file_paths),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_key { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: key struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "uuid")] pub uuid : String , # [serde (rename = "version")] pub version : String , # [serde (rename = "key_type")] pub key_type : String , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "default")] pub default : bool , # [serde (rename = "date_created")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_created : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "algorithm")] pub algorithm : String , # [serde (rename = "hashing_algorithm")] pub hashing_algorithm : String , # [serde (rename = "content_salt")] pub content_salt : Vec < u8 > , # [serde (rename = "master_key")] pub master_key : Vec < u8 > , # [serde (rename = "master_key_nonce")] pub master_key_nonce : Vec < u8 > , # [serde (rename = "key_nonce")] pub key_nonce : Vec < u8 > , # [serde (rename = "key")] pub key : Vec < u8 > , # [serde (rename = "salt")] pub salt : Vec < u8 > , # [serde (rename = "automount")] pub automount : bool } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_key as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			uuid: String,
			version: String,
			key_type: String,
			algorithm: String,
			hashing_algorithm: String,
			content_salt: Vec<u8>,
			master_key: Vec<u8>,
			master_key_nonce: Vec<u8>,
			key_nonce: Vec<u8>,
			key: Vec<u8>,
			salt: Vec<u8>,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				uuid::set(uuid),
				version::set(version),
				key_type::set(key_type),
				algorithm::set(algorithm),
				hashing_algorithm::set(hashing_algorithm),
				content_salt::set(content_salt),
				master_key::set(master_key),
				master_key_nonce::set(master_key_nonce),
				key_nonce::set(key_nonce),
				key::set(key),
				salt::set(salt),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			uuid: String,
			version: String,
			key_type: String,
			algorithm: String,
			hashing_algorithm: String,
			content_salt: Vec<u8>,
			master_key: Vec<u8>,
			master_key_nonce: Vec<u8>,
			key_nonce: Vec<u8>,
			key: Vec<u8>,
			salt: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				uuid::set(uuid),
				version::set(version),
				key_type::set(key_type),
				algorithm::set(algorithm),
				hashing_algorithm::set(hashing_algorithm),
				content_salt::set(content_salt),
				master_key::set(master_key),
				master_key_nonce::set(master_key_nonce),
				key_nonce::set(key_nonce),
				key::set(key),
				salt::set(salt),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod media_data {
	use super::_prisma::*;
	pub const NAME: &str = "MediaData";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PixelWidth(super::_prisma::read_filters::IntNullableFilter),
		PixelHeight(super::_prisma::read_filters::IntNullableFilter),
		Longitude(super::_prisma::read_filters::FloatNullableFilter),
		Latitude(super::_prisma::read_filters::FloatNullableFilter),
		Fps(super::_prisma::read_filters::IntNullableFilter),
		CaptureDeviceMake(super::_prisma::read_filters::StringNullableFilter),
		CaptureDeviceModel(super::_prisma::read_filters::StringNullableFilter),
		CaptureDeviceSoftware(super::_prisma::read_filters::StringNullableFilter),
		DurationSeconds(super::_prisma::read_filters::IntNullableFilter),
		Codecs(super::_prisma::read_filters::StringNullableFilter),
		Streams(super::_prisma::read_filters::IntNullableFilter),
		ObjectIsNull,
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PixelWidth(value) => (pixel_width::NAME, value.into()),
				Self::PixelHeight(value) => (pixel_height::NAME, value.into()),
				Self::Longitude(value) => (longitude::NAME, value.into()),
				Self::Latitude(value) => (latitude::NAME, value.into()),
				Self::Fps(value) => (fps::NAME, value.into()),
				Self::CaptureDeviceMake(value) => (capture_device_make::NAME, value.into()),
				Self::CaptureDeviceModel(value) => (capture_device_model::NAME, value.into()),
				Self::CaptureDeviceSoftware(value) => (capture_device_software::NAME, value.into()),
				Self::DurationSeconds(value) => (duration_seconds::NAME, value.into()),
				Self::Codecs(value) => (codecs::NAME, value.into()),
				Self::Streams(value) => (streams::NAME, value.into()),
				Self::ObjectIsNull => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PixelWidth(super::SortOrder),
		PixelHeight(super::SortOrder),
		Longitude(super::SortOrder),
		Latitude(super::SortOrder),
		Fps(super::SortOrder),
		CaptureDeviceMake(super::SortOrder),
		CaptureDeviceModel(super::SortOrder),
		CaptureDeviceSoftware(super::SortOrder),
		DurationSeconds(super::SortOrder),
		Codecs(super::SortOrder),
		Streams(super::SortOrder),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PixelWidth(param) => ("pixel_width", param.into()),
				Self::PixelHeight(param) => ("pixel_height", param.into()),
				Self::Longitude(param) => ("longitude", param.into()),
				Self::Latitude(param) => ("latitude", param.into()),
				Self::Fps(param) => ("fps", param.into()),
				Self::CaptureDeviceMake(param) => ("capture_device_make", param.into()),
				Self::CaptureDeviceModel(param) => ("capture_device_model", param.into()),
				Self::CaptureDeviceSoftware(param) => ("capture_device_software", param.into()),
				Self::DurationSeconds(param) => ("duration_seconds", param.into()),
				Self::Codecs(param) => ("codecs", param.into()),
				Self::Streams(param) => ("streams", param.into()),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PixelWidth(super::_prisma::write_params::IntNullableParam),
		PixelHeight(super::_prisma::write_params::IntNullableParam),
		Longitude(super::_prisma::write_params::FloatNullableParam),
		Latitude(super::_prisma::write_params::FloatNullableParam),
		Fps(super::_prisma::write_params::IntNullableParam),
		CaptureDeviceMake(super::_prisma::write_params::StringNullableParam),
		CaptureDeviceModel(super::_prisma::write_params::StringNullableParam),
		CaptureDeviceSoftware(super::_prisma::write_params::StringNullableParam),
		DurationSeconds(super::_prisma::write_params::IntNullableParam),
		Codecs(super::_prisma::write_params::StringNullableParam),
		Streams(super::_prisma::write_params::IntNullableParam),
		ConnectObject(super::object::UniqueWhereParam),
		DisconnectObject,
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PixelWidth(value) => (pixel_width::NAME, value.into()),
				Self::PixelHeight(value) => (pixel_height::NAME, value.into()),
				Self::Longitude(value) => (longitude::NAME, value.into()),
				Self::Latitude(value) => (latitude::NAME, value.into()),
				Self::Fps(value) => (fps::NAME, value.into()),
				Self::CaptureDeviceMake(value) => (capture_device_make::NAME, value.into()),
				Self::CaptureDeviceModel(value) => (capture_device_model::NAME, value.into()),
				Self::CaptureDeviceSoftware(value) => (capture_device_software::NAME, value.into()),
				Self::DurationSeconds(value) => (duration_seconds::NAME, value.into()),
				Self::Codecs(value) => (codecs::NAME, value.into()),
				Self::Streams(value) => (streams::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectObject => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PixelWidth(super::_prisma::write_params::IntNullableParam),
		PixelHeight(super::_prisma::write_params::IntNullableParam),
		Longitude(super::_prisma::write_params::FloatNullableParam),
		Latitude(super::_prisma::write_params::FloatNullableParam),
		Fps(super::_prisma::write_params::IntNullableParam),
		CaptureDeviceMake(super::_prisma::write_params::StringNullableParam),
		CaptureDeviceModel(super::_prisma::write_params::StringNullableParam),
		CaptureDeviceSoftware(super::_prisma::write_params::StringNullableParam),
		DurationSeconds(super::_prisma::write_params::IntNullableParam),
		Codecs(super::_prisma::write_params::StringNullableParam),
		Streams(super::_prisma::write_params::IntNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PixelWidth(value) => ("pixel_width", value.into()),
				Self::PixelHeight(value) => ("pixel_height", value.into()),
				Self::Longitude(value) => ("longitude", value.into()),
				Self::Latitude(value) => ("latitude", value.into()),
				Self::Fps(value) => ("fps", value.into()),
				Self::CaptureDeviceMake(value) => ("capture_device_make", value.into()),
				Self::CaptureDeviceModel(value) => ("capture_device_model", value.into()),
				Self::CaptureDeviceSoftware(value) => ("capture_device_software", value.into()),
				Self::DurationSeconds(value) => ("duration_seconds", value.into()),
				Self::Codecs(value) => ("codecs", value.into()),
				Self::Streams(value) => ("streams", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_media_data { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: media_data :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: media_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: media_data :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: media_data :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: media_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: media_data :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pixel_width , pixel_height , longitude , latitude , fps , capture_device_make , capture_device_model , capture_device_software , duration_seconds , codecs , streams , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: media_data :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: media_data :: $ field :: NAME)] pub $ field : crate :: prisma :: media_data :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: media_data :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: media_data :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: media_data :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pixel_width" , "pixel_height" , "longitude" , "latitude" , "fps" , "capture_device_make" , "capture_device_model" , "capture_device_software" , "duration_seconds" , "codecs" , "streams" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: media_data :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pixel_width) => { Option < i32 > } ; (@ field_type ; pixel_height) => { Option < i32 > } ; (@ field_type ; longitude) => { Option < f64 > } ; (@ field_type ; latitude) => { Option < f64 > } ; (@ field_type ; fps) => { Option < i32 > } ; (@ field_type ; capture_device_make) => { Option < String > } ; (@ field_type ; capture_device_model) => { Option < String > } ; (@ field_type ; capture_device_software) => { Option < String > } ; (@ field_type ; duration_seconds) => { Option < i32 > } ; (@ field_type ; codecs) => { Option < String > } ; (@ field_type ; streams) => { Option < i32 > } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; object) => { Option < crate :: prisma :: object :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "MediaData" , available relations are "id, pixel_width, pixel_height, longitude, latitude, fps, capture_device_make, capture_device_model, capture_device_software, duration_seconds, codecs, streams, object")) } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: id :: Select) } ; (@ selection_field_to_selection_param ; pixel_width) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: pixel_width :: Select) } ; (@ selection_field_to_selection_param ; pixel_height) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: pixel_height :: Select) } ; (@ selection_field_to_selection_param ; longitude) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: longitude :: Select) } ; (@ selection_field_to_selection_param ; latitude) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: latitude :: Select) } ; (@ selection_field_to_selection_param ; fps) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: fps :: Select) } ; (@ selection_field_to_selection_param ; capture_device_make) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: capture_device_make :: Select) } ; (@ selection_field_to_selection_param ; capture_device_model) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: capture_device_model :: Select) } ; (@ selection_field_to_selection_param ; capture_device_software) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: capture_device_software :: Select) } ; (@ selection_field_to_selection_param ; duration_seconds) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: duration_seconds :: Select) } ; (@ selection_field_to_selection_param ; codecs) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: codecs :: Select) } ; (@ selection_field_to_selection_param ; streams) => { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: streams :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: object :: Select :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: media_data :: SelectParam > :: into (crate :: prisma :: media_data :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: media_data :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pixel_width) => { "pixel_width" } ; (@ field_serde_name ; pixel_height) => { "pixel_height" } ; (@ field_serde_name ; longitude) => { "longitude" } ; (@ field_serde_name ; latitude) => { "latitude" } ; (@ field_serde_name ; fps) => { "fps" } ; (@ field_serde_name ; capture_device_make) => { "capture_device_make" } ; (@ field_serde_name ; capture_device_model) => { "capture_device_model" } ; (@ field_serde_name ; capture_device_software) => { "capture_device_software" } ; (@ field_serde_name ; duration_seconds) => { "duration_seconds" } ; (@ field_serde_name ; codecs) => { "codecs" } ; (@ field_serde_name ; streams) => { "streams" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_media_data as select;
	pub enum SelectParam {
		Id(id::Select),
		PixelWidth(pixel_width::Select),
		PixelHeight(pixel_height::Select),
		Longitude(longitude::Select),
		Latitude(latitude::Select),
		Fps(fps::Select),
		CaptureDeviceMake(capture_device_make::Select),
		CaptureDeviceModel(capture_device_model::Select),
		CaptureDeviceSoftware(capture_device_software::Select),
		DurationSeconds(duration_seconds::Select),
		Codecs(codecs::Select),
		Streams(streams::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PixelWidth(data) => data.to_selection(),
				Self::PixelHeight(data) => data.to_selection(),
				Self::Longitude(data) => data.to_selection(),
				Self::Latitude(data) => data.to_selection(),
				Self::Fps(data) => data.to_selection(),
				Self::CaptureDeviceMake(data) => data.to_selection(),
				Self::CaptureDeviceModel(data) => data.to_selection(),
				Self::CaptureDeviceSoftware(data) => data.to_selection(),
				Self::DurationSeconds(data) => data.to_selection(),
				Self::Codecs(data) => data.to_selection(),
				Self::Streams(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_media_data { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: media_data :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: media_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: media_data :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: media_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: media_data :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: media_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: media_data :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: media_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: media_data :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: media_data :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: media_data :: pixel_width :: NAME)] pub pixel_width : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: media_data :: pixel_height :: NAME)] pub pixel_height : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: media_data :: longitude :: NAME)] pub longitude : Option < f64 > , # [specta (rename_from_path = crate :: prisma :: media_data :: latitude :: NAME)] pub latitude : Option < f64 > , # [specta (rename_from_path = crate :: prisma :: media_data :: fps :: NAME)] pub fps : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: media_data :: capture_device_make :: NAME)] pub capture_device_make : Option < String > , # [specta (rename_from_path = crate :: prisma :: media_data :: capture_device_model :: NAME)] pub capture_device_model : Option < String > , # [specta (rename_from_path = crate :: prisma :: media_data :: capture_device_software :: NAME)] pub capture_device_software : Option < String > , # [specta (rename_from_path = crate :: prisma :: media_data :: duration_seconds :: NAME)] pub duration_seconds : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: media_data :: codecs :: NAME)] pub codecs : Option < String > , # [specta (rename_from_path = crate :: prisma :: media_data :: streams :: NAME)] pub streams : Option < i32 > , $ (# [specta (rename_from_path = crate :: prisma :: media_data :: $ field :: NAME)] pub $ field : crate :: prisma :: media_data :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pixel_width) , stringify ! (pixel_height) , stringify ! (longitude) , stringify ! (latitude) , stringify ! (fps) , stringify ! (capture_device_make) , stringify ! (capture_device_model) , stringify ! (capture_device_software) , stringify ! (duration_seconds) , stringify ! (codecs) , stringify ! (streams)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: media_data :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: media_data :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: media_data :: pixel_width :: NAME , & self . pixel_width) ? ; state . serialize_field (crate :: prisma :: media_data :: pixel_height :: NAME , & self . pixel_height) ? ; state . serialize_field (crate :: prisma :: media_data :: longitude :: NAME , & self . longitude) ? ; state . serialize_field (crate :: prisma :: media_data :: latitude :: NAME , & self . latitude) ? ; state . serialize_field (crate :: prisma :: media_data :: fps :: NAME , & self . fps) ? ; state . serialize_field (crate :: prisma :: media_data :: capture_device_make :: NAME , & self . capture_device_make) ? ; state . serialize_field (crate :: prisma :: media_data :: capture_device_model :: NAME , & self . capture_device_model) ? ; state . serialize_field (crate :: prisma :: media_data :: capture_device_software :: NAME , & self . capture_device_software) ? ; state . serialize_field (crate :: prisma :: media_data :: duration_seconds :: NAME , & self . duration_seconds) ? ; state . serialize_field (crate :: prisma :: media_data :: codecs :: NAME , & self . codecs) ? ; state . serialize_field (crate :: prisma :: media_data :: streams :: NAME , & self . streams) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pixel_width , pixel_height , longitude , latitude , fps , capture_device_make , capture_device_model , capture_device_software , duration_seconds , codecs , streams } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: media_data :: $ field :: NAME) , + , crate :: prisma :: media_data :: id :: NAME , crate :: prisma :: media_data :: pixel_width :: NAME , crate :: prisma :: media_data :: pixel_height :: NAME , crate :: prisma :: media_data :: longitude :: NAME , crate :: prisma :: media_data :: latitude :: NAME , crate :: prisma :: media_data :: fps :: NAME , crate :: prisma :: media_data :: capture_device_make :: NAME , crate :: prisma :: media_data :: capture_device_model :: NAME , crate :: prisma :: media_data :: capture_device_software :: NAME , crate :: prisma :: media_data :: duration_seconds :: NAME , crate :: prisma :: media_data :: codecs :: NAME , crate :: prisma :: media_data :: streams :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: media_data :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: media_data :: id :: NAME => Ok (Field :: id) , crate :: prisma :: media_data :: pixel_width :: NAME => Ok (Field :: pixel_width) , crate :: prisma :: media_data :: pixel_height :: NAME => Ok (Field :: pixel_height) , crate :: prisma :: media_data :: longitude :: NAME => Ok (Field :: longitude) , crate :: prisma :: media_data :: latitude :: NAME => Ok (Field :: latitude) , crate :: prisma :: media_data :: fps :: NAME => Ok (Field :: fps) , crate :: prisma :: media_data :: capture_device_make :: NAME => Ok (Field :: capture_device_make) , crate :: prisma :: media_data :: capture_device_model :: NAME => Ok (Field :: capture_device_model) , crate :: prisma :: media_data :: capture_device_software :: NAME => Ok (Field :: capture_device_software) , crate :: prisma :: media_data :: duration_seconds :: NAME => Ok (Field :: duration_seconds) , crate :: prisma :: media_data :: codecs :: NAME => Ok (Field :: codecs) , crate :: prisma :: media_data :: streams :: NAME => Ok (Field :: streams) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pixel_width = None ; let mut pixel_height = None ; let mut longitude = None ; let mut latitude = None ; let mut fps = None ; let mut capture_device_make = None ; let mut capture_device_model = None ; let mut capture_device_software = None ; let mut duration_seconds = None ; let mut codecs = None ; let mut streams = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pixel_width => { if pixel_width . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: pixel_width :: NAME)) ; } pixel_width = Some (map . next_value () ?) ; } Field :: pixel_height => { if pixel_height . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: pixel_height :: NAME)) ; } pixel_height = Some (map . next_value () ?) ; } Field :: longitude => { if longitude . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: longitude :: NAME)) ; } longitude = Some (map . next_value () ?) ; } Field :: latitude => { if latitude . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: latitude :: NAME)) ; } latitude = Some (map . next_value () ?) ; } Field :: fps => { if fps . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: fps :: NAME)) ; } fps = Some (map . next_value () ?) ; } Field :: capture_device_make => { if capture_device_make . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: capture_device_make :: NAME)) ; } capture_device_make = Some (map . next_value () ?) ; } Field :: capture_device_model => { if capture_device_model . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: capture_device_model :: NAME)) ; } capture_device_model = Some (map . next_value () ?) ; } Field :: capture_device_software => { if capture_device_software . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: capture_device_software :: NAME)) ; } capture_device_software = Some (map . next_value () ?) ; } Field :: duration_seconds => { if duration_seconds . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: duration_seconds :: NAME)) ; } duration_seconds = Some (map . next_value () ?) ; } Field :: codecs => { if codecs . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: codecs :: NAME)) ; } codecs = Some (map . next_value () ?) ; } Field :: streams => { if streams . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: streams :: NAME)) ; } streams = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: media_data :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: id :: NAME)) ? ; let pixel_width = pixel_width . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: pixel_width :: NAME)) ? ; let pixel_height = pixel_height . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: pixel_height :: NAME)) ? ; let longitude = longitude . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: longitude :: NAME)) ? ; let latitude = latitude . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: latitude :: NAME)) ? ; let fps = fps . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: fps :: NAME)) ? ; let capture_device_make = capture_device_make . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: capture_device_make :: NAME)) ? ; let capture_device_model = capture_device_model . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: capture_device_model :: NAME)) ? ; let capture_device_software = capture_device_software . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: capture_device_software :: NAME)) ? ; let duration_seconds = duration_seconds . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: duration_seconds :: NAME)) ? ; let codecs = codecs . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: codecs :: NAME)) ? ; let streams = streams . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: media_data :: streams :: NAME)) ? ; Ok (Data { id , pixel_width , pixel_height , longitude , latitude , fps , capture_device_make , capture_device_model , capture_device_software , duration_seconds , codecs , streams , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pixel_width" , "pixel_height" , "longitude" , "latitude" , "fps" , "capture_device_make" , "capture_device_model" , "capture_device_software" , "duration_seconds" , "codecs" , "streams" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: media_data :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; object) => { Option < crate :: prisma :: object :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "MediaData" , available relations are "object")) } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: media_data :: IncludeParam > :: into (crate :: prisma :: media_data :: object :: Include :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: media_data :: IncludeParam > :: into (crate :: prisma :: media_data :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: media_data :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pixel_width) => { "pixel_width" } ; (@ field_serde_name ; pixel_height) => { "pixel_height" } ; (@ field_serde_name ; longitude) => { "longitude" } ; (@ field_serde_name ; latitude) => { "latitude" } ; (@ field_serde_name ; fps) => { "fps" } ; (@ field_serde_name ; capture_device_make) => { "capture_device_make" } ; (@ field_serde_name ; capture_device_model) => { "capture_device_model" } ; (@ field_serde_name ; capture_device_software) => { "capture_device_software" } ; (@ field_serde_name ; duration_seconds) => { "duration_seconds" } ; (@ field_serde_name ; codecs) => { "codecs" } ; (@ field_serde_name ; streams) => { "streams" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_media_data as include;
	pub enum IncludeParam {
		Id(id::Include),
		PixelWidth(pixel_width::Include),
		PixelHeight(pixel_height::Include),
		Longitude(longitude::Include),
		Latitude(latitude::Include),
		Fps(fps::Include),
		CaptureDeviceMake(capture_device_make::Include),
		CaptureDeviceModel(capture_device_model::Include),
		CaptureDeviceSoftware(capture_device_software::Include),
		DurationSeconds(duration_seconds::Include),
		Codecs(codecs::Include),
		Streams(streams::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PixelWidth(data) => data.to_selection(),
				Self::PixelHeight(data) => data.to_selection(),
				Self::Longitude(data) => data.to_selection(),
				Self::Latitude(data) => data.to_selection(),
				Self::Fps(data) => data.to_selection(),
				Self::CaptureDeviceMake(data) => data.to_selection(),
				Self::CaptureDeviceModel(data) => data.to_selection(),
				Self::CaptureDeviceSoftware(data) => data.to_selection(),
				Self::DurationSeconds(data) => data.to_selection(),
				Self::Codecs(data) => data.to_selection(),
				Self::Streams(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod capture_device_make {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "capture_device_make";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::CaptureDeviceMake(_prisma::read_filters::StringNullableFilter::Equals(
				value,
			))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			CaptureDeviceMake,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::CaptureDeviceMake(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CaptureDeviceMake(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::CaptureDeviceMake(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::CaptureDeviceMake(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CaptureDeviceMake(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CaptureDeviceMake(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CaptureDeviceMake(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod capture_device_model {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "capture_device_model";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::CaptureDeviceModel(_prisma::read_filters::StringNullableFilter::Equals(
				value,
			))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			CaptureDeviceModel,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::CaptureDeviceModel(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CaptureDeviceModel(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::CaptureDeviceModel(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::CaptureDeviceModel(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CaptureDeviceModel(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CaptureDeviceModel(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CaptureDeviceModel(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod capture_device_software {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "capture_device_software";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::CaptureDeviceSoftware(_prisma::read_filters::StringNullableFilter::Equals(
				value,
			))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			CaptureDeviceSoftware,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::CaptureDeviceSoftware(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CaptureDeviceSoftware(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::CaptureDeviceSoftware(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::CaptureDeviceSoftware(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CaptureDeviceSoftware(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CaptureDeviceSoftware(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CaptureDeviceSoftware(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod codecs {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "codecs";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Codecs(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Codecs,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Codecs(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Codecs(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Codecs(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Codecs(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Codecs(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Codecs(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Codecs(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod duration_seconds {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "duration_seconds";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::DurationSeconds(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			DurationSeconds,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DurationSeconds(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DurationSeconds(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DurationSeconds(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DurationSeconds(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DurationSeconds(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DurationSeconds(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DurationSeconds(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod fps {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "fps";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::Fps(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			Fps,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Fps(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Fps(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Fps(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Fps(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Fps(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Fps(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Fps(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod latitude {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "latitude";
		pub fn equals(value: Option<f64>) -> WhereParam {
			WhereParam::Latitude(_prisma::read_filters::FloatNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::FloatNullableFilter,
			Latitude,
			{
				fn in_vec(_: Vec<f64>) -> InVec;
				fn not_in_vec(_: Vec<f64>) -> NotInVec;
				fn lt(_: f64) -> Lt;
				fn lte(_: f64) -> Lte;
				fn gt(_: f64) -> Gt;
				fn gte(_: f64) -> Gte;
				fn not(_: Option<f64>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Latitude(v)
			}
		}
		pub struct Set(pub Option<f64>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Latitude(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Latitude(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<f64>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::FloatNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Latitude(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Latitude(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Latitude(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Latitude(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod longitude {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "longitude";
		pub fn equals(value: Option<f64>) -> WhereParam {
			WhereParam::Longitude(_prisma::read_filters::FloatNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::FloatNullableFilter,
			Longitude,
			{
				fn in_vec(_: Vec<f64>) -> InVec;
				fn not_in_vec(_: Vec<f64>) -> NotInVec;
				fn lt(_: f64) -> Lt;
				fn lte(_: f64) -> Lte;
				fn gt(_: f64) -> Gt;
				fn gte(_: f64) -> Gte;
				fn not(_: Option<f64>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Longitude(v)
			}
		}
		pub struct Set(pub Option<f64>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Longitude(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Longitude(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<f64>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::FloatNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: f64) -> T {
			UpdateOperation(_prisma::write_params::FloatNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Longitude(_prisma::write_params::FloatNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Longitude(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Longitude(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Longitude(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectObject
		}
		pub fn is_null() -> WhereParam {
			WhereParam::ObjectIsNull
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod pixel_height {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pixel_height";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::PixelHeight(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			PixelHeight,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PixelHeight(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PixelHeight(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PixelHeight(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PixelHeight(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PixelHeight(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PixelHeight(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PixelHeight(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pixel_width {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pixel_width";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::PixelWidth(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			PixelWidth,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PixelWidth(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PixelWidth(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PixelWidth(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PixelWidth(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PixelWidth(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PixelWidth(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PixelWidth(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod streams {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "streams";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::Streams(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			Streams,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Streams(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Streams(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Streams(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Streams(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Streams(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Streams(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Streams(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.media_data().create(self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([]);
			self._params
		}
	}
	pub fn create(_params: Vec<SetParam>) -> Create {
		Create { _params }
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.media_data().create_unchecked(self.id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([id::set(self.id)]);
			self._params
		}
	}
	pub fn create_unchecked(id: i32, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { id, _params }
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pixel_width::NAME),
				::prisma_client_rust::sel(pixel_height::NAME),
				::prisma_client_rust::sel(longitude::NAME),
				::prisma_client_rust::sel(latitude::NAME),
				::prisma_client_rust::sel(fps::NAME),
				::prisma_client_rust::sel(capture_device_make::NAME),
				::prisma_client_rust::sel(capture_device_model::NAME),
				::prisma_client_rust::sel(capture_device_software::NAME),
				::prisma_client_rust::sel(duration_seconds::NAME),
				::prisma_client_rust::sel(codecs::NAME),
				::prisma_client_rust::sel(streams::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "MediaData", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pixel_width")]
		pub pixel_width: Option<i32>,
		#[serde(rename = "pixel_height")]
		pub pixel_height: Option<i32>,
		#[serde(rename = "longitude")]
		pub longitude: Option<f64>,
		#[serde(rename = "latitude")]
		pub latitude: Option<f64>,
		#[serde(rename = "fps")]
		pub fps: Option<i32>,
		#[serde(rename = "capture_device_make")]
		pub capture_device_make: Option<String>,
		#[serde(rename = "capture_device_model")]
		pub capture_device_model: Option<String>,
		#[serde(rename = "capture_device_software")]
		pub capture_device_software: Option<String>,
		#[serde(rename = "duration_seconds")]
		pub duration_seconds: Option<i32>,
		#[serde(rename = "codecs")]
		pub codecs: Option<String>,
		#[serde(rename = "streams")]
		pub streams: Option<i32>,
		#[serde(
			rename = "object",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub object: Option<Option<Box<super::object::Data>>>,
	}
	impl Data {
		pub fn object(
			&self,
		) -> Result<Option<&super::object::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_media_data { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: media_data struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pixel_width")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub pixel_width : Option < i32 > , # [serde (rename = "pixel_height")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub pixel_height : Option < i32 > , # [serde (rename = "longitude")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub longitude : Option < f64 > , # [serde (rename = "latitude")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub latitude : Option < f64 > , # [serde (rename = "fps")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub fps : Option < i32 > , # [serde (rename = "capture_device_make")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub capture_device_make : Option < String > , # [serde (rename = "capture_device_model")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub capture_device_model : Option < String > , # [serde (rename = "capture_device_software")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub capture_device_software : Option < String > , # [serde (rename = "duration_seconds")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub duration_seconds : Option < i32 > , # [serde (rename = "codecs")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub codecs : Option < String > , # [serde (rename = "streams")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub streams : Option < i32 > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_media_data as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([id::set(id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod tag {
	use super::_prisma::*;
	pub const NAME: &str = "Tag";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		Color(super::_prisma::read_filters::StringNullableFilter),
		TotalObjects(super::_prisma::read_filters::IntNullableFilter),
		RedundancyGoal(super::_prisma::read_filters::IntNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
		TagObjectsSome(Vec<super::tag_on_object::WhereParam>),
		TagObjectsEvery(Vec<super::tag_on_object::WhereParam>),
		TagObjectsNone(Vec<super::tag_on_object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Color(value) => (color::NAME, value.into()),
				Self::TotalObjects(value) => (total_objects::NAME, value.into()),
				Self::RedundancyGoal(value) => (redundancy_goal::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::TagObjectsSome(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagObjectsEvery(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagObjectsNone(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		Color(super::SortOrder),
		TotalObjects(super::SortOrder),
		RedundancyGoal(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		TagObjects(Vec<super::tag_on_object::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Color(param) => ("color", param.into()),
				Self::TotalObjects(param) => ("total_objects", param.into()),
				Self::RedundancyGoal(param) => ("redundancy_goal", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::TagObjects(param) => (
					"tag_objects",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		TagObjects(super::tag_on_object::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::TagObjects(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						tag_objects::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Color(super::_prisma::write_params::StringNullableParam),
		TotalObjects(super::_prisma::write_params::IntNullableParam),
		RedundancyGoal(super::_prisma::write_params::IntNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		ConnectTagObjects(Vec<super::tag_on_object::UniqueWhereParam>),
		DisconnectTagObjects(Vec<super::tag_on_object::UniqueWhereParam>),
		SetTagObjects(Vec<super::tag_on_object::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Color(value) => (color::NAME, value.into()),
				Self::TotalObjects(value) => (total_objects::NAME, value.into()),
				Self::RedundancyGoal(value) => (redundancy_goal::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ConnectTagObjects(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectTagObjects(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetTagObjects(where_params) => (
					tag_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::tag_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Color(super::_prisma::write_params::StringNullableParam),
		TotalObjects(super::_prisma::write_params::IntNullableParam),
		RedundancyGoal(super::_prisma::write_params::IntNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Color(value) => ("color", value.into()),
				Self::TotalObjects(value) => ("total_objects", value.into()),
				Self::RedundancyGoal(value) => ("redundancy_goal", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_tag { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: tag :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tag :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: tag :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: tag :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tag :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: tag :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , color , total_objects , redundancy_goal , date_created , date_modified , tag_objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: tag :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: tag :: $ field :: NAME)] pub $ field : crate :: prisma :: tag :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: tag :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: tag :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: tag :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "color" , "total_objects" , "redundancy_goal" , "date_created" , "date_modified" , "tag_objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: tag :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pub_id) => { Vec < u8 > } ; (@ field_type ; name) => { Option < String > } ; (@ field_type ; color) => { Option < String > } ; (@ field_type ; total_objects) => { Option < i32 > } ; (@ field_type ; redundancy_goal) => { Option < i32 > } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_modified) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; tag_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tag_objects :: Data > } ; (@ field_type ; tag_objects) => { Vec < crate :: prisma :: tag_on_object :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Tag" , available relations are "id, pub_id, name, color, total_objects, redundancy_goal, date_created, date_modified, tag_objects")) } ; (@ field_module ; tag_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: tag_on_object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: name :: Select) } ; (@ selection_field_to_selection_param ; color) => { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: color :: Select) } ; (@ selection_field_to_selection_param ; total_objects) => { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: total_objects :: Select) } ; (@ selection_field_to_selection_param ; redundancy_goal) => { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: redundancy_goal :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; tag_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: tag_objects :: Select :: $ selection_mode (crate :: prisma :: tag_on_object :: ManyArgs :: new (crate :: prisma :: tag_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tag_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: tag :: SelectParam > :: into (crate :: prisma :: tag :: tag_objects :: Select :: Fetch (crate :: prisma :: tag_on_object :: ManyArgs :: new (crate :: prisma :: tag_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: tag :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; color) => { "color" } ; (@ field_serde_name ; total_objects) => { "total_objects" } ; (@ field_serde_name ; redundancy_goal) => { "redundancy_goal" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; tag_objects) => { "tag_objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_tag as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		Color(color::Select),
		TotalObjects(total_objects::Select),
		RedundancyGoal(redundancy_goal::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		TagObjects(tag_objects::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Color(data) => data.to_selection(),
				Self::TotalObjects(data) => data.to_selection(),
				Self::RedundancyGoal(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::TagObjects(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_tag { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: tag :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tag :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: tag :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: tag :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: tag :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tag :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: tag :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: tag :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { tag_objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: tag :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: tag :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: tag :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: tag :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = crate :: prisma :: tag :: color :: NAME)] pub color : Option < String > , # [specta (rename_from_path = crate :: prisma :: tag :: total_objects :: NAME)] pub total_objects : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: tag :: redundancy_goal :: NAME)] pub redundancy_goal : Option < i32 > , # [specta (rename_from_path = crate :: prisma :: tag :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: tag :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: prisma :: tag :: $ field :: NAME)] pub $ field : crate :: prisma :: tag :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (color) , stringify ! (total_objects) , stringify ! (redundancy_goal) , stringify ! (date_created) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: tag :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: tag :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: tag :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (crate :: prisma :: tag :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: tag :: color :: NAME , & self . color) ? ; state . serialize_field (crate :: prisma :: tag :: total_objects :: NAME , & self . total_objects) ? ; state . serialize_field (crate :: prisma :: tag :: redundancy_goal :: NAME , & self . redundancy_goal) ? ; state . serialize_field (crate :: prisma :: tag :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: tag :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , color , total_objects , redundancy_goal , date_created , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: tag :: $ field :: NAME) , + , crate :: prisma :: tag :: id :: NAME , crate :: prisma :: tag :: pub_id :: NAME , crate :: prisma :: tag :: name :: NAME , crate :: prisma :: tag :: color :: NAME , crate :: prisma :: tag :: total_objects :: NAME , crate :: prisma :: tag :: redundancy_goal :: NAME , crate :: prisma :: tag :: date_created :: NAME , crate :: prisma :: tag :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: tag :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: tag :: id :: NAME => Ok (Field :: id) , crate :: prisma :: tag :: pub_id :: NAME => Ok (Field :: pub_id) , crate :: prisma :: tag :: name :: NAME => Ok (Field :: name) , crate :: prisma :: tag :: color :: NAME => Ok (Field :: color) , crate :: prisma :: tag :: total_objects :: NAME => Ok (Field :: total_objects) , crate :: prisma :: tag :: redundancy_goal :: NAME => Ok (Field :: redundancy_goal) , crate :: prisma :: tag :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: tag :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut color = None ; let mut total_objects = None ; let mut redundancy_goal = None ; let mut date_created = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: color => { if color . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: color :: NAME)) ; } color = Some (map . next_value () ?) ; } Field :: total_objects => { if total_objects . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: total_objects :: NAME)) ; } total_objects = Some (map . next_value () ?) ; } Field :: redundancy_goal => { if redundancy_goal . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: redundancy_goal :: NAME)) ; } redundancy_goal = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: name :: NAME)) ? ; let color = color . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: color :: NAME)) ? ; let total_objects = total_objects . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: total_objects :: NAME)) ? ; let redundancy_goal = redundancy_goal . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: redundancy_goal :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag :: date_modified :: NAME)) ? ; Ok (Data { id , pub_id , name , color , total_objects , redundancy_goal , date_created , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "color" , "total_objects" , "redundancy_goal" , "date_created" , "date_modified" , "tag_objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: tag :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; tag_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tag_objects :: Data > } ; (@ field_type ; tag_objects) => { Vec < crate :: prisma :: tag_on_object :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Tag" , available relations are "tag_objects")) } ; (@ field_module ; tag_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: tag_on_object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; tag_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: tag :: IncludeParam > :: into (crate :: prisma :: tag :: tag_objects :: Include :: $ selection_mode (crate :: prisma :: tag_on_object :: ManyArgs :: new (crate :: prisma :: tag_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tag_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: tag :: IncludeParam > :: into (crate :: prisma :: tag :: tag_objects :: Include :: Fetch (crate :: prisma :: tag_on_object :: ManyArgs :: new (crate :: prisma :: tag_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: tag :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; color) => { "color" } ; (@ field_serde_name ; total_objects) => { "total_objects" } ; (@ field_serde_name ; redundancy_goal) => { "redundancy_goal" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; tag_objects) => { "tag_objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_tag as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		Color(color::Include),
		TotalObjects(total_objects::Include),
		RedundancyGoal(redundancy_goal::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		TagObjects(tag_objects::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Color(data) => data.to_selection(),
				Self::TotalObjects(data) => data.to_selection(),
				Self::RedundancyGoal(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::TagObjects(data) => data.to_selection(),
			}
		}
	}
	pub mod color {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "color";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Color(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Color,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Color(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Color(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Color(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Color(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Color(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Color(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Color(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod redundancy_goal {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "redundancy_goal";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::RedundancyGoal(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			RedundancyGoal,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::RedundancyGoal(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RedundancyGoal(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::RedundancyGoal(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::RedundancyGoal(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RedundancyGoal(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::RedundancyGoal(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::RedundancyGoal(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod tag_objects {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "tag_objects";
		pub fn some(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagObjectsSome(value)
		}
		pub fn every(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagObjectsEvery(value)
		}
		pub fn none(value: Vec<tag_on_object::WhereParam>) -> WhereParam {
			WhereParam::TagObjectsNone(value)
		}
		pub struct Order(Vec<tag_on_object::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<tag_on_object::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TagObjects(v)
			}
		}
		pub struct Fetch(pub tag_on_object::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<tag_on_object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: tag_on_object::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: tag_on_object::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::TagObjects(v)
			}
		}
		pub fn fetch(params: Vec<tag_on_object::WhereParam>) -> Fetch {
			Fetch(tag_on_object::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<tag_on_object::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectTagObjects(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<tag_on_object::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<tag_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectTagObjects(params)
		}
		pub fn set(params: Vec<tag_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::SetTagObjects(params)
		}
		pub enum Select {
			Select(tag_on_object::ManyArgs, Vec<tag_on_object::SelectParam>),
			Include(tag_on_object::ManyArgs, Vec<tag_on_object::IncludeParam>),
			Fetch(tag_on_object::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TagObjects(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(tag_on_object::ManyArgs, Vec<tag_on_object::SelectParam>),
			Include(tag_on_object::ManyArgs, Vec<tag_on_object::IncludeParam>),
			Fetch(tag_on_object::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TagObjects(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: tag_on_object::ManyArgs,
				nested_selections: Vec<tag_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod total_objects {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "total_objects";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::TotalObjects(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			TotalObjects,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TotalObjects(v)
			}
		}
		pub struct Set(pub Option<i32>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalObjects(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalObjects(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TotalObjects(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TotalObjects(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TotalObjects(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TotalObjects(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.tag().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.tag().create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(color::NAME),
				::prisma_client_rust::sel(total_objects::NAME),
				::prisma_client_rust::sel(redundancy_goal::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Tag", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pub_id")]
		pub pub_id: Vec<u8>,
		#[serde(rename = "name")]
		pub name: Option<String>,
		#[serde(rename = "color")]
		pub color: Option<String>,
		#[serde(rename = "total_objects")]
		pub total_objects: Option<i32>,
		#[serde(rename = "redundancy_goal")]
		pub redundancy_goal: Option<i32>,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_modified")]
		pub date_modified:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "tag_objects")]
		#[specta(skip)]
		pub tag_objects: Option<Vec<super::tag_on_object::Data>>,
	}
	impl Data {
		pub fn tag_objects(
			&self,
		) -> Result<&Vec<super::tag_on_object::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.tag_objects
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(tag_objects),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_tag { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: tag struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "color")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub color : Option < String > , # [serde (rename = "total_objects")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub total_objects : Option < i32 > , # [serde (rename = "redundancy_goal")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub redundancy_goal : Option < i32 > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_tag as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod tag_on_object {
	use super::_prisma::*;
	pub const NAME: &str = "TagOnObject";
	pub fn tag_id_object_id<T: From<UniqueWhereParam>>(tag_id: i32, object_id: i32) -> T {
		UniqueWhereParam::TagIdObjectIdEquals(tag_id, object_id).into()
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		TagIdObjectIdEquals(i32, i32),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		TagId(super::_prisma::read_filters::IntFilter),
		TagIs(Vec<super::tag::WhereParam>),
		TagIsNot(Vec<super::tag::WhereParam>),
		ObjectId(super::_prisma::read_filters::IntFilter),
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::TagIdObjectIdEquals(tag_id, object_id) => (
					"tag_id_object_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							tag_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(tag_id as i64),
						),
						(
							object_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(object_id as i64),
						),
					]),
				),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::TagId(value) => (tag_id::NAME, value.into()),
				Self::TagIs(where_params) => (
					tag::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::TagIsNot(where_params) => (
					tag::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		TagIdObjectIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::TagIdObjectIdEquals(tag_id, object_id) => {
					Self::TagIdObjectIdEquals(tag_id, object_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		DateCreated(super::SortOrder),
		TagId(super::SortOrder),
		ObjectId(super::SortOrder),
		Tag(Vec<super::tag::OrderByWithRelationParam>),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::TagId(param) => ("tag_id", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::Tag(param) => (
					"tag",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Tag(super::tag::UniqueArgs),
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Tag(args) => {
					let mut selections =
						<super::tag::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(tag::NAME, None, [], selections)
				}
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		TagId(super::_prisma::write_params::IntParam),
		ConnectTag(super::tag::UniqueWhereParam),
		ObjectId(super::_prisma::write_params::IntParam),
		ConnectObject(super::object::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::TagId(value) => (tag_id::NAME, value.into()),
				Self::ConnectTag(where_param) => (
					tag::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::tag::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		TagId(super::_prisma::write_params::IntParam),
		ObjectId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::TagId(value) => ("tag_id", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_tag_on_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: tag_on_object :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tag_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: tag_on_object :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tag_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: tag_on_object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { date_created , tag_id , tag , object_id , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: tag_on_object :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: tag_on_object :: $ field :: NAME)] pub $ field : crate :: prisma :: tag_on_object :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: tag_on_object :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: tag_on_object :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: tag_on_object :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag_on_object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag_on_object :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "tag_id" , "tag" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: tag_on_object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; tag_id) => { i32 } ; (@ field_type ; tag : $ selection_mode : ident { $ ($ selections : tt) + }) => { tag :: Data } ; (@ field_type ; tag) => { crate :: prisma :: tag :: Data } ; (@ field_type ; object_id) => { i32 } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; object) => { crate :: prisma :: object :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TagOnObject" , available relations are "date_created, tag_id, tag, object_id, object")) } ; (@ field_module ; tag : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: tag :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: tag_on_object :: SelectParam > :: into (crate :: prisma :: tag_on_object :: date_created :: Select) } ; (@ selection_field_to_selection_param ; tag_id) => { Into :: < crate :: prisma :: tag_on_object :: SelectParam > :: into (crate :: prisma :: tag_on_object :: tag_id :: Select) } ; (@ selection_field_to_selection_param ; tag $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: tag_on_object :: SelectParam > :: into (crate :: prisma :: tag_on_object :: tag :: Select :: $ selection_mode (crate :: prisma :: tag :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tag $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: tag_on_object :: SelectParam > :: into (crate :: prisma :: tag_on_object :: tag :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < crate :: prisma :: tag_on_object :: SelectParam > :: into (crate :: prisma :: tag_on_object :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: tag_on_object :: SelectParam > :: into (crate :: prisma :: tag_on_object :: object :: Select :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: tag_on_object :: SelectParam > :: into (crate :: prisma :: tag_on_object :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: tag_on_object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; tag_id) => { "tag_id" } ; (@ field_serde_name ; tag) => { "tag" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_tag_on_object as select;
	pub enum SelectParam {
		DateCreated(date_created::Select),
		TagId(tag_id::Select),
		Tag(tag::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::TagId(data) => data.to_selection(),
				Self::Tag(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_tag_on_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: tag_on_object :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tag_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: tag_on_object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: tag_on_object :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: tag_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: tag_on_object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { tag , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: tag_on_object :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: tag_on_object :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: tag_on_object :: tag_id :: NAME)] pub tag_id : i32 , # [specta (rename_from_path = crate :: prisma :: tag_on_object :: object_id :: NAME)] pub object_id : i32 , $ (# [specta (rename_from_path = crate :: prisma :: tag_on_object :: $ field :: NAME)] pub $ field : crate :: prisma :: tag_on_object :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (date_created) , stringify ! (tag_id) , stringify ! (object_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: tag_on_object :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: tag_on_object :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: tag_on_object :: tag_id :: NAME , & self . tag_id) ? ; state . serialize_field (crate :: prisma :: tag_on_object :: object_id :: NAME , & self . object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , date_created , tag_id , object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: tag_on_object :: $ field :: NAME) , + , crate :: prisma :: tag_on_object :: date_created :: NAME , crate :: prisma :: tag_on_object :: tag_id :: NAME , crate :: prisma :: tag_on_object :: object_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: tag_on_object :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: tag_on_object :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: tag_on_object :: tag_id :: NAME => Ok (Field :: tag_id) , crate :: prisma :: tag_on_object :: object_id :: NAME => Ok (Field :: object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut date_created = None ; let mut tag_id = None ; let mut object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag_on_object :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: tag_id => { if tag_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag_on_object :: tag_id :: NAME)) ; } tag_id = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag_on_object :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: tag_on_object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag_on_object :: $ field :: NAME)) ? ;) * let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag_on_object :: date_created :: NAME)) ? ; let tag_id = tag_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag_on_object :: tag_id :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: tag_on_object :: object_id :: NAME)) ? ; Ok (Data { date_created , tag_id , object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "tag_id" , "tag" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: tag_on_object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; tag : $ selection_mode : ident { $ ($ selections : tt) + }) => { tag :: Data } ; (@ field_type ; tag) => { crate :: prisma :: tag :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; object) => { crate :: prisma :: object :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "TagOnObject" , available relations are "tag, object")) } ; (@ field_module ; tag : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: tag :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; tag $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: tag_on_object :: IncludeParam > :: into (crate :: prisma :: tag_on_object :: tag :: Include :: $ selection_mode (crate :: prisma :: tag :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tag $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: tag_on_object :: IncludeParam > :: into (crate :: prisma :: tag_on_object :: tag :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: tag_on_object :: IncludeParam > :: into (crate :: prisma :: tag_on_object :: object :: Include :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: tag_on_object :: IncludeParam > :: into (crate :: prisma :: tag_on_object :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: tag_on_object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; tag_id) => { "tag_id" } ; (@ field_serde_name ; tag) => { "tag" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_tag_on_object as include;
	pub enum IncludeParam {
		DateCreated(date_created::Include),
		TagId(tag_id::Include),
		Tag(tag::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::TagId(data) => data.to_selection(),
				Self::Tag(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod tag {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "tag";
		pub fn is(value: Vec<tag::WhereParam>) -> WhereParam {
			WhereParam::TagIs(value)
		}
		pub fn is_not(value: Vec<tag::WhereParam>) -> WhereParam {
			WhereParam::TagIsNot(value)
		}
		pub struct Order(Vec<tag::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<tag::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Tag(v)
			}
		}
		pub struct Fetch(pub tag::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<tag::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Tag(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(tag::UniqueArgs::new())
		}
		pub struct Connect(tag::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectTag(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: tag::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<tag::SelectParam>),
			Include(Vec<tag::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Tag(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<tag::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("tag", None, [], selections)
			}
			pub fn select(nested_selections: Vec<tag::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<tag::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<tag::SelectParam>),
			Include(Vec<tag::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Tag(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<tag::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<tag::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("tag", None, [], selections)
			}
			pub fn select(nested_selections: Vec<tag::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<tag::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod tag_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "tag_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::TagId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, TagId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TagId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TagId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TagId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TagId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TagId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub tag: super::tag::UniqueWhereParam,
		pub object: super::object::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.tag_on_object()
				.create(self.tag, self.object, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([tag::connect(self.tag), object::connect(self.object)]);
			self._params
		}
	}
	pub fn create(
		tag: super::tag::UniqueWhereParam,
		object: super::object::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			tag,
			object,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub tag_id: i32,
		pub object_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.tag_on_object()
				.create_unchecked(self.tag_id, self.object_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([tag_id::set(self.tag_id), object_id::set(self.object_id)]);
			self._params
		}
	}
	pub fn create_unchecked(
		tag_id: i32,
		object_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			tag_id,
			object_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(tag_id::NAME),
				::prisma_client_rust::sel(object_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "TagOnObject", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "tag_id")]
		pub tag_id: i32,
		#[serde(rename = "tag")]
		#[specta(skip)]
		pub tag: Option<Box<super::tag::Data>>,
		#[serde(rename = "object_id")]
		pub object_id: i32,
		#[serde(rename = "object")]
		#[specta(skip)]
		pub object: Option<Box<super::object::Data>>,
	}
	impl Data {
		pub fn tag(
			&self,
		) -> Result<&super::tag::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.tag
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(tag),
				))
				.map(|v| v.as_ref())
		}
		pub fn object(
			&self,
		) -> Result<&super::object::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_tag_on_object { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: tag_on_object struct $ struct_name { # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "tag_id")] pub tag_id : i32 , # [serde (rename = "object_id")] pub object_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_tag_on_object as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			tag: super::tag::UniqueWhereParam,
			object: super::object::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([tag::connect(tag), object::connect(object)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			tag_id: i32,
			object_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([tag_id::set(tag_id), object_id::set(object_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod label {
	use super::_prisma::*;
	pub const NAME: &str = "Label";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
		LabelObjectsSome(Vec<super::label_on_object::WhereParam>),
		LabelObjectsEvery(Vec<super::label_on_object::WhereParam>),
		LabelObjectsNone(Vec<super::label_on_object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::LabelObjectsSome(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelObjectsEvery(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelObjectsNone(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		LabelObjects(Vec<super::label_on_object::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::LabelObjects(param) => (
					"label_objects",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		LabelObjects(super::label_on_object::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::LabelObjects(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						label_objects::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		ConnectLabelObjects(Vec<super::label_on_object::UniqueWhereParam>),
		DisconnectLabelObjects(Vec<super::label_on_object::UniqueWhereParam>),
		SetLabelObjects(Vec<super::label_on_object::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ConnectLabelObjects(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectLabelObjects(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetLabelObjects(where_params) => (
					label_objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::label_on_object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_label { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: label :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: label :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: label :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: label :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: label :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: label :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , date_created , date_modified , label_objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: label :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: label :: $ field :: NAME)] pub $ field : crate :: prisma :: label :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: label :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: label :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: label :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "date_created" , "date_modified" , "label_objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: label :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pub_id) => { Vec < u8 > } ; (@ field_type ; name) => { Option < String > } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_modified) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; label_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < label_objects :: Data > } ; (@ field_type ; label_objects) => { Vec < crate :: prisma :: label_on_object :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Label" , available relations are "id, pub_id, name, date_created, date_modified, label_objects")) } ; (@ field_module ; label_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: label_on_object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: label :: SelectParam > :: into (crate :: prisma :: label :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < crate :: prisma :: label :: SelectParam > :: into (crate :: prisma :: label :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: label :: SelectParam > :: into (crate :: prisma :: label :: name :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: label :: SelectParam > :: into (crate :: prisma :: label :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < crate :: prisma :: label :: SelectParam > :: into (crate :: prisma :: label :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; label_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: label :: SelectParam > :: into (crate :: prisma :: label :: label_objects :: Select :: $ selection_mode (crate :: prisma :: label_on_object :: ManyArgs :: new (crate :: prisma :: label_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: label_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; label_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: label :: SelectParam > :: into (crate :: prisma :: label :: label_objects :: Select :: Fetch (crate :: prisma :: label_on_object :: ManyArgs :: new (crate :: prisma :: label_on_object :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: label :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; label_objects) => { "label_objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_label as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		LabelObjects(label_objects::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::LabelObjects(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_label { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: label :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: label :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: label :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: label :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: label :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: label :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: label :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: label :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { label_objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: label :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: label :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: label :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: label :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = crate :: prisma :: label :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: label :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: prisma :: label :: $ field :: NAME)] pub $ field : crate :: prisma :: label :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (date_created) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: label :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: label :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: label :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (crate :: prisma :: label :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: label :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: label :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , date_created , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: label :: $ field :: NAME) , + , crate :: prisma :: label :: id :: NAME , crate :: prisma :: label :: pub_id :: NAME , crate :: prisma :: label :: name :: NAME , crate :: prisma :: label :: date_created :: NAME , crate :: prisma :: label :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: label :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: label :: id :: NAME => Ok (Field :: id) , crate :: prisma :: label :: pub_id :: NAME => Ok (Field :: pub_id) , crate :: prisma :: label :: name :: NAME => Ok (Field :: name) , crate :: prisma :: label :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: label :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut date_created = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label :: name :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label :: date_modified :: NAME)) ? ; Ok (Data { id , pub_id , name , date_created , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "date_created" , "date_modified" , "label_objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: label :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; label_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < label_objects :: Data > } ; (@ field_type ; label_objects) => { Vec < crate :: prisma :: label_on_object :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Label" , available relations are "label_objects")) } ; (@ field_module ; label_objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: label_on_object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; label_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: label :: IncludeParam > :: into (crate :: prisma :: label :: label_objects :: Include :: $ selection_mode (crate :: prisma :: label_on_object :: ManyArgs :: new (crate :: prisma :: label_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: label_on_object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; label_objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: label :: IncludeParam > :: into (crate :: prisma :: label :: label_objects :: Include :: Fetch (crate :: prisma :: label_on_object :: ManyArgs :: new (crate :: prisma :: label_on_object :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: label :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; label_objects) => { "label_objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_label as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		LabelObjects(label_objects::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::LabelObjects(data) => data.to_selection(),
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod label_objects {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "label_objects";
		pub fn some(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelObjectsSome(value)
		}
		pub fn every(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelObjectsEvery(value)
		}
		pub fn none(value: Vec<label_on_object::WhereParam>) -> WhereParam {
			WhereParam::LabelObjectsNone(value)
		}
		pub struct Order(Vec<label_on_object::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<label_on_object::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LabelObjects(v)
			}
		}
		pub struct Fetch(pub label_on_object::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<label_on_object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: label_on_object::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: label_on_object::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::LabelObjects(v)
			}
		}
		pub fn fetch(params: Vec<label_on_object::WhereParam>) -> Fetch {
			Fetch(label_on_object::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<label_on_object::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLabelObjects(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<label_on_object::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<label_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectLabelObjects(params)
		}
		pub fn set(params: Vec<label_on_object::UniqueWhereParam>) -> SetParam {
			SetParam::SetLabelObjects(params)
		}
		pub enum Select {
			Select(label_on_object::ManyArgs, Vec<label_on_object::SelectParam>),
			Include(
				label_on_object::ManyArgs,
				Vec<label_on_object::IncludeParam>,
			),
			Fetch(label_on_object::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LabelObjects(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(label_on_object::ManyArgs, Vec<label_on_object::SelectParam>),
			Include(
				label_on_object::ManyArgs,
				Vec<label_on_object::IncludeParam>,
			),
			Fetch(label_on_object::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LabelObjects(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: label_on_object::ManyArgs,
				nested_selections: Vec<label_on_object::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.label().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.label().create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Label", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pub_id")]
		pub pub_id: Vec<u8>,
		#[serde(rename = "name")]
		pub name: Option<String>,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_modified")]
		pub date_modified:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "label_objects")]
		#[specta(skip)]
		pub label_objects: Option<Vec<super::label_on_object::Data>>,
	}
	impl Data {
		pub fn label_objects(
			&self,
		) -> Result<&Vec<super::label_on_object::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.label_objects
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(label_objects),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_label { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: label struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_label as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod label_on_object {
	use super::_prisma::*;
	pub const NAME: &str = "LabelOnObject";
	pub fn label_id_object_id<T: From<UniqueWhereParam>>(label_id: i32, object_id: i32) -> T {
		UniqueWhereParam::LabelIdObjectIdEquals(label_id, object_id).into()
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LabelIdObjectIdEquals(i32, i32),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		LabelId(super::_prisma::read_filters::IntFilter),
		LabelIs(Vec<super::label::WhereParam>),
		LabelIsNot(Vec<super::label::WhereParam>),
		ObjectId(super::_prisma::read_filters::IntFilter),
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::LabelIdObjectIdEquals(label_id, object_id) => (
					"label_id_object_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							label_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(label_id as i64),
						),
						(
							object_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(object_id as i64),
						),
					]),
				),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::LabelId(value) => (label_id::NAME, value.into()),
				Self::LabelIs(where_params) => (
					label::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LabelIsNot(where_params) => (
					label::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		LabelIdObjectIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::LabelIdObjectIdEquals(label_id, object_id) => {
					Self::LabelIdObjectIdEquals(label_id, object_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		DateCreated(super::SortOrder),
		LabelId(super::SortOrder),
		ObjectId(super::SortOrder),
		Label(Vec<super::label::OrderByWithRelationParam>),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::LabelId(param) => ("label_id", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::Label(param) => (
					"label",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Label(super::label::UniqueArgs),
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Label(args) => {
					let mut selections = < super :: label :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(label::NAME, None, [], selections)
				}
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		LabelId(super::_prisma::write_params::IntParam),
		ConnectLabel(super::label::UniqueWhereParam),
		ObjectId(super::_prisma::write_params::IntParam),
		ConnectObject(super::object::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::LabelId(value) => (label_id::NAME, value.into()),
				Self::ConnectLabel(where_param) => (
					label::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::label::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		LabelId(super::_prisma::write_params::IntParam),
		ObjectId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::LabelId(value) => ("label_id", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_label_on_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: label_on_object :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: label_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: label_on_object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: label_on_object :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: label_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: label_on_object :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { date_created , label_id , label , object_id , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: label_on_object :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: label_on_object :: $ field :: NAME)] pub $ field : crate :: prisma :: label_on_object :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: label_on_object :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: label_on_object :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: label_on_object :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label_on_object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label_on_object :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "label_id" , "label" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: label_on_object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; label_id) => { i32 } ; (@ field_type ; label : $ selection_mode : ident { $ ($ selections : tt) + }) => { label :: Data } ; (@ field_type ; label) => { crate :: prisma :: label :: Data } ; (@ field_type ; object_id) => { i32 } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; object) => { crate :: prisma :: object :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "LabelOnObject" , available relations are "date_created, label_id, label, object_id, object")) } ; (@ field_module ; label : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: label :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: label_on_object :: SelectParam > :: into (crate :: prisma :: label_on_object :: date_created :: Select) } ; (@ selection_field_to_selection_param ; label_id) => { Into :: < crate :: prisma :: label_on_object :: SelectParam > :: into (crate :: prisma :: label_on_object :: label_id :: Select) } ; (@ selection_field_to_selection_param ; label $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: label_on_object :: SelectParam > :: into (crate :: prisma :: label_on_object :: label :: Select :: $ selection_mode (crate :: prisma :: label :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; label $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: label_on_object :: SelectParam > :: into (crate :: prisma :: label_on_object :: label :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < crate :: prisma :: label_on_object :: SelectParam > :: into (crate :: prisma :: label_on_object :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: label_on_object :: SelectParam > :: into (crate :: prisma :: label_on_object :: object :: Select :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: label_on_object :: SelectParam > :: into (crate :: prisma :: label_on_object :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: label_on_object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; label_id) => { "label_id" } ; (@ field_serde_name ; label) => { "label" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_label_on_object as select;
	pub enum SelectParam {
		DateCreated(date_created::Select),
		LabelId(label_id::Select),
		Label(label::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::LabelId(data) => data.to_selection(),
				Self::Label(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_label_on_object { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: label_on_object :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: label_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: label_on_object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: label_on_object :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: label_on_object :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: label_on_object :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { label , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: label_on_object :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: label_on_object :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: label_on_object :: label_id :: NAME)] pub label_id : i32 , # [specta (rename_from_path = crate :: prisma :: label_on_object :: object_id :: NAME)] pub object_id : i32 , $ (# [specta (rename_from_path = crate :: prisma :: label_on_object :: $ field :: NAME)] pub $ field : crate :: prisma :: label_on_object :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (date_created) , stringify ! (label_id) , stringify ! (object_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: label_on_object :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: label_on_object :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: label_on_object :: label_id :: NAME , & self . label_id) ? ; state . serialize_field (crate :: prisma :: label_on_object :: object_id :: NAME , & self . object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , date_created , label_id , object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: label_on_object :: $ field :: NAME) , + , crate :: prisma :: label_on_object :: date_created :: NAME , crate :: prisma :: label_on_object :: label_id :: NAME , crate :: prisma :: label_on_object :: object_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: label_on_object :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: label_on_object :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: label_on_object :: label_id :: NAME => Ok (Field :: label_id) , crate :: prisma :: label_on_object :: object_id :: NAME => Ok (Field :: object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut date_created = None ; let mut label_id = None ; let mut object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label_on_object :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: label_id => { if label_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label_on_object :: label_id :: NAME)) ; } label_id = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label_on_object :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: label_on_object :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label_on_object :: $ field :: NAME)) ? ;) * let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label_on_object :: date_created :: NAME)) ? ; let label_id = label_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label_on_object :: label_id :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: label_on_object :: object_id :: NAME)) ? ; Ok (Data { date_created , label_id , object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "label_id" , "label" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: label_on_object :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; label : $ selection_mode : ident { $ ($ selections : tt) + }) => { label :: Data } ; (@ field_type ; label) => { crate :: prisma :: label :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; object) => { crate :: prisma :: object :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "LabelOnObject" , available relations are "label, object")) } ; (@ field_module ; label : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: label :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; label $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: label_on_object :: IncludeParam > :: into (crate :: prisma :: label_on_object :: label :: Include :: $ selection_mode (crate :: prisma :: label :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; label $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: label_on_object :: IncludeParam > :: into (crate :: prisma :: label_on_object :: label :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: label_on_object :: IncludeParam > :: into (crate :: prisma :: label_on_object :: object :: Include :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: label_on_object :: IncludeParam > :: into (crate :: prisma :: label_on_object :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: label_on_object :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; label_id) => { "label_id" } ; (@ field_serde_name ; label) => { "label" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_label_on_object as include;
	pub enum IncludeParam {
		DateCreated(date_created::Include),
		LabelId(label_id::Include),
		Label(label::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::LabelId(data) => data.to_selection(),
				Self::Label(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod label {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "label";
		pub fn is(value: Vec<label::WhereParam>) -> WhereParam {
			WhereParam::LabelIs(value)
		}
		pub fn is_not(value: Vec<label::WhereParam>) -> WhereParam {
			WhereParam::LabelIsNot(value)
		}
		pub struct Order(Vec<label::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<label::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Label(v)
			}
		}
		pub struct Fetch(pub label::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<label::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Label(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(label::UniqueArgs::new())
		}
		pub struct Connect(label::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLabel(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: label::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<label::SelectParam>),
			Include(Vec<label::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Label(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<label::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("label", None, [], selections)
			}
			pub fn select(nested_selections: Vec<label::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<label::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<label::SelectParam>),
			Include(Vec<label::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Label(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<label::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<label::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("label", None, [], selections)
			}
			pub fn select(nested_selections: Vec<label::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<label::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod label_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "label_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::LabelId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, LabelId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LabelId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LabelId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LabelId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LabelId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LabelId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub label: super::label::UniqueWhereParam,
		pub object: super::object::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.label_on_object()
				.create(self.label, self.object, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([label::connect(self.label), object::connect(self.object)]);
			self._params
		}
	}
	pub fn create(
		label: super::label::UniqueWhereParam,
		object: super::object::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			label,
			object,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub label_id: i32,
		pub object_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.label_on_object()
				.create_unchecked(self.label_id, self.object_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([label_id::set(self.label_id), object_id::set(self.object_id)]);
			self._params
		}
	}
	pub fn create_unchecked(
		label_id: i32,
		object_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			label_id,
			object_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(label_id::NAME),
				::prisma_client_rust::sel(object_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "LabelOnObject", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "label_id")]
		pub label_id: i32,
		#[serde(rename = "label")]
		#[specta(skip)]
		pub label: Option<Box<super::label::Data>>,
		#[serde(rename = "object_id")]
		pub object_id: i32,
		#[serde(rename = "object")]
		#[specta(skip)]
		pub object: Option<Box<super::object::Data>>,
	}
	impl Data {
		pub fn label(
			&self,
		) -> Result<&super::label::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.label
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(label),
				))
				.map(|v| v.as_ref())
		}
		pub fn object(
			&self,
		) -> Result<&super::object::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_label_on_object { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: label_on_object struct $ struct_name { # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "label_id")] pub label_id : i32 , # [serde (rename = "object_id")] pub object_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_label_on_object as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			label: super::label::UniqueWhereParam,
			object: super::object::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([label::connect(label), object::connect(object)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			label_id: i32,
			object_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([label_id::set(label_id), object_id::set(object_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod space {
	use super::_prisma::*;
	pub const NAME: &str = "Space";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringNullableFilter),
		Description(super::_prisma::read_filters::StringNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
		ObjectsSome(Vec<super::object_in_space::WhereParam>),
		ObjectsEvery(Vec<super::object_in_space::WhereParam>),
		ObjectsNone(Vec<super::object_in_space::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Description(value) => (description::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ObjectsSome(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectsEvery(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectsNone(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		Description(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		Objects(Vec<super::object_in_space::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Description(param) => ("description", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::Objects(param) => (
					"objects",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Objects(super::object_in_space::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Objects(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						objects::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Description(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		ConnectObjects(Vec<super::object_in_space::UniqueWhereParam>),
		DisconnectObjects(Vec<super::object_in_space::UniqueWhereParam>),
		SetObjects(Vec<super::object_in_space::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Description(value) => (description::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ConnectObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringNullableParam),
		Description(super::_prisma::write_params::StringNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Description(value) => ("description", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_space { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: space :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: space :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: space :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: space :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , description , date_created , date_modified , objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: space :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: space :: $ field :: NAME)] pub $ field : crate :: prisma :: space :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: space :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: space :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: space :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: space :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: space :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "description" , "date_created" , "date_modified" , "objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: space :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pub_id) => { Vec < u8 > } ; (@ field_type ; name) => { Option < String > } ; (@ field_type ; description) => { Option < String > } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_modified) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < objects :: Data > } ; (@ field_type ; objects) => { Vec < crate :: prisma :: object_in_space :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Space" , available relations are "id, pub_id, name, description, date_created, date_modified, objects")) } ; (@ field_module ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object_in_space :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: space :: SelectParam > :: into (crate :: prisma :: space :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < crate :: prisma :: space :: SelectParam > :: into (crate :: prisma :: space :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: space :: SelectParam > :: into (crate :: prisma :: space :: name :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < crate :: prisma :: space :: SelectParam > :: into (crate :: prisma :: space :: description :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: space :: SelectParam > :: into (crate :: prisma :: space :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < crate :: prisma :: space :: SelectParam > :: into (crate :: prisma :: space :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: space :: SelectParam > :: into (crate :: prisma :: space :: objects :: Select :: $ selection_mode (crate :: prisma :: object_in_space :: ManyArgs :: new (crate :: prisma :: object_in_space :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object_in_space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: space :: SelectParam > :: into (crate :: prisma :: space :: objects :: Select :: Fetch (crate :: prisma :: object_in_space :: ManyArgs :: new (crate :: prisma :: object_in_space :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: space :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; objects) => { "objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_space as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		Description(description::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		Objects(objects::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Objects(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_space { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: space :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: space :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: space :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: space :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: space :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: space :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: space :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: space :: name :: NAME)] pub name : Option < String > , # [specta (rename_from_path = crate :: prisma :: space :: description :: NAME)] pub description : Option < String > , # [specta (rename_from_path = crate :: prisma :: space :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: space :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: prisma :: space :: $ field :: NAME)] pub $ field : crate :: prisma :: space :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (description) , stringify ! (date_created) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: space :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: space :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: space :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (crate :: prisma :: space :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: space :: description :: NAME , & self . description) ? ; state . serialize_field (crate :: prisma :: space :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: space :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , description , date_created , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: space :: $ field :: NAME) , + , crate :: prisma :: space :: id :: NAME , crate :: prisma :: space :: pub_id :: NAME , crate :: prisma :: space :: name :: NAME , crate :: prisma :: space :: description :: NAME , crate :: prisma :: space :: date_created :: NAME , crate :: prisma :: space :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: space :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: space :: id :: NAME => Ok (Field :: id) , crate :: prisma :: space :: pub_id :: NAME => Ok (Field :: pub_id) , crate :: prisma :: space :: name :: NAME => Ok (Field :: name) , crate :: prisma :: space :: description :: NAME => Ok (Field :: description) , crate :: prisma :: space :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: space :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut description = None ; let mut date_created = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: space :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: space :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: space :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: space :: description :: NAME)) ; } description = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: space :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: space :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: space :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: space :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: space :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: space :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: space :: name :: NAME)) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: space :: description :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: space :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: space :: date_modified :: NAME)) ? ; Ok (Data { id , pub_id , name , description , date_created , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "description" , "date_created" , "date_modified" , "objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: space :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < objects :: Data > } ; (@ field_type ; objects) => { Vec < crate :: prisma :: object_in_space :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Space" , available relations are "objects")) } ; (@ field_module ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object_in_space :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: space :: IncludeParam > :: into (crate :: prisma :: space :: objects :: Include :: $ selection_mode (crate :: prisma :: object_in_space :: ManyArgs :: new (crate :: prisma :: object_in_space :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object_in_space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: space :: IncludeParam > :: into (crate :: prisma :: space :: objects :: Include :: Fetch (crate :: prisma :: object_in_space :: ManyArgs :: new (crate :: prisma :: object_in_space :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: space :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; objects) => { "objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_space as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		Description(description::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		Objects(objects::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Description(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Objects(data) => data.to_selection(),
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod description {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "description";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Description(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Description,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Description(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Description(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Description(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Description(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Description(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Description(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Description(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Name,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod objects {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "objects";
		pub fn some(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::ObjectsSome(value)
		}
		pub fn every(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::ObjectsEvery(value)
		}
		pub fn none(value: Vec<object_in_space::WhereParam>) -> WhereParam {
			WhereParam::ObjectsNone(value)
		}
		pub struct Order(Vec<object_in_space::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<object_in_space::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Objects(v)
			}
		}
		pub struct Fetch(pub object_in_space::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object_in_space::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: object_in_space::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: object_in_space::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Objects(v)
			}
		}
		pub fn fetch(params: Vec<object_in_space::WhereParam>) -> Fetch {
			Fetch(object_in_space::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<object_in_space::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObjects(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<object_in_space::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<object_in_space::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectObjects(params)
		}
		pub fn set(params: Vec<object_in_space::UniqueWhereParam>) -> SetParam {
			SetParam::SetObjects(params)
		}
		pub enum Select {
			Select(object_in_space::ManyArgs, Vec<object_in_space::SelectParam>),
			Include(
				object_in_space::ManyArgs,
				Vec<object_in_space::IncludeParam>,
			),
			Fetch(object_in_space::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Objects(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(object_in_space::ManyArgs, Vec<object_in_space::SelectParam>),
			Include(
				object_in_space::ManyArgs,
				Vec<object_in_space::IncludeParam>,
			),
			Fetch(object_in_space::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Objects(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_space::ManyArgs,
				nested_selections: Vec<object_in_space::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.space().create(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create { pub_id, _params }
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.space().create_unchecked(self.pub_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([pub_id::set(self.pub_id)]);
			self._params
		}
	}
	pub fn create_unchecked(pub_id: Vec<u8>, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
		CreateUnchecked { pub_id, _params }
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(description::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Space", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pub_id")]
		pub pub_id: Vec<u8>,
		#[serde(rename = "name")]
		pub name: Option<String>,
		#[serde(rename = "description")]
		pub description: Option<String>,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_modified")]
		pub date_modified:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "objects")]
		#[specta(skip)]
		pub objects: Option<Vec<super::object_in_space::Data>>,
	}
	impl Data {
		pub fn objects(
			&self,
		) -> Result<&Vec<super::object_in_space::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.objects
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(objects),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_space { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: space struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub name : Option < String > , # [serde (rename = "description")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub description : Option < String > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_space as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(self, pub_id: Vec<u8>, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod object_in_space {
	use super::_prisma::*;
	pub const NAME: &str = "ObjectInSpace";
	pub fn space_id_object_id<T: From<UniqueWhereParam>>(space_id: i32, object_id: i32) -> T {
		UniqueWhereParam::SpaceIdObjectIdEquals(space_id, object_id).into()
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		SpaceIdObjectIdEquals(i32, i32),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		SpaceId(super::_prisma::read_filters::IntFilter),
		SpaceIs(Vec<super::space::WhereParam>),
		SpaceIsNot(Vec<super::space::WhereParam>),
		ObjectId(super::_prisma::read_filters::IntFilter),
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::SpaceIdObjectIdEquals(space_id, object_id) => (
					"space_id_object_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							space_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(space_id as i64),
						),
						(
							object_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(object_id as i64),
						),
					]),
				),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::SpaceId(value) => (space_id::NAME, value.into()),
				Self::SpaceIs(where_params) => (
					space::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::SpaceIsNot(where_params) => (
					space::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		SpaceIdObjectIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::SpaceIdObjectIdEquals(space_id, object_id) => {
					Self::SpaceIdObjectIdEquals(space_id, object_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		DateCreated(super::SortOrder),
		SpaceId(super::SortOrder),
		ObjectId(super::SortOrder),
		Space(Vec<super::space::OrderByWithRelationParam>),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::SpaceId(param) => ("space_id", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::Space(param) => (
					"space",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Space(super::space::UniqueArgs),
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Space(args) => {
					let mut selections = < super :: space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(space::NAME, None, [], selections)
				}
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		SpaceId(super::_prisma::write_params::IntParam),
		ConnectSpace(super::space::UniqueWhereParam),
		ObjectId(super::_prisma::write_params::IntParam),
		ConnectObject(super::object::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::SpaceId(value) => (space_id::NAME, value.into()),
				Self::ConnectSpace(where_param) => (
					space::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::space::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		SpaceId(super::_prisma::write_params::IntParam),
		ObjectId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::SpaceId(value) => ("space_id", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_object_in_space { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: object_in_space :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object_in_space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: object_in_space :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: object_in_space :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object_in_space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: object_in_space :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { date_created , space_id , space , object_id , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: object_in_space :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: object_in_space :: $ field :: NAME)] pub $ field : crate :: prisma :: object_in_space :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: object_in_space :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: object_in_space :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: object_in_space :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_space :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_space :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "space_id" , "space" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: object_in_space :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; space_id) => { i32 } ; (@ field_type ; space : $ selection_mode : ident { $ ($ selections : tt) + }) => { space :: Data } ; (@ field_type ; space) => { crate :: prisma :: space :: Data } ; (@ field_type ; object_id) => { i32 } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; object) => { crate :: prisma :: object :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ObjectInSpace" , available relations are "date_created, space_id, space, object_id, object")) } ; (@ field_module ; space : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: space :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: object_in_space :: SelectParam > :: into (crate :: prisma :: object_in_space :: date_created :: Select) } ; (@ selection_field_to_selection_param ; space_id) => { Into :: < crate :: prisma :: object_in_space :: SelectParam > :: into (crate :: prisma :: object_in_space :: space_id :: Select) } ; (@ selection_field_to_selection_param ; space $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object_in_space :: SelectParam > :: into (crate :: prisma :: object_in_space :: space :: Select :: $ selection_mode (crate :: prisma :: space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; space $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object_in_space :: SelectParam > :: into (crate :: prisma :: object_in_space :: space :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < crate :: prisma :: object_in_space :: SelectParam > :: into (crate :: prisma :: object_in_space :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object_in_space :: SelectParam > :: into (crate :: prisma :: object_in_space :: object :: Select :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object_in_space :: SelectParam > :: into (crate :: prisma :: object_in_space :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: object_in_space :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; space_id) => { "space_id" } ; (@ field_serde_name ; space) => { "space" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_object_in_space as select;
	pub enum SelectParam {
		DateCreated(date_created::Select),
		SpaceId(space_id::Select),
		Space(space::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::SpaceId(data) => data.to_selection(),
				Self::Space(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_object_in_space { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: object_in_space :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object_in_space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: object_in_space :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: object_in_space :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object_in_space :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: object_in_space :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { space , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: object_in_space :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: object_in_space :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: object_in_space :: space_id :: NAME)] pub space_id : i32 , # [specta (rename_from_path = crate :: prisma :: object_in_space :: object_id :: NAME)] pub object_id : i32 , $ (# [specta (rename_from_path = crate :: prisma :: object_in_space :: $ field :: NAME)] pub $ field : crate :: prisma :: object_in_space :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (date_created) , stringify ! (space_id) , stringify ! (object_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: object_in_space :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: object_in_space :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: object_in_space :: space_id :: NAME , & self . space_id) ? ; state . serialize_field (crate :: prisma :: object_in_space :: object_id :: NAME , & self . object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , date_created , space_id , object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: object_in_space :: $ field :: NAME) , + , crate :: prisma :: object_in_space :: date_created :: NAME , crate :: prisma :: object_in_space :: space_id :: NAME , crate :: prisma :: object_in_space :: object_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: object_in_space :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: object_in_space :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: object_in_space :: space_id :: NAME => Ok (Field :: space_id) , crate :: prisma :: object_in_space :: object_id :: NAME => Ok (Field :: object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut date_created = None ; let mut space_id = None ; let mut object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_space :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: space_id => { if space_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_space :: space_id :: NAME)) ; } space_id = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_space :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_space :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_space :: $ field :: NAME)) ? ;) * let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_space :: date_created :: NAME)) ? ; let space_id = space_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_space :: space_id :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_space :: object_id :: NAME)) ? ; Ok (Data { date_created , space_id , object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "space_id" , "space" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: object_in_space :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; space : $ selection_mode : ident { $ ($ selections : tt) + }) => { space :: Data } ; (@ field_type ; space) => { crate :: prisma :: space :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; object) => { crate :: prisma :: object :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ObjectInSpace" , available relations are "space, object")) } ; (@ field_module ; space : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: space :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; space $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object_in_space :: IncludeParam > :: into (crate :: prisma :: object_in_space :: space :: Include :: $ selection_mode (crate :: prisma :: space :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; space $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object_in_space :: IncludeParam > :: into (crate :: prisma :: object_in_space :: space :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object_in_space :: IncludeParam > :: into (crate :: prisma :: object_in_space :: object :: Include :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object_in_space :: IncludeParam > :: into (crate :: prisma :: object_in_space :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: object_in_space :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; space_id) => { "space_id" } ; (@ field_serde_name ; space) => { "space" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_object_in_space as include;
	pub enum IncludeParam {
		DateCreated(date_created::Include),
		SpaceId(space_id::Include),
		Space(space::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::SpaceId(data) => data.to_selection(),
				Self::Space(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod space {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "space";
		pub fn is(value: Vec<space::WhereParam>) -> WhereParam {
			WhereParam::SpaceIs(value)
		}
		pub fn is_not(value: Vec<space::WhereParam>) -> WhereParam {
			WhereParam::SpaceIsNot(value)
		}
		pub struct Order(Vec<space::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<space::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Space(v)
			}
		}
		pub struct Fetch(pub space::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<space::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Space(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(space::UniqueArgs::new())
		}
		pub struct Connect(space::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectSpace(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: space::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<space::SelectParam>),
			Include(Vec<space::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Space(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<space::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("space", None, [], selections)
			}
			pub fn select(nested_selections: Vec<space::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<space::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<space::SelectParam>),
			Include(Vec<space::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Space(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<space::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<space::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("space", None, [], selections)
			}
			pub fn select(nested_selections: Vec<space::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<space::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod space_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "space_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::SpaceId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, SpaceId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::SpaceId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::SpaceId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::SpaceId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::SpaceId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::SpaceId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub space: super::space::UniqueWhereParam,
		pub object: super::object::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.object_in_space()
				.create(self.space, self.object, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([space::connect(self.space), object::connect(self.object)]);
			self._params
		}
	}
	pub fn create(
		space: super::space::UniqueWhereParam,
		object: super::object::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			space,
			object,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub space_id: i32,
		pub object_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.object_in_space()
				.create_unchecked(self.space_id, self.object_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([space_id::set(self.space_id), object_id::set(self.object_id)]);
			self._params
		}
	}
	pub fn create_unchecked(
		space_id: i32,
		object_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			space_id,
			object_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(space_id::NAME),
				::prisma_client_rust::sel(object_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "ObjectInSpace", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "space_id")]
		pub space_id: i32,
		#[serde(rename = "space")]
		#[specta(skip)]
		pub space: Option<Box<super::space::Data>>,
		#[serde(rename = "object_id")]
		pub object_id: i32,
		#[serde(rename = "object")]
		#[specta(skip)]
		pub object: Option<Box<super::object::Data>>,
	}
	impl Data {
		pub fn space(
			&self,
		) -> Result<&super::space::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.space
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(space),
				))
				.map(|v| v.as_ref())
		}
		pub fn object(
			&self,
		) -> Result<&super::object::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_object_in_space { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: object_in_space struct $ struct_name { # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "space_id")] pub space_id : i32 , # [serde (rename = "object_id")] pub object_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_object_in_space as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			space: super::space::UniqueWhereParam,
			object: super::object::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([space::connect(space), object::connect(object)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			space_id: i32,
			object_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([space_id::set(space_id), object_id::set(object_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod job {
	use super::_prisma::*;
	pub const NAME: &str = "Job";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringFilter),
		NodeId(super::_prisma::read_filters::IntFilter),
		Action(super::_prisma::read_filters::StringNullableFilter),
		Status(super::_prisma::read_filters::IntFilter),
		ErrorsText(super::_prisma::read_filters::StringNullableFilter),
		Data(super::_prisma::read_filters::BytesNullableFilter),
		Metadata(super::_prisma::read_filters::BytesNullableFilter),
		ParentId(super::_prisma::read_filters::BytesNullableFilter),
		TaskCount(super::_prisma::read_filters::IntFilter),
		CompletedTaskCount(super::_prisma::read_filters::IntFilter),
		DateEstimatedCompletion(super::_prisma::read_filters::DateTimeNullableFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateStarted(super::_prisma::read_filters::DateTimeNullableFilter),
		DateCompleted(super::_prisma::read_filters::DateTimeNullableFilter),
		NodesIs(Vec<super::node::WhereParam>),
		NodesIsNot(Vec<super::node::WhereParam>),
		ParentIsNull,
		ParentIs(Vec<super::job::WhereParam>),
		ParentIsNot(Vec<super::job::WhereParam>),
		ChildrenSome(Vec<super::job::WhereParam>),
		ChildrenEvery(Vec<super::job::WhereParam>),
		ChildrenNone(Vec<super::job::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::Action(value) => (action::NAME, value.into()),
				Self::Status(value) => (status::NAME, value.into()),
				Self::ErrorsText(value) => (errors_text::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::Metadata(value) => (metadata::NAME, value.into()),
				Self::ParentId(value) => (parent_id::NAME, value.into()),
				Self::TaskCount(value) => (task_count::NAME, value.into()),
				Self::CompletedTaskCount(value) => (completed_task_count::NAME, value.into()),
				Self::DateEstimatedCompletion(value) => {
					(date_estimated_completion::NAME, value.into())
				}
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateStarted(value) => (date_started::NAME, value.into()),
				Self::DateCompleted(value) => (date_completed::NAME, value.into()),
				Self::NodesIs(where_params) => (
					nodes::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::NodesIsNot(where_params) => (
					nodes::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ParentIsNull => (
					parent::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::ParentIs(where_params) => (
					parent::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ParentIsNot(where_params) => (
					parent::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ChildrenSome(where_params) => (
					children::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ChildrenEvery(where_params) => (
					children::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ChildrenNone(where_params) => (
					children::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(Vec<u8>),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		Name(super::SortOrder),
		NodeId(super::SortOrder),
		Action(super::SortOrder),
		Status(super::SortOrder),
		ErrorsText(super::SortOrder),
		Data(super::SortOrder),
		Metadata(super::SortOrder),
		ParentId(super::SortOrder),
		TaskCount(super::SortOrder),
		CompletedTaskCount(super::SortOrder),
		DateEstimatedCompletion(super::SortOrder),
		DateCreated(super::SortOrder),
		DateStarted(super::SortOrder),
		DateCompleted(super::SortOrder),
		Nodes(Vec<super::node::OrderByWithRelationParam>),
		Parent(Vec<super::job::OrderByWithRelationParam>),
		Children(Vec<super::job::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::NodeId(param) => ("node_id", param.into()),
				Self::Action(param) => ("action", param.into()),
				Self::Status(param) => ("status", param.into()),
				Self::ErrorsText(param) => ("errors_text", param.into()),
				Self::Data(param) => ("data", param.into()),
				Self::Metadata(param) => ("metadata", param.into()),
				Self::ParentId(param) => ("parent_id", param.into()),
				Self::TaskCount(param) => ("task_count", param.into()),
				Self::CompletedTaskCount(param) => ("completed_task_count", param.into()),
				Self::DateEstimatedCompletion(param) => ("date_estimated_completion", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateStarted(param) => ("date_started", param.into()),
				Self::DateCompleted(param) => ("date_completed", param.into()),
				Self::Nodes(param) => (
					"nodes",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Parent(param) => (
					"parent",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Children(param) => (
					"children",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Nodes(super::node::UniqueArgs),
		Parent(super::job::UniqueArgs),
		Children(super::job::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Nodes(args) => {
					let mut selections =
						<super::node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(nodes::NAME, None, [], selections)
				}
				Self::Parent(args) => {
					let mut selections =
						<super::job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						);
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(parent::NAME, None, [], selections)
				}
				Self::Children(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections.extend(
						<super::job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						),
					);
					::prisma_client_rust::Selection::new(
						children::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringParam),
		NodeId(super::_prisma::write_params::IntParam),
		Action(super::_prisma::write_params::StringNullableParam),
		Status(super::_prisma::write_params::IntParam),
		ErrorsText(super::_prisma::write_params::StringNullableParam),
		Data(super::_prisma::write_params::BytesNullableParam),
		Metadata(super::_prisma::write_params::BytesNullableParam),
		ParentId(super::_prisma::write_params::BytesNullableParam),
		TaskCount(super::_prisma::write_params::IntParam),
		CompletedTaskCount(super::_prisma::write_params::IntParam),
		DateEstimatedCompletion(super::_prisma::write_params::DateTimeNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateStarted(super::_prisma::write_params::DateTimeNullableParam),
		DateCompleted(super::_prisma::write_params::DateTimeNullableParam),
		ConnectNodes(super::node::UniqueWhereParam),
		ConnectParent(super::job::UniqueWhereParam),
		DisconnectParent,
		ConnectChildren(Vec<super::job::UniqueWhereParam>),
		DisconnectChildren(Vec<super::job::UniqueWhereParam>),
		SetChildren(Vec<super::job::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::NodeId(value) => (node_id::NAME, value.into()),
				Self::Action(value) => (action::NAME, value.into()),
				Self::Status(value) => (status::NAME, value.into()),
				Self::ErrorsText(value) => (errors_text::NAME, value.into()),
				Self::Data(value) => (data::NAME, value.into()),
				Self::Metadata(value) => (metadata::NAME, value.into()),
				Self::ParentId(value) => (parent_id::NAME, value.into()),
				Self::TaskCount(value) => (task_count::NAME, value.into()),
				Self::CompletedTaskCount(value) => (completed_task_count::NAME, value.into()),
				Self::DateEstimatedCompletion(value) => {
					(date_estimated_completion::NAME, value.into())
				}
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateStarted(value) => (date_started::NAME, value.into()),
				Self::DateCompleted(value) => (date_completed::NAME, value.into()),
				Self::ConnectNodes(where_param) => (
					nodes::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::node::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ConnectParent(where_param) => (
					parent::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectParent => (
					parent::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
				Self::ConnectChildren(where_params) => (
					children::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectChildren(where_params) => (
					children::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetChildren(where_params) => (
					children::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::job::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringParam),
		NodeId(super::_prisma::write_params::IntParam),
		Action(super::_prisma::write_params::StringNullableParam),
		Status(super::_prisma::write_params::IntParam),
		ErrorsText(super::_prisma::write_params::StringNullableParam),
		Data(super::_prisma::write_params::BytesNullableParam),
		Metadata(super::_prisma::write_params::BytesNullableParam),
		ParentId(super::_prisma::write_params::BytesNullableParam),
		TaskCount(super::_prisma::write_params::IntParam),
		CompletedTaskCount(super::_prisma::write_params::IntParam),
		DateEstimatedCompletion(super::_prisma::write_params::DateTimeNullableParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateStarted(super::_prisma::write_params::DateTimeNullableParam),
		DateCompleted(super::_prisma::write_params::DateTimeNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::NodeId(value) => ("node_id", value.into()),
				Self::Action(value) => ("action", value.into()),
				Self::Status(value) => ("status", value.into()),
				Self::ErrorsText(value) => ("errors_text", value.into()),
				Self::Data(value) => ("data", value.into()),
				Self::Metadata(value) => ("metadata", value.into()),
				Self::ParentId(value) => ("parent_id", value.into()),
				Self::TaskCount(value) => ("task_count", value.into()),
				Self::CompletedTaskCount(value) => ("completed_task_count", value.into()),
				Self::DateEstimatedCompletion(value) => ("date_estimated_completion", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateStarted(value) => ("date_started", value.into()),
				Self::DateCompleted(value) => ("date_completed", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_job { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: job :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: job :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: job :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: job :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , node_id , action , status , errors_text , data , metadata , parent_id , task_count , completed_task_count , date_estimated_completion , date_created , date_started , date_completed , nodes , parent , children } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: job :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: job :: $ field :: NAME)] pub $ field : crate :: prisma :: job :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: job :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: job :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: job :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "node_id" , "action" , "status" , "errors_text" , "data" , "metadata" , "parent_id" , "task_count" , "completed_task_count" , "date_estimated_completion" , "date_created" , "date_started" , "date_completed" , "nodes" , "parent" , "children"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: job :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { Vec < u8 > } ; (@ field_type ; name) => { String } ; (@ field_type ; node_id) => { i32 } ; (@ field_type ; action) => { Option < String > } ; (@ field_type ; status) => { i32 } ; (@ field_type ; errors_text) => { Option < String > } ; (@ field_type ; data) => { Option < Vec < u8 > > } ; (@ field_type ; metadata) => { Option < Vec < u8 > > } ; (@ field_type ; parent_id) => { Option < Vec < u8 > > } ; (@ field_type ; task_count) => { i32 } ; (@ field_type ; completed_task_count) => { i32 } ; (@ field_type ; date_estimated_completion) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_started) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; date_completed) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; nodes : $ selection_mode : ident { $ ($ selections : tt) + }) => { nodes :: Data } ; (@ field_type ; nodes) => { crate :: prisma :: node :: Data } ; (@ field_type ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < parent :: Data > } ; (@ field_type ; parent) => { Option < crate :: prisma :: job :: Data > } ; (@ field_type ; children : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < children :: Data > } ; (@ field_type ; children) => { Vec < crate :: prisma :: job :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Job" , available relations are "id, name, node_id, action, status, errors_text, data, metadata, parent_id, task_count, completed_task_count, date_estimated_completion, date_created, date_started, date_completed, nodes, parent, children")) } ; (@ field_module ; nodes : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: node :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: job :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; children : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: job :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: name :: Select) } ; (@ selection_field_to_selection_param ; node_id) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: node_id :: Select) } ; (@ selection_field_to_selection_param ; action) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: action :: Select) } ; (@ selection_field_to_selection_param ; status) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: status :: Select) } ; (@ selection_field_to_selection_param ; errors_text) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: errors_text :: Select) } ; (@ selection_field_to_selection_param ; data) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: data :: Select) } ; (@ selection_field_to_selection_param ; metadata) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: metadata :: Select) } ; (@ selection_field_to_selection_param ; parent_id) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: parent_id :: Select) } ; (@ selection_field_to_selection_param ; task_count) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: task_count :: Select) } ; (@ selection_field_to_selection_param ; completed_task_count) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: completed_task_count :: Select) } ; (@ selection_field_to_selection_param ; date_estimated_completion) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: date_estimated_completion :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_started) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: date_started :: Select) } ; (@ selection_field_to_selection_param ; date_completed) => { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: date_completed :: Select) } ; (@ selection_field_to_selection_param ; nodes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: nodes :: Select :: $ selection_mode (crate :: prisma :: node :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; nodes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: nodes :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: parent :: Select :: $ selection_mode (crate :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: parent :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; children $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: children :: Select :: $ selection_mode (crate :: prisma :: job :: ManyArgs :: new (crate :: prisma :: job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; children $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: job :: SelectParam > :: into (crate :: prisma :: job :: children :: Select :: Fetch (crate :: prisma :: job :: ManyArgs :: new (crate :: prisma :: job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: job :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; action) => { "action" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; errors_text) => { "errors_text" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; parent_id) => { "parent_id" } ; (@ field_serde_name ; task_count) => { "task_count" } ; (@ field_serde_name ; completed_task_count) => { "completed_task_count" } ; (@ field_serde_name ; date_estimated_completion) => { "date_estimated_completion" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_started) => { "date_started" } ; (@ field_serde_name ; date_completed) => { "date_completed" } ; (@ field_serde_name ; nodes) => { "nodes" } ; (@ field_serde_name ; parent) => { "parent" } ; (@ field_serde_name ; children) => { "children" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_job as select;
	pub enum SelectParam {
		Id(id::Select),
		Name(name::Select),
		NodeId(node_id::Select),
		Action(action::Select),
		Status(status::Select),
		ErrorsText(errors_text::Select),
		Data(data::Select),
		Metadata(metadata::Select),
		ParentId(parent_id::Select),
		TaskCount(task_count::Select),
		CompletedTaskCount(completed_task_count::Select),
		DateEstimatedCompletion(date_estimated_completion::Select),
		DateCreated(date_created::Select),
		DateStarted(date_started::Select),
		DateCompleted(date_completed::Select),
		Nodes(nodes::Select),
		Parent(parent::Select),
		Children(children::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Action(data) => data.to_selection(),
				Self::Status(data) => data.to_selection(),
				Self::ErrorsText(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::Metadata(data) => data.to_selection(),
				Self::ParentId(data) => data.to_selection(),
				Self::TaskCount(data) => data.to_selection(),
				Self::CompletedTaskCount(data) => data.to_selection(),
				Self::DateEstimatedCompletion(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateStarted(data) => data.to_selection(),
				Self::DateCompleted(data) => data.to_selection(),
				Self::Nodes(data) => data.to_selection(),
				Self::Parent(data) => data.to_selection(),
				Self::Children(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_job { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: job :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: job :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: job :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: job :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: job :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { nodes , parent , children } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: job :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: job :: id :: NAME)] pub id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: job :: name :: NAME)] pub name : String , # [specta (rename_from_path = crate :: prisma :: job :: node_id :: NAME)] pub node_id : i32 , # [specta (rename_from_path = crate :: prisma :: job :: action :: NAME)] pub action : Option < String > , # [specta (rename_from_path = crate :: prisma :: job :: status :: NAME)] pub status : i32 , # [specta (rename_from_path = crate :: prisma :: job :: errors_text :: NAME)] pub errors_text : Option < String > , # [specta (rename_from_path = crate :: prisma :: job :: data :: NAME)] pub data : Option < Vec < u8 > > , # [specta (rename_from_path = crate :: prisma :: job :: metadata :: NAME)] pub metadata : Option < Vec < u8 > > , # [specta (rename_from_path = crate :: prisma :: job :: parent_id :: NAME)] pub parent_id : Option < Vec < u8 > > , # [specta (rename_from_path = crate :: prisma :: job :: task_count :: NAME)] pub task_count : i32 , # [specta (rename_from_path = crate :: prisma :: job :: completed_task_count :: NAME)] pub completed_task_count : i32 , # [specta (rename_from_path = crate :: prisma :: job :: date_estimated_completion :: NAME)] pub date_estimated_completion : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = crate :: prisma :: job :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: job :: date_started :: NAME)] pub date_started : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [specta (rename_from_path = crate :: prisma :: job :: date_completed :: NAME)] pub date_completed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (# [specta (rename_from_path = crate :: prisma :: job :: $ field :: NAME)] pub $ field : crate :: prisma :: job :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (node_id) , stringify ! (action) , stringify ! (status) , stringify ! (errors_text) , stringify ! (data) , stringify ! (metadata) , stringify ! (parent_id) , stringify ! (task_count) , stringify ! (completed_task_count) , stringify ! (date_estimated_completion) , stringify ! (date_created) , stringify ! (date_started) , stringify ! (date_completed)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: job :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: job :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: job :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: job :: node_id :: NAME , & self . node_id) ? ; state . serialize_field (crate :: prisma :: job :: action :: NAME , & self . action) ? ; state . serialize_field (crate :: prisma :: job :: status :: NAME , & self . status) ? ; state . serialize_field (crate :: prisma :: job :: errors_text :: NAME , & self . errors_text) ? ; state . serialize_field (crate :: prisma :: job :: data :: NAME , & self . data) ? ; state . serialize_field (crate :: prisma :: job :: metadata :: NAME , & self . metadata) ? ; state . serialize_field (crate :: prisma :: job :: parent_id :: NAME , & self . parent_id) ? ; state . serialize_field (crate :: prisma :: job :: task_count :: NAME , & self . task_count) ? ; state . serialize_field (crate :: prisma :: job :: completed_task_count :: NAME , & self . completed_task_count) ? ; state . serialize_field (crate :: prisma :: job :: date_estimated_completion :: NAME , & self . date_estimated_completion) ? ; state . serialize_field (crate :: prisma :: job :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: job :: date_started :: NAME , & self . date_started) ? ; state . serialize_field (crate :: prisma :: job :: date_completed :: NAME , & self . date_completed) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , node_id , action , status , errors_text , data , metadata , parent_id , task_count , completed_task_count , date_estimated_completion , date_created , date_started , date_completed } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: job :: $ field :: NAME) , + , crate :: prisma :: job :: id :: NAME , crate :: prisma :: job :: name :: NAME , crate :: prisma :: job :: node_id :: NAME , crate :: prisma :: job :: action :: NAME , crate :: prisma :: job :: status :: NAME , crate :: prisma :: job :: errors_text :: NAME , crate :: prisma :: job :: data :: NAME , crate :: prisma :: job :: metadata :: NAME , crate :: prisma :: job :: parent_id :: NAME , crate :: prisma :: job :: task_count :: NAME , crate :: prisma :: job :: completed_task_count :: NAME , crate :: prisma :: job :: date_estimated_completion :: NAME , crate :: prisma :: job :: date_created :: NAME , crate :: prisma :: job :: date_started :: NAME , crate :: prisma :: job :: date_completed :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: job :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: job :: id :: NAME => Ok (Field :: id) , crate :: prisma :: job :: name :: NAME => Ok (Field :: name) , crate :: prisma :: job :: node_id :: NAME => Ok (Field :: node_id) , crate :: prisma :: job :: action :: NAME => Ok (Field :: action) , crate :: prisma :: job :: status :: NAME => Ok (Field :: status) , crate :: prisma :: job :: errors_text :: NAME => Ok (Field :: errors_text) , crate :: prisma :: job :: data :: NAME => Ok (Field :: data) , crate :: prisma :: job :: metadata :: NAME => Ok (Field :: metadata) , crate :: prisma :: job :: parent_id :: NAME => Ok (Field :: parent_id) , crate :: prisma :: job :: task_count :: NAME => Ok (Field :: task_count) , crate :: prisma :: job :: completed_task_count :: NAME => Ok (Field :: completed_task_count) , crate :: prisma :: job :: date_estimated_completion :: NAME => Ok (Field :: date_estimated_completion) , crate :: prisma :: job :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: job :: date_started :: NAME => Ok (Field :: date_started) , crate :: prisma :: job :: date_completed :: NAME => Ok (Field :: date_completed) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut node_id = None ; let mut action = None ; let mut status = None ; let mut errors_text = None ; let mut data = None ; let mut metadata = None ; let mut parent_id = None ; let mut task_count = None ; let mut completed_task_count = None ; let mut date_estimated_completion = None ; let mut date_created = None ; let mut date_started = None ; let mut date_completed = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: node_id => { if node_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: node_id :: NAME)) ; } node_id = Some (map . next_value () ?) ; } Field :: action => { if action . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: action :: NAME)) ; } action = Some (map . next_value () ?) ; } Field :: status => { if status . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: status :: NAME)) ; } status = Some (map . next_value () ?) ; } Field :: errors_text => { if errors_text . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: errors_text :: NAME)) ; } errors_text = Some (map . next_value () ?) ; } Field :: data => { if data . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: data :: NAME)) ; } data = Some (map . next_value () ?) ; } Field :: metadata => { if metadata . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: metadata :: NAME)) ; } metadata = Some (map . next_value () ?) ; } Field :: parent_id => { if parent_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: parent_id :: NAME)) ; } parent_id = Some (map . next_value () ?) ; } Field :: task_count => { if task_count . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: task_count :: NAME)) ; } task_count = Some (map . next_value () ?) ; } Field :: completed_task_count => { if completed_task_count . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: completed_task_count :: NAME)) ; } completed_task_count = Some (map . next_value () ?) ; } Field :: date_estimated_completion => { if date_estimated_completion . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: date_estimated_completion :: NAME)) ; } date_estimated_completion = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_started => { if date_started . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: date_started :: NAME)) ; } date_started = Some (map . next_value () ?) ; } Field :: date_completed => { if date_completed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: date_completed :: NAME)) ; } date_completed = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: job :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: name :: NAME)) ? ; let node_id = node_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: node_id :: NAME)) ? ; let action = action . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: action :: NAME)) ? ; let status = status . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: status :: NAME)) ? ; let errors_text = errors_text . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: errors_text :: NAME)) ? ; let data = data . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: data :: NAME)) ? ; let metadata = metadata . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: metadata :: NAME)) ? ; let parent_id = parent_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: parent_id :: NAME)) ? ; let task_count = task_count . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: task_count :: NAME)) ? ; let completed_task_count = completed_task_count . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: completed_task_count :: NAME)) ? ; let date_estimated_completion = date_estimated_completion . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: date_estimated_completion :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: date_created :: NAME)) ? ; let date_started = date_started . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: date_started :: NAME)) ? ; let date_completed = date_completed . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: job :: date_completed :: NAME)) ? ; Ok (Data { id , name , node_id , action , status , errors_text , data , metadata , parent_id , task_count , completed_task_count , date_estimated_completion , date_created , date_started , date_completed , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "node_id" , "action" , "status" , "errors_text" , "data" , "metadata" , "parent_id" , "task_count" , "completed_task_count" , "date_estimated_completion" , "date_created" , "date_started" , "date_completed" , "nodes" , "parent" , "children"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: job :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; nodes : $ selection_mode : ident { $ ($ selections : tt) + }) => { nodes :: Data } ; (@ field_type ; nodes) => { crate :: prisma :: node :: Data } ; (@ field_type ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < parent :: Data > } ; (@ field_type ; parent) => { Option < crate :: prisma :: job :: Data > } ; (@ field_type ; children : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < children :: Data > } ; (@ field_type ; children) => { Vec < crate :: prisma :: job :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Job" , available relations are "nodes, parent, children")) } ; (@ field_module ; nodes : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: node :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; parent : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: job :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; children : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: job :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; nodes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: job :: IncludeParam > :: into (crate :: prisma :: job :: nodes :: Include :: $ selection_mode (crate :: prisma :: node :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; nodes $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: job :: IncludeParam > :: into (crate :: prisma :: job :: nodes :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: job :: IncludeParam > :: into (crate :: prisma :: job :: parent :: Include :: $ selection_mode (crate :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; parent $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: job :: IncludeParam > :: into (crate :: prisma :: job :: parent :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; children $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: job :: IncludeParam > :: into (crate :: prisma :: job :: children :: Include :: $ selection_mode (crate :: prisma :: job :: ManyArgs :: new (crate :: prisma :: job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: job :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; children $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: job :: IncludeParam > :: into (crate :: prisma :: job :: children :: Include :: Fetch (crate :: prisma :: job :: ManyArgs :: new (crate :: prisma :: job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: job :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; node_id) => { "node_id" } ; (@ field_serde_name ; action) => { "action" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; errors_text) => { "errors_text" } ; (@ field_serde_name ; data) => { "data" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; parent_id) => { "parent_id" } ; (@ field_serde_name ; task_count) => { "task_count" } ; (@ field_serde_name ; completed_task_count) => { "completed_task_count" } ; (@ field_serde_name ; date_estimated_completion) => { "date_estimated_completion" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_started) => { "date_started" } ; (@ field_serde_name ; date_completed) => { "date_completed" } ; (@ field_serde_name ; nodes) => { "nodes" } ; (@ field_serde_name ; parent) => { "parent" } ; (@ field_serde_name ; children) => { "children" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_job as include;
	pub enum IncludeParam {
		Id(id::Include),
		Name(name::Include),
		NodeId(node_id::Include),
		Action(action::Include),
		Status(status::Include),
		ErrorsText(errors_text::Include),
		Data(data::Include),
		Metadata(metadata::Include),
		ParentId(parent_id::Include),
		TaskCount(task_count::Include),
		CompletedTaskCount(completed_task_count::Include),
		DateEstimatedCompletion(date_estimated_completion::Include),
		DateCreated(date_created::Include),
		DateStarted(date_started::Include),
		DateCompleted(date_completed::Include),
		Nodes(nodes::Include),
		Parent(parent::Include),
		Children(children::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::NodeId(data) => data.to_selection(),
				Self::Action(data) => data.to_selection(),
				Self::Status(data) => data.to_selection(),
				Self::ErrorsText(data) => data.to_selection(),
				Self::Data(data) => data.to_selection(),
				Self::Metadata(data) => data.to_selection(),
				Self::ParentId(data) => data.to_selection(),
				Self::TaskCount(data) => data.to_selection(),
				Self::CompletedTaskCount(data) => data.to_selection(),
				Self::DateEstimatedCompletion(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateStarted(data) => data.to_selection(),
				Self::DateCompleted(data) => data.to_selection(),
				Self::Nodes(data) => data.to_selection(),
				Self::Parent(data) => data.to_selection(),
				Self::Children(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod action {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "action";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::Action(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			Action,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Action(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Action(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Action(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Action(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Action(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Action(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Action(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod children {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "children";
		pub fn some(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ChildrenSome(value)
		}
		pub fn every(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ChildrenEvery(value)
		}
		pub fn none(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ChildrenNone(value)
		}
		pub struct Order(Vec<job::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<job::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Children(v)
			}
		}
		pub struct Fetch(pub job::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<job::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: job::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: job::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Children(v)
			}
		}
		pub fn fetch(params: Vec<job::WhereParam>) -> Fetch {
			Fetch(job::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<job::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectChildren(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<job::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<job::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectChildren(params)
		}
		pub fn set(params: Vec<job::UniqueWhereParam>) -> SetParam {
			SetParam::SetChildren(params)
		}
		pub enum Select {
			Select(job::ManyArgs, Vec<job::SelectParam>),
			Include(job::ManyArgs, Vec<job::IncludeParam>),
			Fetch(job::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Children(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(args: job::ManyArgs, nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(args: job::ManyArgs, nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(job::ManyArgs, Vec<job::SelectParam>),
			Include(job::ManyArgs, Vec<job::IncludeParam>),
			Fetch(job::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Children(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args, selections) = match self {
					Self::Select(args, selections) => (
						args.to_graphql().0,
						selections.into_iter().map(|s| s.to_selection()).collect(),
					),
					Self::Include(args, selections) => (args.to_graphql().0, {
						let mut nested_selections =
							<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}),
					Self::Fetch(args) => (
						args.to_graphql().0,
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
					),
				};
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(args: job::ManyArgs, nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(args: job::ManyArgs, nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod completed_task_count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "completed_task_count";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::CompletedTaskCount(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			CompletedTaskCount,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::CompletedTaskCount(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CompletedTaskCount(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::CompletedTaskCount(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::CompletedTaskCount(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::CompletedTaskCount(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::CompletedTaskCount(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::CompletedTaskCount(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod data {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "data";
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::Data(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			Data,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Data(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Data(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Data(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Data(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Data(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_completed {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_completed";
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateCompleted(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateCompleted,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCompleted(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCompleted(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCompleted(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCompleted(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCompleted(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCompleted(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCompleted(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_estimated_completion {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_estimated_completion";
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateEstimatedCompletion(
				_prisma::read_filters::DateTimeNullableFilter::Equals(value),
			)
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateEstimatedCompletion,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateEstimatedCompletion(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateEstimatedCompletion(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateEstimatedCompletion(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateEstimatedCompletion(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateEstimatedCompletion(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateEstimatedCompletion(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateEstimatedCompletion(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_started {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_started";
		pub fn equals(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> WhereParam {
			WhereParam::DateStarted(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeNullableFilter,
			DateStarted,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: Option<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateStarted(v)
			}
		}
		pub struct Set(
			pub  Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateStarted(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateStarted(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: Option<
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateStarted(_prisma::write_params::DateTimeNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateStarted(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateStarted(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateStarted(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod errors_text {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "errors_text";
		pub fn equals(value: Option<String>) -> WhereParam {
			WhereParam::ErrorsText(_prisma::read_filters::StringNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringNullableFilter,
			ErrorsText,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: Option<String>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ErrorsText(v)
			}
		}
		pub struct Set(pub Option<String>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ErrorsText(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::ErrorsText(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<String>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ErrorsText(_prisma::write_params::StringNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ErrorsText(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ErrorsText(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ErrorsText(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, Id, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod metadata {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "metadata";
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::Metadata(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			Metadata,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Metadata(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Metadata(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Metadata(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Metadata(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Metadata(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Metadata(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Metadata(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod node_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "node_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::NodeId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, NodeId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::NodeId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::NodeId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::NodeId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::NodeId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod nodes {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "nodes";
		pub fn is(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodesIs(value)
		}
		pub fn is_not(value: Vec<node::WhereParam>) -> WhereParam {
			WhereParam::NodesIsNot(value)
		}
		pub struct Order(Vec<node::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<node::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Nodes(v)
			}
		}
		pub struct Fetch(pub node::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<node::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Nodes(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(node::UniqueArgs::new())
		}
		pub struct Connect(node::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectNodes(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: node::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<node::SelectParam>),
			Include(Vec<node::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Nodes(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("nodes", None, [], selections)
			}
			pub fn select(nested_selections: Vec<node::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<node::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<node::SelectParam>),
			Include(Vec<node::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Nodes(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<node::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("nodes", None, [], selections)
			}
			pub fn select(nested_selections: Vec<node::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<node::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod parent {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "parent";
		pub fn is(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ParentIs(value)
		}
		pub fn is_not(value: Vec<job::WhereParam>) -> WhereParam {
			WhereParam::ParentIsNot(value)
		}
		pub struct Order(Vec<job::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<job::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Parent(v)
			}
		}
		pub struct Fetch(pub job::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<job::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Parent(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(job::UniqueArgs::new())
		}
		pub struct Connect(job::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectParent(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: job::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectParent
		}
		pub fn is_null() -> WhereParam {
			WhereParam::ParentIsNull
		}
		pub enum Select {
			Select(Vec<job::SelectParam>),
			Include(Vec<job::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Parent(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("parent", None, [], selections)
			}
			pub fn select(nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<job::SelectParam>),
			Include(Vec<job::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Parent(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<job::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("parent", None, [], selections)
			}
			pub fn select(nested_selections: Vec<job::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<job::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod parent_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "parent_id";
		pub fn equals(value: Option<Vec<u8>>) -> WhereParam {
			WhereParam::ParentId(_prisma::read_filters::BytesNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesNullableFilter,
			ParentId,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Option<Vec<u8>>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ParentId(v)
			}
		}
		pub struct Set(pub Option<Vec<u8>>);
		pub fn set<T: From<Set>>(value: Option<Vec<u8>>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesNullableParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ParentId(_prisma::write_params::BytesNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ParentId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ParentId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ParentId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod status {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "status";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::Status(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Status, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Status(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Status(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Status(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Status(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Status(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Status(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Status(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod task_count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "task_count";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::TaskCount(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			TaskCount,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::TaskCount(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TaskCount(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::TaskCount(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::TaskCount(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::TaskCount(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::TaskCount(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::TaskCount(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub id: Vec<u8>,
		pub name: String,
		pub nodes: super::node::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.job()
				.create(self.id, self.name, self.nodes, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				id::set(self.id),
				name::set(self.name),
				nodes::connect(self.nodes),
			]);
			self._params
		}
	}
	pub fn create(
		id: Vec<u8>,
		name: String,
		nodes: super::node::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			id,
			name,
			nodes,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub id: Vec<u8>,
		pub name: String,
		pub node_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.job()
				.create_unchecked(self.id, self.name, self.node_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				id::set(self.id),
				name::set(self.name),
				node_id::set(self.node_id),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		id: Vec<u8>,
		name: String,
		node_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			id,
			name,
			node_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(node_id::NAME),
				::prisma_client_rust::sel(action::NAME),
				::prisma_client_rust::sel(status::NAME),
				::prisma_client_rust::sel(errors_text::NAME),
				::prisma_client_rust::sel(data::NAME),
				::prisma_client_rust::sel(metadata::NAME),
				::prisma_client_rust::sel(parent_id::NAME),
				::prisma_client_rust::sel(task_count::NAME),
				::prisma_client_rust::sel(completed_task_count::NAME),
				::prisma_client_rust::sel(date_estimated_completion::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_started::NAME),
				::prisma_client_rust::sel(date_completed::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Job", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: Vec<u8>,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "node_id")]
		pub node_id: i32,
		#[serde(rename = "action")]
		pub action: Option<String>,
		#[serde(rename = "status")]
		pub status: i32,
		#[serde(rename = "errors_text")]
		pub errors_text: Option<String>,
		#[serde(rename = "data")]
		pub data: Option<Vec<u8>>,
		#[serde(rename = "metadata")]
		pub metadata: Option<Vec<u8>>,
		#[serde(rename = "parent_id")]
		pub parent_id: Option<Vec<u8>>,
		#[serde(rename = "task_count")]
		pub task_count: i32,
		#[serde(rename = "completed_task_count")]
		pub completed_task_count: i32,
		#[serde(rename = "date_estimated_completion")]
		pub date_estimated_completion: Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_started")]
		pub date_started: Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>,
		#[serde(rename = "date_completed")]
		pub date_completed: Option<
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		>,
		#[serde(rename = "nodes")]
		#[specta(skip)]
		pub nodes: Option<Box<super::node::Data>>,
		#[serde(
			rename = "parent",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub parent: Option<Option<Box<super::job::Data>>>,
		#[serde(rename = "children")]
		#[specta(skip)]
		pub children: Option<Vec<super::job::Data>>,
	}
	impl Data {
		pub fn nodes(
			&self,
		) -> Result<&super::node::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.nodes
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(nodes),
				))
				.map(|v| v.as_ref())
		}
		pub fn parent(
			&self,
		) -> Result<Option<&super::job::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.parent
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(parent),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
		pub fn children(
			&self,
		) -> Result<&Vec<super::job::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.children
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(children),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_job { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: job struct $ struct_name { # [serde (rename = "id")] pub id : Vec < u8 > , # [serde (rename = "name")] pub name : String , # [serde (rename = "node_id")] pub node_id : i32 , # [serde (rename = "action")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub action : Option < String > , # [serde (rename = "status")] pub status : i32 , # [serde (rename = "errors_text")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub errors_text : Option < String > , # [serde (rename = "data")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub data : Option < Vec < u8 > > , # [serde (rename = "metadata")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub metadata : Option < Vec < u8 > > , # [serde (rename = "parent_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub parent_id : Option < Vec < u8 > > , # [serde (rename = "task_count")] pub task_count : i32 , # [serde (rename = "completed_task_count")] pub completed_task_count : i32 , # [serde (rename = "date_estimated_completion")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_estimated_completion : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_started")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_started : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "date_completed")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub date_completed : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_job as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			id: Vec<u8>,
			name: String,
			nodes: super::node::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([id::set(id), name::set(name), nodes::connect(nodes)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			id: Vec<u8>,
			name: String,
			node_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([id::set(id), name::set(name), node_id::set(node_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod album {
	use super::_prisma::*;
	pub const NAME: &str = "Album";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Name(super::_prisma::read_filters::StringFilter),
		IsHidden(super::_prisma::read_filters::BooleanFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
		ObjectsSome(Vec<super::object_in_album::WhereParam>),
		ObjectsEvery(Vec<super::object_in_album::WhereParam>),
		ObjectsNone(Vec<super::object_in_album::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::IsHidden(value) => (is_hidden::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ObjectsSome(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectsEvery(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectsNone(where_params) => (
					objects::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Name(super::SortOrder),
		IsHidden(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		Objects(Vec<super::object_in_album::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::IsHidden(param) => ("is_hidden", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::Objects(param) => (
					"objects",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Objects(super::object_in_album::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Objects(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						objects::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringParam),
		IsHidden(super::_prisma::write_params::BooleanParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		ConnectObjects(Vec<super::object_in_album::UniqueWhereParam>),
		DisconnectObjects(Vec<super::object_in_album::UniqueWhereParam>),
		SetObjects(Vec<super::object_in_album::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::IsHidden(value) => (is_hidden::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ConnectObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_album::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_album::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetObjects(where_params) => (
					objects::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::object_in_album::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Name(super::_prisma::write_params::StringParam),
		IsHidden(super::_prisma::write_params::BooleanParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::IsHidden(value) => ("is_hidden", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_album { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: album :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: album :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: album :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: album :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: album :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: album :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , name , is_hidden , date_created , date_modified , objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: album :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: album :: $ field :: NAME)] pub $ field : crate :: prisma :: album :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: album :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: album :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: album :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: album :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: album :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "is_hidden" , "date_created" , "date_modified" , "objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: album :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pub_id) => { Vec < u8 > } ; (@ field_type ; name) => { String } ; (@ field_type ; is_hidden) => { bool } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_modified) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < objects :: Data > } ; (@ field_type ; objects) => { Vec < crate :: prisma :: object_in_album :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Album" , available relations are "id, pub_id, name, is_hidden, date_created, date_modified, objects")) } ; (@ field_module ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object_in_album :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: album :: SelectParam > :: into (crate :: prisma :: album :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < crate :: prisma :: album :: SelectParam > :: into (crate :: prisma :: album :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: album :: SelectParam > :: into (crate :: prisma :: album :: name :: Select) } ; (@ selection_field_to_selection_param ; is_hidden) => { Into :: < crate :: prisma :: album :: SelectParam > :: into (crate :: prisma :: album :: is_hidden :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: album :: SelectParam > :: into (crate :: prisma :: album :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < crate :: prisma :: album :: SelectParam > :: into (crate :: prisma :: album :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: album :: SelectParam > :: into (crate :: prisma :: album :: objects :: Select :: $ selection_mode (crate :: prisma :: object_in_album :: ManyArgs :: new (crate :: prisma :: object_in_album :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object_in_album :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: album :: SelectParam > :: into (crate :: prisma :: album :: objects :: Select :: Fetch (crate :: prisma :: object_in_album :: ManyArgs :: new (crate :: prisma :: object_in_album :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: album :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; is_hidden) => { "is_hidden" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; objects) => { "objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_album as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Name(name::Select),
		IsHidden(is_hidden::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		Objects(objects::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::IsHidden(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Objects(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_album { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: album :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: album :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: album :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: album :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: album :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: album :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { objects } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: album :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: album :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: album :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: album :: name :: NAME)] pub name : String , # [specta (rename_from_path = crate :: prisma :: album :: is_hidden :: NAME)] pub is_hidden : bool , # [specta (rename_from_path = crate :: prisma :: album :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: album :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: prisma :: album :: $ field :: NAME)] pub $ field : crate :: prisma :: album :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (name) , stringify ! (is_hidden) , stringify ! (date_created) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: album :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: album :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: album :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (crate :: prisma :: album :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: album :: is_hidden :: NAME , & self . is_hidden) ? ; state . serialize_field (crate :: prisma :: album :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: album :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , name , is_hidden , date_created , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: album :: $ field :: NAME) , + , crate :: prisma :: album :: id :: NAME , crate :: prisma :: album :: pub_id :: NAME , crate :: prisma :: album :: name :: NAME , crate :: prisma :: album :: is_hidden :: NAME , crate :: prisma :: album :: date_created :: NAME , crate :: prisma :: album :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: album :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: album :: id :: NAME => Ok (Field :: id) , crate :: prisma :: album :: pub_id :: NAME => Ok (Field :: pub_id) , crate :: prisma :: album :: name :: NAME => Ok (Field :: name) , crate :: prisma :: album :: is_hidden :: NAME => Ok (Field :: is_hidden) , crate :: prisma :: album :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: album :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut name = None ; let mut is_hidden = None ; let mut date_created = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: album :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: album :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: album :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: is_hidden => { if is_hidden . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: album :: is_hidden :: NAME)) ; } is_hidden = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: album :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: album :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: album :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: album :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: album :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: album :: pub_id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: album :: name :: NAME)) ? ; let is_hidden = is_hidden . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: album :: is_hidden :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: album :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: album :: date_modified :: NAME)) ? ; Ok (Data { id , pub_id , name , is_hidden , date_created , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "name" , "is_hidden" , "date_created" , "date_modified" , "objects"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: album :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < objects :: Data > } ; (@ field_type ; objects) => { Vec < crate :: prisma :: object_in_album :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Album" , available relations are "objects")) } ; (@ field_module ; objects : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object_in_album :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: album :: IncludeParam > :: into (crate :: prisma :: album :: objects :: Include :: $ selection_mode (crate :: prisma :: object_in_album :: ManyArgs :: new (crate :: prisma :: object_in_album :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: object_in_album :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; objects $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: album :: IncludeParam > :: into (crate :: prisma :: album :: objects :: Include :: Fetch (crate :: prisma :: object_in_album :: ManyArgs :: new (crate :: prisma :: object_in_album :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: album :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; is_hidden) => { "is_hidden" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; objects) => { "objects" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_album as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Name(name::Include),
		IsHidden(is_hidden::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		Objects(objects::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::IsHidden(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Objects(data) => data.to_selection(),
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod is_hidden {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "is_hidden";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::IsHidden(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			IsHidden,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IsHidden(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsHidden(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsHidden(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IsHidden(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IsHidden(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IsHidden(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IsHidden(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod objects {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "objects";
		pub fn some(value: Vec<object_in_album::WhereParam>) -> WhereParam {
			WhereParam::ObjectsSome(value)
		}
		pub fn every(value: Vec<object_in_album::WhereParam>) -> WhereParam {
			WhereParam::ObjectsEvery(value)
		}
		pub fn none(value: Vec<object_in_album::WhereParam>) -> WhereParam {
			WhereParam::ObjectsNone(value)
		}
		pub struct Order(Vec<object_in_album::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(v: Vec<object_in_album::OrderByRelationAggregateParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Objects(v)
			}
		}
		pub struct Fetch(pub object_in_album::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object_in_album::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(mut self, param: object_in_album::OrderByWithRelationParam) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: object_in_album::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Objects(v)
			}
		}
		pub fn fetch(params: Vec<object_in_album::WhereParam>) -> Fetch {
			Fetch(object_in_album::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<object_in_album::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObjects(v)
			}
		}
		pub fn connect<T: From<Connect>>(params: Vec<object_in_album::UniqueWhereParam>) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<object_in_album::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectObjects(params)
		}
		pub fn set(params: Vec<object_in_album::UniqueWhereParam>) -> SetParam {
			SetParam::SetObjects(params)
		}
		pub enum Select {
			Select(object_in_album::ManyArgs, Vec<object_in_album::SelectParam>),
			Include(
				object_in_album::ManyArgs,
				Vec<object_in_album::IncludeParam>,
			),
			Fetch(object_in_album::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Objects(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_album::ManyArgs,
				nested_selections: Vec<object_in_album::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_album::ManyArgs,
				nested_selections: Vec<object_in_album::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(object_in_album::ManyArgs, Vec<object_in_album::SelectParam>),
			Include(
				object_in_album::ManyArgs,
				Vec<object_in_album::IncludeParam>,
			),
			Fetch(object_in_album::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Objects(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: object_in_album::ManyArgs,
				nested_selections: Vec<object_in_album::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: object_in_album::ManyArgs,
				nested_selections: Vec<object_in_album::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub name: String,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.album().create(self.pub_id, self.name, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([pub_id::set(self.pub_id), name::set(self.name)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, name: String, _params: Vec<SetParam>) -> Create {
		Create {
			pub_id,
			name,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub name: String,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.album()
				.create_unchecked(self.pub_id, self.name, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([pub_id::set(self.pub_id), name::set(self.name)]);
			self._params
		}
	}
	pub fn create_unchecked(
		pub_id: Vec<u8>,
		name: String,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			pub_id,
			name,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(is_hidden::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Album", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pub_id")]
		pub pub_id: Vec<u8>,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "is_hidden")]
		pub is_hidden: bool,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_modified")]
		pub date_modified:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "objects")]
		#[specta(skip)]
		pub objects: Option<Vec<super::object_in_album::Data>>,
	}
	impl Data {
		pub fn objects(
			&self,
		) -> Result<&Vec<super::object_in_album::Data>, ::prisma_client_rust::RelationNotFetchedError>
		{
			self.objects
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(objects),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_album { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: album struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "name")] pub name : String , # [serde (rename = "is_hidden")] pub is_hidden : bool , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_album as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			pub_id: Vec<u8>,
			name: String,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id), name::set(name)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			name: String,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id), name::set(name)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod object_in_album {
	use super::_prisma::*;
	pub const NAME: &str = "ObjectInAlbum";
	pub fn album_id_object_id<T: From<UniqueWhereParam>>(album_id: i32, object_id: i32) -> T {
		UniqueWhereParam::AlbumIdObjectIdEquals(album_id, object_id).into()
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		AlbumIdObjectIdEquals(i32, i32),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		AlbumId(super::_prisma::read_filters::IntFilter),
		AlbumIs(Vec<super::album::WhereParam>),
		AlbumIsNot(Vec<super::album::WhereParam>),
		ObjectId(super::_prisma::read_filters::IntFilter),
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::AlbumIdObjectIdEquals(album_id, object_id) => (
					"album_id_object_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							album_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(album_id as i64),
						),
						(
							object_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(object_id as i64),
						),
					]),
				),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::AlbumId(value) => (album_id::NAME, value.into()),
				Self::AlbumIs(where_params) => (
					album::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::AlbumIsNot(where_params) => (
					album::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		AlbumIdObjectIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::AlbumIdObjectIdEquals(album_id, object_id) => {
					Self::AlbumIdObjectIdEquals(album_id, object_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		DateCreated(super::SortOrder),
		AlbumId(super::SortOrder),
		ObjectId(super::SortOrder),
		Album(Vec<super::album::OrderByWithRelationParam>),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::AlbumId(param) => ("album_id", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::Album(param) => (
					"album",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Album(super::album::UniqueArgs),
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Album(args) => {
					let mut selections = < super :: album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(album::NAME, None, [], selections)
				}
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		AlbumId(super::_prisma::write_params::IntParam),
		ConnectAlbum(super::album::UniqueWhereParam),
		ObjectId(super::_prisma::write_params::IntParam),
		ConnectObject(super::object::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::AlbumId(value) => (album_id::NAME, value.into()),
				Self::ConnectAlbum(where_param) => (
					album::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::album::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		AlbumId(super::_prisma::write_params::IntParam),
		ObjectId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::AlbumId(value) => ("album_id", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_object_in_album { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: object_in_album :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object_in_album :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: object_in_album :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: object_in_album :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object_in_album :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: object_in_album :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { date_created , album_id , album , object_id , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: object_in_album :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: object_in_album :: $ field :: NAME)] pub $ field : crate :: prisma :: object_in_album :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: object_in_album :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: object_in_album :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: object_in_album :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_album :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_album :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "album_id" , "album" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: object_in_album :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; album_id) => { i32 } ; (@ field_type ; album : $ selection_mode : ident { $ ($ selections : tt) + }) => { album :: Data } ; (@ field_type ; album) => { crate :: prisma :: album :: Data } ; (@ field_type ; object_id) => { i32 } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; object) => { crate :: prisma :: object :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ObjectInAlbum" , available relations are "date_created, album_id, album, object_id, object")) } ; (@ field_module ; album : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: album :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: object_in_album :: SelectParam > :: into (crate :: prisma :: object_in_album :: date_created :: Select) } ; (@ selection_field_to_selection_param ; album_id) => { Into :: < crate :: prisma :: object_in_album :: SelectParam > :: into (crate :: prisma :: object_in_album :: album_id :: Select) } ; (@ selection_field_to_selection_param ; album $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object_in_album :: SelectParam > :: into (crate :: prisma :: object_in_album :: album :: Select :: $ selection_mode (crate :: prisma :: album :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; album $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object_in_album :: SelectParam > :: into (crate :: prisma :: object_in_album :: album :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < crate :: prisma :: object_in_album :: SelectParam > :: into (crate :: prisma :: object_in_album :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object_in_album :: SelectParam > :: into (crate :: prisma :: object_in_album :: object :: Select :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object_in_album :: SelectParam > :: into (crate :: prisma :: object_in_album :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: object_in_album :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; album_id) => { "album_id" } ; (@ field_serde_name ; album) => { "album" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_object_in_album as select;
	pub enum SelectParam {
		DateCreated(date_created::Select),
		AlbumId(album_id::Select),
		Album(album::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::AlbumId(data) => data.to_selection(),
				Self::Album(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_object_in_album { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: object_in_album :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object_in_album :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: object_in_album :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: object_in_album :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: object_in_album :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: object_in_album :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { album , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: object_in_album :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: object_in_album :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: object_in_album :: album_id :: NAME)] pub album_id : i32 , # [specta (rename_from_path = crate :: prisma :: object_in_album :: object_id :: NAME)] pub object_id : i32 , $ (# [specta (rename_from_path = crate :: prisma :: object_in_album :: $ field :: NAME)] pub $ field : crate :: prisma :: object_in_album :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (date_created) , stringify ! (album_id) , stringify ! (object_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: object_in_album :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: object_in_album :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: object_in_album :: album_id :: NAME , & self . album_id) ? ; state . serialize_field (crate :: prisma :: object_in_album :: object_id :: NAME , & self . object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , date_created , album_id , object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: object_in_album :: $ field :: NAME) , + , crate :: prisma :: object_in_album :: date_created :: NAME , crate :: prisma :: object_in_album :: album_id :: NAME , crate :: prisma :: object_in_album :: object_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: object_in_album :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: object_in_album :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: object_in_album :: album_id :: NAME => Ok (Field :: album_id) , crate :: prisma :: object_in_album :: object_id :: NAME => Ok (Field :: object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut date_created = None ; let mut album_id = None ; let mut object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_album :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: album_id => { if album_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_album :: album_id :: NAME)) ; } album_id = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_album :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: object_in_album :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_album :: $ field :: NAME)) ? ;) * let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_album :: date_created :: NAME)) ? ; let album_id = album_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_album :: album_id :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: object_in_album :: object_id :: NAME)) ? ; Ok (Data { date_created , album_id , object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "album_id" , "album" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: object_in_album :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; album : $ selection_mode : ident { $ ($ selections : tt) + }) => { album :: Data } ; (@ field_type ; album) => { crate :: prisma :: album :: Data } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { object :: Data } ; (@ field_type ; object) => { crate :: prisma :: object :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ObjectInAlbum" , available relations are "album, object")) } ; (@ field_module ; album : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: album :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; album $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object_in_album :: IncludeParam > :: into (crate :: prisma :: object_in_album :: album :: Include :: $ selection_mode (crate :: prisma :: album :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; album $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object_in_album :: IncludeParam > :: into (crate :: prisma :: object_in_album :: album :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: object_in_album :: IncludeParam > :: into (crate :: prisma :: object_in_album :: object :: Include :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: object_in_album :: IncludeParam > :: into (crate :: prisma :: object_in_album :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: object_in_album :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; album_id) => { "album_id" } ; (@ field_serde_name ; album) => { "album" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_object_in_album as include;
	pub enum IncludeParam {
		DateCreated(date_created::Include),
		AlbumId(album_id::Include),
		Album(album::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::AlbumId(data) => data.to_selection(),
				Self::Album(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod album {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "album";
		pub fn is(value: Vec<album::WhereParam>) -> WhereParam {
			WhereParam::AlbumIs(value)
		}
		pub fn is_not(value: Vec<album::WhereParam>) -> WhereParam {
			WhereParam::AlbumIsNot(value)
		}
		pub struct Order(Vec<album::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<album::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Album(v)
			}
		}
		pub struct Fetch(pub album::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<album::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Album(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(album::UniqueArgs::new())
		}
		pub struct Connect(album::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectAlbum(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: album::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<album::SelectParam>),
			Include(Vec<album::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Album(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<album::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("album", None, [], selections)
			}
			pub fn select(nested_selections: Vec<album::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<album::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<album::SelectParam>),
			Include(Vec<album::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Album(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<album::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<album::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("album", None, [], selections)
			}
			pub fn select(nested_selections: Vec<album::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<album::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod album_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "album_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::AlbumId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, AlbumId, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::AlbumId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::AlbumId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::AlbumId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::AlbumId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::AlbumId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub album: super::album::UniqueWhereParam,
		pub object: super::object::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.object_in_album()
				.create(self.album, self.object, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([album::connect(self.album), object::connect(self.object)]);
			self._params
		}
	}
	pub fn create(
		album: super::album::UniqueWhereParam,
		object: super::object::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			album,
			object,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub album_id: i32,
		pub object_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.object_in_album()
				.create_unchecked(self.album_id, self.object_id, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([album_id::set(self.album_id), object_id::set(self.object_id)]);
			self._params
		}
	}
	pub fn create_unchecked(
		album_id: i32,
		object_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			album_id,
			object_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(album_id::NAME),
				::prisma_client_rust::sel(object_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "ObjectInAlbum", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "album_id")]
		pub album_id: i32,
		#[serde(rename = "album")]
		#[specta(skip)]
		pub album: Option<Box<super::album::Data>>,
		#[serde(rename = "object_id")]
		pub object_id: i32,
		#[serde(rename = "object")]
		#[specta(skip)]
		pub object: Option<Box<super::object::Data>>,
	}
	impl Data {
		pub fn album(
			&self,
		) -> Result<&super::album::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.album
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(album),
				))
				.map(|v| v.as_ref())
		}
		pub fn object(
			&self,
		) -> Result<&super::object::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_object_in_album { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: object_in_album struct $ struct_name { # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "album_id")] pub album_id : i32 , # [serde (rename = "object_id")] pub object_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_object_in_album as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			album: super::album::UniqueWhereParam,
			object: super::object::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([album::connect(album), object::connect(object)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			album_id: i32,
			object_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([album_id::set(album_id), object_id::set(object_id)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod comment {
	use super::_prisma::*;
	pub const NAME: &str = "Comment";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		PubId(super::_prisma::read_filters::BytesFilter),
		Content(super::_prisma::read_filters::StringFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
		ObjectId(super::_prisma::read_filters::IntNullableFilter),
		ObjectIsNull,
		ObjectIs(Vec<super::object::WhereParam>),
		ObjectIsNot(Vec<super::object::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Content(value) => (content::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ObjectIsNull => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Value(
						::prisma_client_rust::PrismaValue::Null,
					),
				),
				Self::ObjectIs(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::ObjectIsNot(where_params) => (
					object::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		PubIdEquals(Vec<u8>),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::PubIdEquals(value) => {
					Self::PubId(super::_prisma::read_filters::BytesFilter::Equals(value))
				}
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		PubId(super::SortOrder),
		Content(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		ObjectId(super::SortOrder),
		Object(Vec<super::object::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::PubId(param) => ("pub_id", param.into()),
				Self::Content(param) => ("content", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::ObjectId(param) => ("object_id", param.into()),
				Self::Object(param) => (
					"object",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Object(super::object::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Object(args) => {
					let mut selections = < super :: object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Content(super::_prisma::write_params::StringParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		ObjectId(super::_prisma::write_params::IntNullableParam),
		ConnectObject(super::object::UniqueWhereParam),
		DisconnectObject,
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::PubId(value) => (pub_id::NAME, value.into()),
				Self::Content(value) => (content::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ObjectId(value) => (object_id::NAME, value.into()),
				Self::ConnectObject(where_param) => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::object::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::DisconnectObject => (
					object::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(true),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		PubId(super::_prisma::write_params::BytesParam),
		Content(super::_prisma::write_params::StringParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		ObjectId(super::_prisma::write_params::IntNullableParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::PubId(value) => ("pub_id", value.into()),
				Self::Content(value) => ("content", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
				Self::ObjectId(value) => ("object_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_comment { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: comment :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: comment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: comment :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: comment :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: comment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: comment :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , pub_id , content , date_created , date_modified , object_id , object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: comment :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: comment :: $ field :: NAME)] pub $ field : crate :: prisma :: comment :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: comment :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: comment :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: comment :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: comment :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: comment :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "content" , "date_created" , "date_modified" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: comment :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; pub_id) => { Vec < u8 > } ; (@ field_type ; content) => { String } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_modified) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; object_id) => { Option < i32 > } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; object) => { Option < crate :: prisma :: object :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Comment" , available relations are "id, pub_id, content, date_created, date_modified, object_id, object")) } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: comment :: SelectParam > :: into (crate :: prisma :: comment :: id :: Select) } ; (@ selection_field_to_selection_param ; pub_id) => { Into :: < crate :: prisma :: comment :: SelectParam > :: into (crate :: prisma :: comment :: pub_id :: Select) } ; (@ selection_field_to_selection_param ; content) => { Into :: < crate :: prisma :: comment :: SelectParam > :: into (crate :: prisma :: comment :: content :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: comment :: SelectParam > :: into (crate :: prisma :: comment :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < crate :: prisma :: comment :: SelectParam > :: into (crate :: prisma :: comment :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; object_id) => { Into :: < crate :: prisma :: comment :: SelectParam > :: into (crate :: prisma :: comment :: object_id :: Select) } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: comment :: SelectParam > :: into (crate :: prisma :: comment :: object :: Select :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: comment :: SelectParam > :: into (crate :: prisma :: comment :: object :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: comment :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; content) => { "content" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_comment as select;
	pub enum SelectParam {
		Id(id::Select),
		PubId(pub_id::Select),
		Content(content::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		ObjectId(object_id::Select),
		Object(object::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Content(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_comment { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: comment :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: comment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: comment :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: comment :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: comment :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: comment :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: comment :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: comment :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { object } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: comment :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: comment :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: comment :: pub_id :: NAME)] pub pub_id : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: comment :: content :: NAME)] pub content : String , # [specta (rename_from_path = crate :: prisma :: comment :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: comment :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: comment :: object_id :: NAME)] pub object_id : Option < i32 > , $ (# [specta (rename_from_path = crate :: prisma :: comment :: $ field :: NAME)] pub $ field : crate :: prisma :: comment :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (pub_id) , stringify ! (content) , stringify ! (date_created) , stringify ! (date_modified) , stringify ! (object_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: comment :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: comment :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: comment :: pub_id :: NAME , & self . pub_id) ? ; state . serialize_field (crate :: prisma :: comment :: content :: NAME , & self . content) ? ; state . serialize_field (crate :: prisma :: comment :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: comment :: date_modified :: NAME , & self . date_modified) ? ; state . serialize_field (crate :: prisma :: comment :: object_id :: NAME , & self . object_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , pub_id , content , date_created , date_modified , object_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: comment :: $ field :: NAME) , + , crate :: prisma :: comment :: id :: NAME , crate :: prisma :: comment :: pub_id :: NAME , crate :: prisma :: comment :: content :: NAME , crate :: prisma :: comment :: date_created :: NAME , crate :: prisma :: comment :: date_modified :: NAME , crate :: prisma :: comment :: object_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: comment :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: comment :: id :: NAME => Ok (Field :: id) , crate :: prisma :: comment :: pub_id :: NAME => Ok (Field :: pub_id) , crate :: prisma :: comment :: content :: NAME => Ok (Field :: content) , crate :: prisma :: comment :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: comment :: date_modified :: NAME => Ok (Field :: date_modified) , crate :: prisma :: comment :: object_id :: NAME => Ok (Field :: object_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut pub_id = None ; let mut content = None ; let mut date_created = None ; let mut date_modified = None ; let mut object_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: comment :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: pub_id => { if pub_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: comment :: pub_id :: NAME)) ; } pub_id = Some (map . next_value () ?) ; } Field :: content => { if content . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: comment :: content :: NAME)) ; } content = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: comment :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: comment :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } Field :: object_id => { if object_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: comment :: object_id :: NAME)) ; } object_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: comment :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: comment :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: comment :: id :: NAME)) ? ; let pub_id = pub_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: comment :: pub_id :: NAME)) ? ; let content = content . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: comment :: content :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: comment :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: comment :: date_modified :: NAME)) ? ; let object_id = object_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: comment :: object_id :: NAME)) ? ; Ok (Data { id , pub_id , content , date_created , date_modified , object_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "pub_id" , "content" , "date_created" , "date_modified" , "object_id" , "object"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: comment :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < object :: Data > } ; (@ field_type ; object) => { Option < crate :: prisma :: object :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Comment" , available relations are "object")) } ; (@ field_module ; object : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: object :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: comment :: IncludeParam > :: into (crate :: prisma :: comment :: object :: Include :: $ selection_mode (crate :: prisma :: object :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; object $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: comment :: IncludeParam > :: into (crate :: prisma :: comment :: object :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: comment :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; pub_id) => { "pub_id" } ; (@ field_serde_name ; content) => { "content" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; object_id) => { "object_id" } ; (@ field_serde_name ; object) => { "object" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_comment as include;
	pub enum IncludeParam {
		Id(id::Include),
		PubId(pub_id::Include),
		Content(content::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		ObjectId(object_id::Include),
		Object(object::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::PubId(data) => data.to_selection(),
				Self::Content(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::ObjectId(data) => data.to_selection(),
				Self::Object(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod content {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "content";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Content(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::StringFilter,
			Content,
			{
				fn in_vec(_: Vec<String>) -> InVec;
				fn not_in_vec(_: Vec<String>) -> NotInVec;
				fn lt(_: String) -> Lt;
				fn lte(_: String) -> Lte;
				fn gt(_: String) -> Gt;
				fn gte(_: String) -> Gte;
				fn contains(_: String) -> Contains;
				fn starts_with(_: String) -> StartsWith;
				fn ends_with(_: String) -> EndsWith;
				fn not(_: String) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Content(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Content(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Content(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Content(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Content(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Content(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Content(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod object {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object";
		pub fn is(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIs(value)
		}
		pub fn is_not(value: Vec<object::WhereParam>) -> WhereParam {
			WhereParam::ObjectIsNot(value)
		}
		pub struct Order(Vec<object::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<object::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Object(v)
			}
		}
		pub struct Fetch(pub object::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<object::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Object(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(object::UniqueArgs::new())
		}
		pub struct Connect(object::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectObject(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: object::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub fn disconnect() -> SetParam {
			SetParam::DisconnectObject
		}
		pub fn is_null() -> WhereParam {
			WhereParam::ObjectIsNull
		}
		pub enum Select {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Object(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<object::SelectParam>),
			Include(Vec<object::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Object(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections =
							<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
							);
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("object", None, [], selections)
			}
			pub fn select(nested_selections: Vec<object::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<object::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod object_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "object_id";
		pub fn equals(value: Option<i32>) -> WhereParam {
			WhereParam::ObjectId(_prisma::read_filters::IntNullableFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntNullableFilter,
			ObjectId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: Option<i32>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Set(pub Option<i32>);
		pub fn set<T: From<Set>>(value: Option<i32>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntNullableParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntNullableParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::ObjectId(_prisma::write_params::IntNullableParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::ObjectId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::ObjectId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::ObjectId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod pub_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "pub_id";
		pub fn equals<T: From<UniqueWhereParam>>(value: Vec<u8>) -> T {
			UniqueWhereParam::PubIdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BytesFilter, PubId, {
			fn in_vec(_: Vec<Vec<u8>>) -> InVec;
			fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
			fn not(_: Vec<u8>) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::PubId(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::PubId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::PubId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::PubId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub pub_id: Vec<u8>,
		pub content: String,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.comment()
				.create(self.pub_id, self.content, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params
				.extend([pub_id::set(self.pub_id), content::set(self.content)]);
			self._params
		}
	}
	pub fn create(pub_id: Vec<u8>, content: String, _params: Vec<SetParam>) -> Create {
		Create {
			pub_id,
			content,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub pub_id: Vec<u8>,
		pub content: String,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.comment()
				.create_unchecked(self.pub_id, self.content, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params
				.extend([pub_id::set(self.pub_id), content::set(self.content)]);
			self._params
		}
	}
	pub fn create_unchecked(
		pub_id: Vec<u8>,
		content: String,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			pub_id,
			content,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(pub_id::NAME),
				::prisma_client_rust::sel(content::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
				::prisma_client_rust::sel(object_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "Comment", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "pub_id")]
		pub pub_id: Vec<u8>,
		#[serde(rename = "content")]
		pub content: String,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_modified")]
		pub date_modified:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "object_id")]
		pub object_id: Option<i32>,
		#[serde(
			rename = "object",
			default,
			skip_serializing_if = "Option::is_none",
			with = "prisma_client_rust::serde::double_option"
		)]
		#[specta(skip)]
		pub object: Option<Option<Box<super::object::Data>>>,
	}
	impl Data {
		pub fn object(
			&self,
		) -> Result<Option<&super::object::Data>, ::prisma_client_rust::RelationNotFetchedError> {
			self.object
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(object),
				))
				.map(|v| v.as_ref().map(|v| v.as_ref()))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_comment { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: comment struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "pub_id")] pub pub_id : Vec < u8 > , # [serde (rename = "content")] pub content : String , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "object_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub object_id : Option < i32 > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_comment as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			pub_id: Vec<u8>,
			content: String,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([pub_id::set(pub_id), content::set(content)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			pub_id: Vec<u8>,
			content: String,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([pub_id::set(pub_id), content::set(content)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod indexer_rule {
	use super::_prisma::*;
	pub const NAME: &str = "IndexerRule";
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		Id(super::_prisma::read_filters::IntFilter),
		Name(super::_prisma::read_filters::StringFilter),
		Default(super::_prisma::read_filters::BooleanFilter),
		RulesPerKind(super::_prisma::read_filters::BytesFilter),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		DateModified(super::_prisma::read_filters::DateTimeFilter),
		LocationsSome(Vec<super::indexer_rules_in_location::WhereParam>),
		LocationsEvery(Vec<super::indexer_rules_in_location::WhereParam>),
		LocationsNone(Vec<super::indexer_rules_in_location::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Id(value) => (id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Default(value) => (default::NAME, value.into()),
				Self::RulesPerKind(value) => (rules_per_kind::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::LocationsSome(where_params) => (
					locations::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"some".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationsEvery(where_params) => (
					locations::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"every".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationsNone(where_params) => (
					locations::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"none".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::IdEquals(value) => {
					Self::Id(super::_prisma::read_filters::IntFilter::Equals(value))
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		Id(super::SortOrder),
		Name(super::SortOrder),
		Default(super::SortOrder),
		RulesPerKind(super::SortOrder),
		DateCreated(super::SortOrder),
		DateModified(super::SortOrder),
		Locations(Vec<super::indexer_rules_in_location::OrderByRelationAggregateParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(param) => ("id", param.into()),
				Self::Name(param) => ("name", param.into()),
				Self::Default(param) => ("default", param.into()),
				Self::RulesPerKind(param) => ("rules_per_kind", param.into()),
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::DateModified(param) => ("date_modified", param.into()),
				Self::Locations(param) => (
					"locations",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Locations(super::indexer_rules_in_location::ManyArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Locations(args) => {
					let (arguments, mut nested_selections) = args.to_graphql();
					nested_selections . extend (< super :: indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
					::prisma_client_rust::Selection::new(
						locations::NAME,
						None,
						arguments,
						nested_selections,
					)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		Id(super::_prisma::write_params::IntParam),
		Name(super::_prisma::write_params::StringParam),
		Default(super::_prisma::write_params::BooleanParam),
		RulesPerKind(super::_prisma::write_params::BytesParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
		ConnectLocations(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
		DisconnectLocations(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
		SetLocations(Vec<super::indexer_rules_in_location::UniqueWhereParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => (id::NAME, value.into()),
				Self::Name(value) => (name::NAME, value.into()),
				Self::Default(value) => (default::NAME, value.into()),
				Self::RulesPerKind(value) => (rules_per_kind::NAME, value.into()),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::DateModified(value) => (date_modified::NAME, value.into()),
				Self::ConnectLocations(where_params) => (
					locations::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::DisconnectLocations(where_params) => (
					locations::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"disconnect".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
				Self::SetLocations(where_params) => (
					locations::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"set".to_string(),
						::prisma_client_rust::PrismaValue::List(
							where_params
								.into_iter()
								.map(Into::<super::indexer_rules_in_location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		Id(super::_prisma::write_params::IntParam),
		Name(super::_prisma::write_params::StringParam),
		Default(super::_prisma::write_params::BooleanParam),
		RulesPerKind(super::_prisma::write_params::BytesParam),
		DateCreated(super::_prisma::write_params::DateTimeParam),
		DateModified(super::_prisma::write_params::DateTimeParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::Id(value) => ("id", value.into()),
				Self::Name(value) => ("name", value.into()),
				Self::Default(value) => ("default", value.into()),
				Self::RulesPerKind(value) => ("rules_per_kind", value.into()),
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::DateModified(value) => ("date_modified", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_indexer_rule { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: indexer_rule :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: indexer_rule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: indexer_rule :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: indexer_rule :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: indexer_rule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: indexer_rule :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , default , rules_per_kind , date_created , date_modified , locations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: indexer_rule :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: indexer_rule :: $ field :: NAME)] pub $ field : crate :: prisma :: indexer_rule :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: indexer_rule :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: indexer_rule :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: indexer_rule :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rule :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rule :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "default" , "rules_per_kind" , "date_created" , "date_modified" , "locations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: indexer_rule :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; default) => { bool } ; (@ field_type ; rules_per_kind) => { Vec < u8 > } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; date_modified) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < locations :: Data > } ; (@ field_type ; locations) => { Vec < crate :: prisma :: indexer_rules_in_location :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "IndexerRule" , available relations are "id, name, default, rules_per_kind, date_created, date_modified, locations")) } ; (@ field_module ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: indexer_rules_in_location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: indexer_rule :: SelectParam > :: into (crate :: prisma :: indexer_rule :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: indexer_rule :: SelectParam > :: into (crate :: prisma :: indexer_rule :: name :: Select) } ; (@ selection_field_to_selection_param ; default) => { Into :: < crate :: prisma :: indexer_rule :: SelectParam > :: into (crate :: prisma :: indexer_rule :: default :: Select) } ; (@ selection_field_to_selection_param ; rules_per_kind) => { Into :: < crate :: prisma :: indexer_rule :: SelectParam > :: into (crate :: prisma :: indexer_rule :: rules_per_kind :: Select) } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: indexer_rule :: SelectParam > :: into (crate :: prisma :: indexer_rule :: date_created :: Select) } ; (@ selection_field_to_selection_param ; date_modified) => { Into :: < crate :: prisma :: indexer_rule :: SelectParam > :: into (crate :: prisma :: indexer_rule :: date_modified :: Select) } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: indexer_rule :: SelectParam > :: into (crate :: prisma :: indexer_rule :: locations :: Select :: $ selection_mode (crate :: prisma :: indexer_rules_in_location :: ManyArgs :: new (crate :: prisma :: indexer_rules_in_location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: indexer_rule :: SelectParam > :: into (crate :: prisma :: indexer_rule :: locations :: Select :: Fetch (crate :: prisma :: indexer_rules_in_location :: ManyArgs :: new (crate :: prisma :: indexer_rules_in_location :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: indexer_rule :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; default) => { "default" } ; (@ field_serde_name ; rules_per_kind) => { "rules_per_kind" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; locations) => { "locations" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_indexer_rule as select;
	pub enum SelectParam {
		Id(id::Select),
		Name(name::Select),
		Default(default::Select),
		RulesPerKind(rules_per_kind::Select),
		DateCreated(date_created::Select),
		DateModified(date_modified::Select),
		Locations(locations::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Default(data) => data.to_selection(),
				Self::RulesPerKind(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Locations(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_indexer_rule { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: indexer_rule :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: indexer_rule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: indexer_rule :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: indexer_rule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: indexer_rule :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: indexer_rule :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: indexer_rule :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: indexer_rule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { locations } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: indexer_rule :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: indexer_rule :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: prisma :: indexer_rule :: name :: NAME)] pub name : String , # [specta (rename_from_path = crate :: prisma :: indexer_rule :: default :: NAME)] pub default : bool , # [specta (rename_from_path = crate :: prisma :: indexer_rule :: rules_per_kind :: NAME)] pub rules_per_kind : Vec < u8 > , # [specta (rename_from_path = crate :: prisma :: indexer_rule :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: indexer_rule :: date_modified :: NAME)] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: prisma :: indexer_rule :: $ field :: NAME)] pub $ field : crate :: prisma :: indexer_rule :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (default) , stringify ! (rules_per_kind) , stringify ! (date_created) , stringify ! (date_modified)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: indexer_rule :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: indexer_rule :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: indexer_rule :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: indexer_rule :: default :: NAME , & self . default) ? ; state . serialize_field (crate :: prisma :: indexer_rule :: rules_per_kind :: NAME , & self . rules_per_kind) ? ; state . serialize_field (crate :: prisma :: indexer_rule :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: indexer_rule :: date_modified :: NAME , & self . date_modified) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , default , rules_per_kind , date_created , date_modified } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: indexer_rule :: $ field :: NAME) , + , crate :: prisma :: indexer_rule :: id :: NAME , crate :: prisma :: indexer_rule :: name :: NAME , crate :: prisma :: indexer_rule :: default :: NAME , crate :: prisma :: indexer_rule :: rules_per_kind :: NAME , crate :: prisma :: indexer_rule :: date_created :: NAME , crate :: prisma :: indexer_rule :: date_modified :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: indexer_rule :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: indexer_rule :: id :: NAME => Ok (Field :: id) , crate :: prisma :: indexer_rule :: name :: NAME => Ok (Field :: name) , crate :: prisma :: indexer_rule :: default :: NAME => Ok (Field :: default) , crate :: prisma :: indexer_rule :: rules_per_kind :: NAME => Ok (Field :: rules_per_kind) , crate :: prisma :: indexer_rule :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: indexer_rule :: date_modified :: NAME => Ok (Field :: date_modified) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut default = None ; let mut rules_per_kind = None ; let mut date_created = None ; let mut date_modified = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rule :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rule :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: default => { if default . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rule :: default :: NAME)) ; } default = Some (map . next_value () ?) ; } Field :: rules_per_kind => { if rules_per_kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rule :: rules_per_kind :: NAME)) ; } rules_per_kind = Some (map . next_value () ?) ; } Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rule :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: date_modified => { if date_modified . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rule :: date_modified :: NAME)) ; } date_modified = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rule :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rule :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rule :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rule :: name :: NAME)) ? ; let default = default . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rule :: default :: NAME)) ? ; let rules_per_kind = rules_per_kind . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rule :: rules_per_kind :: NAME)) ? ; let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rule :: date_created :: NAME)) ? ; let date_modified = date_modified . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rule :: date_modified :: NAME)) ? ; Ok (Data { id , name , default , rules_per_kind , date_created , date_modified , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "default" , "rules_per_kind" , "date_created" , "date_modified" , "locations"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: indexer_rule :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < locations :: Data > } ; (@ field_type ; locations) => { Vec < crate :: prisma :: indexer_rules_in_location :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "IndexerRule" , available relations are "locations")) } ; (@ field_module ; locations : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: indexer_rules_in_location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: indexer_rule :: IncludeParam > :: into (crate :: prisma :: indexer_rule :: locations :: Include :: $ selection_mode (crate :: prisma :: indexer_rules_in_location :: ManyArgs :: new (crate :: prisma :: indexer_rules_in_location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; locations $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: indexer_rule :: IncludeParam > :: into (crate :: prisma :: indexer_rule :: locations :: Include :: Fetch (crate :: prisma :: indexer_rules_in_location :: ManyArgs :: new (crate :: prisma :: indexer_rules_in_location :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: indexer_rule :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; default) => { "default" } ; (@ field_serde_name ; rules_per_kind) => { "rules_per_kind" } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; date_modified) => { "date_modified" } ; (@ field_serde_name ; locations) => { "locations" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_indexer_rule as include;
	pub enum IncludeParam {
		Id(id::Include),
		Name(name::Include),
		Default(default::Include),
		RulesPerKind(rules_per_kind::Include),
		DateCreated(date_created::Include),
		DateModified(date_modified::Include),
		Locations(locations::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Name(data) => data.to_selection(),
				Self::Default(data) => data.to_selection(),
				Self::RulesPerKind(data) => data.to_selection(),
				Self::DateCreated(data) => data.to_selection(),
				Self::DateModified(data) => data.to_selection(),
				Self::Locations(data) => data.to_selection(),
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod date_modified {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_modified";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateModified(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateModified,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateModified(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateModified(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateModified(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateModified(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod default {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "default";
		pub fn equals(value: bool) -> WhereParam {
			WhereParam::Default(_prisma::read_filters::BooleanFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BooleanFilter,
			Default,
			{
				fn not(_: bool) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Default(v)
			}
		}
		pub struct Set(pub bool);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Default(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Default(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: bool) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BooleanParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Default(_prisma::write_params::BooleanParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Default(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Default(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Default(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "id";
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
			fn in_vec(_: Vec<i32>) -> InVec;
			fn not_in_vec(_: Vec<i32>) -> NotInVec;
			fn lt(_: i32) -> Lt;
			fn lte(_: i32) -> Lte;
			fn gt(_: i32) -> Gt;
			fn gte(_: i32) -> Gte;
			fn not(_: i32) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Id(v)
			}
		}
		pub struct Set(pub i32);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Id(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Id(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod locations {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "locations";
		pub fn some(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::LocationsSome(value)
		}
		pub fn every(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::LocationsEvery(value)
		}
		pub fn none(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
			WhereParam::LocationsNone(value)
		}
		pub struct Order(Vec<indexer_rules_in_location::OrderByRelationAggregateParam>);
		pub fn order<T: From<Order>>(
			v: Vec<indexer_rules_in_location::OrderByRelationAggregateParam>,
		) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Locations(v)
			}
		}
		pub struct Fetch(pub indexer_rules_in_location::ManyArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<indexer_rules_in_location::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
			pub fn order_by(
				mut self,
				param: indexer_rules_in_location::OrderByWithRelationParam,
			) -> Self {
				self.0 = self.0.order_by(param);
				self
			}
			pub fn skip(mut self, value: i64) -> Self {
				self.0 = self.0.skip(value);
				self
			}
			pub fn take(mut self, value: i64) -> Self {
				self.0 = self.0.take(value);
				self
			}
			pub fn cursor(mut self, value: indexer_rules_in_location::UniqueWhereParam) -> Self {
				self.0 = self.0.cursor(value.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Locations(v)
			}
		}
		pub fn fetch(params: Vec<indexer_rules_in_location::WhereParam>) -> Fetch {
			Fetch(indexer_rules_in_location::ManyArgs::new(params))
		}
		pub struct Connect(pub Vec<indexer_rules_in_location::UniqueWhereParam>);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLocations(v)
			}
		}
		pub fn connect<T: From<Connect>>(
			params: Vec<indexer_rules_in_location::UniqueWhereParam>,
		) -> T {
			Connect(params).into()
		}
		pub fn disconnect(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
			SetParam::DisconnectLocations(params)
		}
		pub fn set(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
			SetParam::SetLocations(params)
		}
		pub enum Select {
			Select(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::SelectParam>,
			),
			Include(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::IncludeParam>,
			),
			Fetch(indexer_rules_in_location::ManyArgs),
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Locations(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
		pub enum Include {
			Select(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::SelectParam>,
			),
			Include(
				indexer_rules_in_location::ManyArgs,
				Vec<indexer_rules_in_location::IncludeParam>,
			),
			Fetch(indexer_rules_in_location::ManyArgs),
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Locations(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
				::prisma_client_rust::Selection::new(NAME, None, args, selections)
			}
			pub fn select(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::SelectParam>,
			) -> Self {
				Self::Select(args, nested_selections)
			}
			pub fn include(
				args: indexer_rules_in_location::ManyArgs,
				nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
			) -> Self {
				Self::Include(args, nested_selections)
			}
		}
	}
	pub mod name {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "name";
		pub fn equals(value: String) -> WhereParam {
			WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
			fn in_vec(_: Vec<String>) -> InVec;
			fn not_in_vec(_: Vec<String>) -> NotInVec;
			fn lt(_: String) -> Lt;
			fn lte(_: String) -> Lte;
			fn gt(_: String) -> Gt;
			fn gte(_: String) -> Gte;
			fn contains(_: String) -> Contains;
			fn starts_with(_: String) -> StartsWith;
			fn ends_with(_: String) -> EndsWith;
			fn not(_: String) -> Not;
		});
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Name(v)
			}
		}
		pub struct Set(pub String);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::StringParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::Name(_prisma::write_params::StringParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::Name(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Name(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Name(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod rules_per_kind {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "rules_per_kind";
		pub fn equals(value: Vec<u8>) -> WhereParam {
			WhereParam::RulesPerKind(_prisma::read_filters::BytesFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::BytesFilter,
			RulesPerKind,
			{
				fn in_vec(_: Vec<Vec<u8>>) -> InVec;
				fn not_in_vec(_: Vec<Vec<u8>>) -> NotInVec;
				fn not(_: Vec<u8>) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::RulesPerKind(v)
			}
		}
		pub struct Set(pub Vec<u8>);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RulesPerKind(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::RulesPerKind(_prisma::write_params::BytesParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(value: Vec<u8>) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::BytesParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::RulesPerKind(_prisma::write_params::BytesParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::RulesPerKind(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::RulesPerKind(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::RulesPerKind(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub name: String,
		pub rules_per_kind: Vec<u8>,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client
				.indexer_rule()
				.create(self.name, self.rules_per_kind, self._params)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				name::set(self.name),
				rules_per_kind::set(self.rules_per_kind),
			]);
			self._params
		}
	}
	pub fn create(name: String, rules_per_kind: Vec<u8>, _params: Vec<SetParam>) -> Create {
		Create {
			name,
			rules_per_kind,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub name: String,
		pub rules_per_kind: Vec<u8>,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client
				.indexer_rule()
				.create_unchecked(self.name, self.rules_per_kind, self._params)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				name::set(self.name),
				rules_per_kind::set(self.rules_per_kind),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		name: String,
		rules_per_kind: Vec<u8>,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			name,
			rules_per_kind,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(id::NAME),
				::prisma_client_rust::sel(name::NAME),
				::prisma_client_rust::sel(default::NAME),
				::prisma_client_rust::sel(rules_per_kind::NAME),
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(date_modified::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(rename = "IndexerRule", crate = "prisma_client_rust::specta")]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "name")]
		pub name: String,
		#[serde(rename = "default")]
		pub default: bool,
		#[serde(rename = "rules_per_kind")]
		pub rules_per_kind: Vec<u8>,
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "date_modified")]
		pub date_modified:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "locations")]
		#[specta(skip)]
		pub locations: Option<Vec<super::indexer_rules_in_location::Data>>,
	}
	impl Data {
		pub fn locations(
			&self,
		) -> Result<
			&Vec<super::indexer_rules_in_location::Data>,
			::prisma_client_rust::RelationNotFetchedError,
		> {
			self.locations
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(locations),
				))
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_indexer_rule { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: indexer_rule struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "name")] pub name : String , # [serde (rename = "default")] pub default : bool , # [serde (rename = "rules_per_kind")] pub rules_per_kind : Vec < u8 > , # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "date_modified")] pub date_modified : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_indexer_rule as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			name: String,
			rules_per_kind: Vec<u8>,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([name::set(name), rules_per_kind::set(rules_per_kind)]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			name: String,
			rules_per_kind: Vec<u8>,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([name::set(name), rules_per_kind::set(rules_per_kind)]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod indexer_rules_in_location {
	use super::_prisma::*;
	pub const NAME: &str = "IndexerRulesInLocation";
	pub fn location_id_indexer_rule_id<T: From<UniqueWhereParam>>(
		location_id: i32,
		indexer_rule_id: i32,
	) -> T {
		UniqueWhereParam::LocationIdIndexerRuleIdEquals(location_id, indexer_rule_id).into()
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		LocationIdIndexerRuleIdEquals(i32, i32),
		DateCreated(super::_prisma::read_filters::DateTimeFilter),
		LocationId(super::_prisma::read_filters::IntFilter),
		LocationIs(Vec<super::location::WhereParam>),
		LocationIsNot(Vec<super::location::WhereParam>),
		IndexerRuleId(super::_prisma::read_filters::IntFilter),
		IndexerRuleIs(Vec<super::indexer_rule::WhereParam>),
		IndexerRuleIsNot(Vec<super::indexer_rule::WhereParam>),
	}
	impl ::prisma_client_rust::WhereInput for WhereParam {
		fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
			let (name, value) = match self {
				Self::Not(value) => (
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::Or(value) => (
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
							.collect(),
					),
				),
				Self::And(value) => (
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						::prisma_client_rust::merge_fields(
							value
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(Into::into)
								.collect(),
						),
					),
				),
				Self::LocationIdIndexerRuleIdEquals(location_id, indexer_rule_id) => (
					"location_id_indexer_rule_id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![
						(
							location_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(location_id as i64),
						),
						(
							indexer_rule_id::NAME.to_string(),
							::prisma_client_rust::PrismaValue::Int(indexer_rule_id as i64),
						),
					]),
				),
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::LocationId(value) => (location_id::NAME, value.into()),
				Self::LocationIs(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::LocationIsNot(where_params) => (
					location::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRuleId(value) => (indexer_rule_id::NAME, value.into()),
				Self::IndexerRuleIs(where_params) => (
					indexer_rule::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"is".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRuleIsNot(where_params) => (
					indexer_rule::NAME,
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"isNot".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							where_params
								.into_iter()
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		LocationIdIndexerRuleIdEquals(i32, i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::LocationIdIndexerRuleIdEquals(location_id, indexer_rule_id) => {
					Self::LocationIdIndexerRuleIdEquals(location_id, indexer_rule_id)
				}
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByWithRelationParam {
		DateCreated(super::SortOrder),
		LocationId(super::SortOrder),
		IndexerRuleId(super::SortOrder),
		Location(Vec<super::location::OrderByWithRelationParam>),
		IndexerRule(Vec<super::indexer_rule::OrderByWithRelationParam>),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(param) => ("date_created", param.into()),
				Self::LocationId(param) => ("location_id", param.into()),
				Self::IndexerRuleId(param) => ("indexer_rule_id", param.into()),
				Self::Location(param) => (
					"location",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
				Self::IndexerRule(param) => (
					"indexer_rule",
					::prisma_client_rust::PrismaValue::Object(
						param.into_iter().map(Into::into).collect(),
					),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum OrderByRelationAggregateParam {
		_Count(super::SortOrder),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::_Count(param) => ("_count", param.into()),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum WithParam {
		Location(super::location::UniqueArgs),
		IndexerRule(super::indexer_rule::UniqueArgs),
	}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Location(args) => {
					let mut selections = < super :: location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(location::NAME, None, [], selections)
				}
				Self::IndexerRule(args) => {
					let mut selections = < super :: indexer_rule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
					selections.extend(
						args.with_params
							.into_iter()
							.map(Into::<::prisma_client_rust::Selection>::into),
					);
					::prisma_client_rust::Selection::new(indexer_rule::NAME, None, [], selections)
				}
			}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		LocationId(super::_prisma::write_params::IntParam),
		ConnectLocation(super::location::UniqueWhereParam),
		IndexerRuleId(super::_prisma::write_params::IntParam),
		ConnectIndexerRule(super::indexer_rule::UniqueWhereParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => (date_created::NAME, value.into()),
				Self::LocationId(value) => (location_id::NAME, value.into()),
				Self::ConnectLocation(where_param) => (
					location::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::location::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
				Self::IndexerRuleId(value) => (indexer_rule_id::NAME, value.into()),
				Self::ConnectIndexerRule(where_param) => (
					indexer_rule::NAME,
					::prisma_client_rust::PrismaValue::Object(vec![(
						"connect".to_string(),
						::prisma_client_rust::PrismaValue::Object(
							[where_param]
								.into_iter()
								.map(Into::<super::indexer_rule::WhereParam>::into)
								.map(::prisma_client_rust::WhereInput::serialize)
								.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
								.collect(),
						),
					)]),
				),
			};
			(k.to_string(), v)
		}
	}
	#[derive(Clone)]
	pub enum UncheckedSetParam {
		DateCreated(super::_prisma::write_params::DateTimeParam),
		LocationId(super::_prisma::write_params::IntParam),
		IndexerRuleId(super::_prisma::write_params::IntParam),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			let (k, v) = match self {
				Self::DateCreated(value) => ("date_created", value.into()),
				Self::LocationId(value) => ("location_id", value.into()),
				Self::IndexerRuleId(value) => ("indexer_rule_id", value.into()),
			};
			(k.to_string(), v)
		}
	}
	#[macro_export]
	macro_rules ! _select_indexer_rules_in_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: indexer_rules_in_location :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: indexer_rules_in_location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: indexer_rules_in_location :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: indexer_rules_in_location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: indexer_rules_in_location :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { date_created , location_id , location , indexer_rule_id , indexer_rule } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: indexer_rules_in_location :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: prisma :: indexer_rules_in_location :: $ field :: NAME)] pub $ field : crate :: prisma :: indexer_rules_in_location :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "location_id" , "location" , "indexer_rule_id" , "indexer_rule"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: indexer_rules_in_location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; date_created) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; location_id) => { i32 } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { location :: Data } ; (@ field_type ; location) => { crate :: prisma :: location :: Data } ; (@ field_type ; indexer_rule_id) => { i32 } ; (@ field_type ; indexer_rule : $ selection_mode : ident { $ ($ selections : tt) + }) => { indexer_rule :: Data } ; (@ field_type ; indexer_rule) => { crate :: prisma :: indexer_rule :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "IndexerRulesInLocation" , available relations are "date_created, location_id, location, indexer_rule_id, indexer_rule")) } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; indexer_rule : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: indexer_rule :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; date_created) => { Into :: < crate :: prisma :: indexer_rules_in_location :: SelectParam > :: into (crate :: prisma :: indexer_rules_in_location :: date_created :: Select) } ; (@ selection_field_to_selection_param ; location_id) => { Into :: < crate :: prisma :: indexer_rules_in_location :: SelectParam > :: into (crate :: prisma :: indexer_rules_in_location :: location_id :: Select) } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: indexer_rules_in_location :: SelectParam > :: into (crate :: prisma :: indexer_rules_in_location :: location :: Select :: $ selection_mode (crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: indexer_rules_in_location :: SelectParam > :: into (crate :: prisma :: indexer_rules_in_location :: location :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; indexer_rule_id) => { Into :: < crate :: prisma :: indexer_rules_in_location :: SelectParam > :: into (crate :: prisma :: indexer_rules_in_location :: indexer_rule_id :: Select) } ; (@ selection_field_to_selection_param ; indexer_rule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: indexer_rules_in_location :: SelectParam > :: into (crate :: prisma :: indexer_rules_in_location :: indexer_rule :: Select :: $ selection_mode (crate :: prisma :: indexer_rule :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; indexer_rule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: indexer_rules_in_location :: SelectParam > :: into (crate :: prisma :: indexer_rules_in_location :: indexer_rule :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: indexer_rules_in_location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; location) => { "location" } ; (@ field_serde_name ; indexer_rule_id) => { "indexer_rule_id" } ; (@ field_serde_name ; indexer_rule) => { "indexer_rule" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _select_indexer_rules_in_location as select;
	pub enum SelectParam {
		DateCreated(date_created::Select),
		LocationId(location_id::Select),
		Location(location::Select),
		IndexerRuleId(indexer_rule_id::Select),
		IndexerRule(indexer_rule::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::LocationId(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::IndexerRuleId(data) => data.to_selection(),
				Self::IndexerRule(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_indexer_rules_in_location { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: indexer_rules_in_location :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: indexer_rules_in_location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: indexer_rules_in_location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: indexer_rules_in_location :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: indexer_rules_in_location :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: indexer_rules_in_location :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { location , indexer_rule } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: prisma :: indexer_rules_in_location :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: prisma :: indexer_rules_in_location :: date_created :: NAME)] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: prisma :: indexer_rules_in_location :: location_id :: NAME)] pub location_id : i32 , # [specta (rename_from_path = crate :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME)] pub indexer_rule_id : i32 , $ (# [specta (rename_from_path = crate :: prisma :: indexer_rules_in_location :: $ field :: NAME)] pub $ field : crate :: prisma :: indexer_rules_in_location :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> std :: result :: Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (date_created) , stringify ! (location_id) , stringify ! (indexer_rule_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: indexer_rules_in_location :: date_created :: NAME , & self . date_created) ? ; state . serialize_field (crate :: prisma :: indexer_rules_in_location :: location_id :: NAME , & self . location_id) ? ; state . serialize_field (crate :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME , & self . indexer_rule_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , date_created , location_id , indexer_rule_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> std :: result :: Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME) , + , crate :: prisma :: indexer_rules_in_location :: date_created :: NAME , crate :: prisma :: indexer_rules_in_location :: location_id :: NAME , crate :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> std :: result :: Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: indexer_rules_in_location :: date_created :: NAME => Ok (Field :: date_created) , crate :: prisma :: indexer_rules_in_location :: location_id :: NAME => Ok (Field :: location_id) , crate :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME => Ok (Field :: indexer_rule_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> std :: result :: Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut date_created = None ; let mut location_id = None ; let mut indexer_rule_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: date_created => { if date_created . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rules_in_location :: date_created :: NAME)) ; } date_created = Some (map . next_value () ?) ; } Field :: location_id => { if location_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rules_in_location :: location_id :: NAME)) ; } location_id = Some (map . next_value () ?) ; } Field :: indexer_rule_id => { if indexer_rule_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME)) ; } indexer_rule_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rules_in_location :: $ field :: NAME)) ? ;) * let date_created = date_created . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rules_in_location :: date_created :: NAME)) ? ; let location_id = location_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rules_in_location :: location_id :: NAME)) ? ; let indexer_rule_id = indexer_rule_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: indexer_rules_in_location :: indexer_rule_id :: NAME)) ? ; Ok (Data { date_created , location_id , indexer_rule_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["date_created" , "location_id" , "location" , "indexer_rule_id" , "indexer_rule"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: indexer_rules_in_location :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { location :: Data } ; (@ field_type ; location) => { crate :: prisma :: location :: Data } ; (@ field_type ; indexer_rule : $ selection_mode : ident { $ ($ selections : tt) + }) => { indexer_rule :: Data } ; (@ field_type ; indexer_rule) => { crate :: prisma :: indexer_rule :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "IndexerRulesInLocation" , available relations are "location, indexer_rule")) } ; (@ field_module ; location : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: location :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; indexer_rule : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: indexer_rule :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: indexer_rules_in_location :: IncludeParam > :: into (crate :: prisma :: indexer_rules_in_location :: location :: Include :: $ selection_mode (crate :: prisma :: location :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; location $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: indexer_rules_in_location :: IncludeParam > :: into (crate :: prisma :: indexer_rules_in_location :: location :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; indexer_rule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: indexer_rules_in_location :: IncludeParam > :: into (crate :: prisma :: indexer_rules_in_location :: indexer_rule :: Include :: $ selection_mode (crate :: prisma :: indexer_rule :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; indexer_rule $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: indexer_rules_in_location :: IncludeParam > :: into (crate :: prisma :: indexer_rules_in_location :: indexer_rule :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: indexer_rules_in_location :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; date_created) => { "date_created" } ; (@ field_serde_name ; location_id) => { "location_id" } ; (@ field_serde_name ; location) => { "location" } ; (@ field_serde_name ; indexer_rule_id) => { "indexer_rule_id" } ; (@ field_serde_name ; indexer_rule) => { "indexer_rule" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
	pub use _include_indexer_rules_in_location as include;
	pub enum IncludeParam {
		DateCreated(date_created::Include),
		LocationId(location_id::Include),
		Location(location::Include),
		IndexerRuleId(indexer_rule_id::Include),
		IndexerRule(indexer_rule::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::DateCreated(data) => data.to_selection(),
				Self::LocationId(data) => data.to_selection(),
				Self::Location(data) => data.to_selection(),
				Self::IndexerRuleId(data) => data.to_selection(),
				Self::IndexerRule(data) => data.to_selection(),
			}
		}
	}
	pub mod _count {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "_count";
		pub struct Order(super::SortOrder);
		pub fn order<T: From<Order>>(v: super::SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByRelationAggregateParam {
			fn from(Order(v): Order) -> Self {
				Self::_Count(v)
			}
		}
	}
	pub mod date_created {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "date_created";
		pub fn equals(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> WhereParam {
			WhereParam::DateCreated(_prisma::read_filters::DateTimeFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::DateTimeFilter,
			DateCreated,
			{
				fn in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> InVec;
				fn not_in_vec(
					_: Vec<
						::prisma_client_rust::chrono::DateTime<
							::prisma_client_rust::chrono::FixedOffset,
						>,
					>,
				) -> NotInVec;
				fn lt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lt;
				fn lte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Lte;
				fn gt(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gt;
				fn gte(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Gte;
				fn not(
					_: ::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Set(
			pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		);
		impl From<UpdateOperation> for SetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		impl From<Set> for SetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		pub fn set<T: From<Set>>(
			value: ::prisma_client_rust::chrono::DateTime<
				::prisma_client_rust::chrono::FixedOffset,
			>,
		) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::DateTimeParam);
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::DateCreated(_prisma::write_params::DateTimeParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::DateCreated(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::DateCreated(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::DateCreated(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod indexer_rule {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "indexer_rule";
		pub fn is(value: Vec<indexer_rule::WhereParam>) -> WhereParam {
			WhereParam::IndexerRuleIs(value)
		}
		pub fn is_not(value: Vec<indexer_rule::WhereParam>) -> WhereParam {
			WhereParam::IndexerRuleIsNot(value)
		}
		pub struct Order(Vec<indexer_rule::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<indexer_rule::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IndexerRule(v)
			}
		}
		pub struct Fetch(pub indexer_rule::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<indexer_rule::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::IndexerRule(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(indexer_rule::UniqueArgs::new())
		}
		pub struct Connect(indexer_rule::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectIndexerRule(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: indexer_rule::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<indexer_rule::SelectParam>),
			Include(Vec<indexer_rule::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IndexerRule(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<indexer_rule::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						)
					}
				};
				::prisma_client_rust::Selection::new("indexer_rule", None, [], selections)
			}
			pub fn select(nested_selections: Vec<indexer_rule::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<indexer_rule::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<indexer_rule::SelectParam>),
			Include(Vec<indexer_rule::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IndexerRule(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = < indexer_rule :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<indexer_rule::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
						)
					}
				};
				::prisma_client_rust::Selection::new("indexer_rule", None, [], selections)
			}
			pub fn select(nested_selections: Vec<indexer_rule::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<indexer_rule::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod indexer_rule_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "indexer_rule_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::IndexerRuleId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			IndexerRuleId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::IndexerRuleId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::IndexerRuleId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::IndexerRuleId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::IndexerRuleId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::IndexerRuleId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	pub mod location {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "location";
		pub fn is(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIs(value)
		}
		pub fn is_not(value: Vec<location::WhereParam>) -> WhereParam {
			WhereParam::LocationIsNot(value)
		}
		pub struct Order(Vec<location::OrderByWithRelationParam>);
		pub fn order<T: From<Order>>(v: Vec<location::OrderByWithRelationParam>) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::Location(v)
			}
		}
		pub struct Fetch(pub location::UniqueArgs);
		impl Fetch {
			pub fn with(mut self, params: impl Into<location::WithParam>) -> Self {
				self.0 = self.0.with(params.into());
				self
			}
		}
		impl From<Fetch> for WithParam {
			fn from(Fetch(v): Fetch) -> Self {
				WithParam::Location(v)
			}
		}
		pub fn fetch() -> Fetch {
			Fetch(location::UniqueArgs::new())
		}
		pub struct Connect(location::UniqueWhereParam);
		impl From<Connect> for SetParam {
			fn from(Connect(v): Connect) -> Self {
				Self::ConnectLocation(v)
			}
		}
		pub fn connect<T: From<Connect>>(value: location::UniqueWhereParam) -> T {
			Connect(value).into()
		}
		pub enum Select {
			Select(Vec<location::SelectParam>),
			Include(Vec<location::IncludeParam>),
			Fetch,
		}
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Location(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = vec![];
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("location", None, [], selections)
			}
			pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
		pub enum Include {
			Select(Vec<location::SelectParam>),
			Include(Vec<location::IncludeParam>),
			Fetch,
		}
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Location(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				let selections = match self {
					Self::Select(selections) => {
						selections.into_iter().map(|s| s.to_selection()).collect()
					}
					Self::Include(selections) => {
						let mut nested_selections = < location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
						nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
						nested_selections
					}
					Self::Fetch => {
						<location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
					}
				};
				::prisma_client_rust::Selection::new("location", None, [], selections)
			}
			pub fn select(nested_selections: Vec<location::SelectParam>) -> Self {
				Self::Select(nested_selections)
			}
			pub fn include(nested_selections: Vec<location::IncludeParam>) -> Self {
				Self::Include(nested_selections)
			}
		}
	}
	pub mod location_id {
		use super::super::{_prisma::*, *};
		use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
		pub const NAME: &str = "location_id";
		pub fn equals(value: i32) -> WhereParam {
			WhereParam::LocationId(_prisma::read_filters::IntFilter::Equals(value))
		}
		::prisma_client_rust::scalar_where_param_fns!(
			_prisma::read_filters::IntFilter,
			LocationId,
			{
				fn in_vec(_: Vec<i32>) -> InVec;
				fn not_in_vec(_: Vec<i32>) -> NotInVec;
				fn lt(_: i32) -> Lt;
				fn lte(_: i32) -> Lte;
				fn gt(_: i32) -> Gt;
				fn gte(_: i32) -> Gte;
				fn not(_: i32) -> Not;
			}
		);
		pub struct Order(SortOrder);
		pub fn order<T: From<Order>>(v: SortOrder) -> T {
			Order(v).into()
		}
		impl From<Order> for super::OrderByWithRelationParam {
			fn from(Order(v): Order) -> Self {
				Self::LocationId(v)
			}
		}
		pub struct Set(pub i32);
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub struct UpdateOperation(pub _prisma::write_params::IntParam);
		pub fn increment<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Increment(value)).into()
		}
		pub fn decrement<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Decrement(value)).into()
		}
		pub fn multiply<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Multiply(value)).into()
		}
		pub fn divide<T: From<UpdateOperation>>(value: i32) -> T {
			UpdateOperation(_prisma::write_params::IntParam::Divide(value)).into()
		}
		impl From<Set> for UncheckedSetParam {
			fn from(Set(v): Set) -> Self {
				Self::LocationId(_prisma::write_params::IntParam::Set(v))
			}
		}
		impl From<UpdateOperation> for UncheckedSetParam {
			fn from(UpdateOperation(v): UpdateOperation) -> Self {
				Self::LocationId(v)
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::LocationId(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::LocationId(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::sel(NAME)
			}
		}
	}
	#[derive(Clone)]
	pub struct Create {
		pub location: super::location::UniqueWhereParam,
		pub indexer_rule: super::indexer_rule::UniqueWhereParam,
		pub _params: Vec<SetParam>,
	}
	impl Create {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
			client.indexer_rules_in_location().create(
				self.location,
				self.indexer_rule,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<SetParam> {
			self._params.extend([
				location::connect(self.location),
				indexer_rule::connect(self.indexer_rule),
			]);
			self._params
		}
	}
	pub fn create(
		location: super::location::UniqueWhereParam,
		indexer_rule: super::indexer_rule::UniqueWhereParam,
		_params: Vec<SetParam>,
	) -> Create {
		Create {
			location,
			indexer_rule,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct CreateUnchecked {
		pub location_id: i32,
		pub indexer_rule_id: i32,
		pub _params: Vec<UncheckedSetParam>,
	}
	impl CreateUnchecked {
		pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
			client.indexer_rules_in_location().create_unchecked(
				self.location_id,
				self.indexer_rule_id,
				self._params,
			)
		}
		pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
			self._params.extend([
				location_id::set(self.location_id),
				indexer_rule_id::set(self.indexer_rule_id),
			]);
			self._params
		}
	}
	pub fn create_unchecked(
		location_id: i32,
		indexer_rule_id: i32,
		_params: Vec<UncheckedSetParam>,
	) -> CreateUnchecked {
		CreateUnchecked {
			location_id,
			indexer_rule_id,
			_params,
		}
	}
	#[derive(Clone)]
	pub struct Types;
	impl ::prisma_client_rust::ModelTypes for Types {
		type Data = Data;
		type Where = WhereParam;
		type UncheckedSet = UncheckedSetParam;
		type Set = SetParam;
		type With = WithParam;
		type OrderBy = OrderByWithRelationParam;
		type Cursor = UniqueWhereParam;
		const MODEL: &'static str = NAME;
		fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
			vec![
				::prisma_client_rust::sel(date_created::NAME),
				::prisma_client_rust::sel(location_id::NAME),
				::prisma_client_rust::sel(indexer_rule_id::NAME),
			]
		}
	}
	#[derive(
		Debug,
		Clone,
		:: serde :: Serialize,
		:: serde :: Deserialize,
		:: prisma_client_rust :: specta :: Type,
	)]
	#[specta(
		rename = "IndexerRulesInLocation",
		crate = "prisma_client_rust::specta"
	)]
	pub struct Data {
		#[serde(rename = "date_created")]
		pub date_created:
			::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
		#[serde(rename = "location_id")]
		pub location_id: i32,
		#[serde(rename = "location")]
		#[specta(skip)]
		pub location: Option<Box<super::location::Data>>,
		#[serde(rename = "indexer_rule_id")]
		pub indexer_rule_id: i32,
		#[serde(rename = "indexer_rule")]
		#[specta(skip)]
		pub indexer_rule: Option<Box<super::indexer_rule::Data>>,
	}
	impl Data {
		pub fn location(
			&self,
		) -> Result<&super::location::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.location
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(location),
				))
				.map(|v| v.as_ref())
		}
		pub fn indexer_rule(
			&self,
		) -> Result<&super::indexer_rule::Data, ::prisma_client_rust::RelationNotFetchedError> {
			self.indexer_rule
				.as_ref()
				.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
					stringify!(indexer_rule),
				))
				.map(|v| v.as_ref())
		}
	}
	#[macro_export]
	macro_rules ! _partial_unchecked_indexer_rules_in_location { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: indexer_rules_in_location struct $ struct_name { # [serde (rename = "date_created")] pub date_created : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "location_id")] pub location_id : i32 , # [serde (rename = "indexer_rule_id")] pub indexer_rule_id : i32 } [$ ($ scalar_field) , +] } } ; }
	pub use _partial_unchecked_indexer_rules_in_location as partial_unchecked;
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
	pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
	pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
	pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
	pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
	pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
	pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
	pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
	pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
	pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
	pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
	pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
	pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
	pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
	pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
	#[derive(Clone)]
	pub struct Actions<'a> {
		pub client: &'a ::prisma_client_rust::PrismaClientInternals,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
			FindUniqueQuery::new(self.client, _where.into())
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
			FindFirstQuery::new(self.client, _where)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
			FindManyQuery::new(self.client, _where)
		}
		pub fn create(
			self,
			location: super::location::UniqueWhereParam,
			indexer_rule: super::indexer_rule::UniqueWhereParam,
			mut _params: Vec<SetParam>,
		) -> CreateQuery<'a> {
			_params.extend([
				location::connect(location),
				indexer_rule::connect(indexer_rule),
			]);
			CreateQuery::new(self.client, _params)
		}
		pub fn create_unchecked(
			self,
			location_id: i32,
			indexer_rule_id: i32,
			mut _params: Vec<UncheckedSetParam>,
		) -> CreateUncheckedQuery<'a> {
			_params.extend([
				location_id::set(location_id),
				indexer_rule_id::set(indexer_rule_id),
			]);
			CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
		}
		pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
			let data = data.into_iter().map(CreateUnchecked::to_params).collect();
			CreateManyQuery::new(self.client, data)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
			UpdateQuery::new(self.client, _where.into(), _params, vec![])
		}
		pub fn update_unchecked(
			self,
			_where: UniqueWhereParam,
			_params: Vec<UncheckedSetParam>,
		) -> UpdateUncheckedQuery<'a> {
			UpdateUncheckedQuery::new(
				self.client,
				_where.into(),
				_params.into_iter().map(Into::into).collect(),
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateManyQuery<'a> {
			UpdateManyQuery::new(self.client, _where, _params)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			_create: Create,
			_update: Vec<SetParam>,
		) -> UpsertQuery<'a> {
			UpsertQuery::new(self.client, _where.into(), _create.to_params(), _update)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
			DeleteQuery::new(self.client, _where.into(), vec![])
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
			DeleteManyQuery::new(self.client, _where)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
			CountQuery::new(self.client, _where)
		}
	}
}
pub mod _prisma {
	pub struct PrismaClientBuilder {
		url: Option<String>,
		action_notifier: ::prisma_client_rust::ActionNotifier,
	}
	impl PrismaClientBuilder {
		fn new() -> Self {
			Self {
				url: None,
				action_notifier: ::prisma_client_rust::ActionNotifier::new(),
			}
		}
		pub fn with_url(mut self, url: String) -> Self {
			self.url = Some(url);
			self
		}
		pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
			let internals = ::prisma_client_rust::PrismaClientInternals::new(
				self.url,
				self.action_notifier,
				super::DATAMODEL_STR,
			)
			.await?;
			Ok(PrismaClient(internals))
		}
	}
	pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
	impl ::std::fmt::Debug for PrismaClient {
		fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
			f.debug_struct("PrismaClient").finish()
		}
	}
	impl PrismaClient {
		pub fn _builder() -> PrismaClientBuilder {
			PrismaClientBuilder::new()
		}
		pub fn _query_raw<T: ::prisma_client_rust::Data>(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::QueryRaw<T> {
			::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub fn _execute_raw(
			&self,
			query: ::prisma_client_rust::Raw,
		) -> ::prisma_client_rust::ExecuteRaw {
			::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
		}
		pub async fn _batch<
			'batch,
			T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
			Marker,
		>(
			&self,
			queries: T,
		) -> ::prisma_client_rust::Result<
			<T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
		> {
			::prisma_client_rust::batch(queries, &self.0).await
		}
		pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
			::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
		}
		pub async fn _migrate_deploy(
			&self,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateDeployError> {
			let res = ::prisma_client_rust::migrations::migrate_deploy(
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.0.url(),
			)
			.await;
			::prisma_client_rust::tokio::time::sleep(core::time::Duration::from_millis(1)).await;
			res
		}
		pub async fn _migrate_resolve(
			&self,
			migration: &str,
		) -> Result<(), ::prisma_client_rust::migrations::MigrateResolveError> {
			::prisma_client_rust::migrations::migrate_resolve(
				migration,
				super::DATAMODEL_STR,
				super::MIGRATIONS_DIR,
				&self.0.url(),
			)
			.await
		}
		pub fn _db_push(&self) -> ::prisma_client_rust::migrations::DbPush {
			::prisma_client_rust::migrations::db_push(super::DATAMODEL_STR, &self.0.url())
		}
		pub fn owned_operation(&self) -> super::owned_operation::Actions {
			super::owned_operation::Actions { client: &self.0 }
		}
		pub fn shared_operation(&self) -> super::shared_operation::Actions {
			super::shared_operation::Actions { client: &self.0 }
		}
		pub fn statistics(&self) -> super::statistics::Actions {
			super::statistics::Actions { client: &self.0 }
		}
		pub fn node(&self) -> super::node::Actions {
			super::node::Actions { client: &self.0 }
		}
		pub fn volume(&self) -> super::volume::Actions {
			super::volume::Actions { client: &self.0 }
		}
		pub fn location(&self) -> super::location::Actions {
			super::location::Actions { client: &self.0 }
		}
		pub fn file_path(&self) -> super::file_path::Actions {
			super::file_path::Actions { client: &self.0 }
		}
		pub fn object(&self) -> super::object::Actions {
			super::object::Actions { client: &self.0 }
		}
		pub fn file_conflict(&self) -> super::file_conflict::Actions {
			super::file_conflict::Actions { client: &self.0 }
		}
		pub fn key(&self) -> super::key::Actions {
			super::key::Actions { client: &self.0 }
		}
		pub fn media_data(&self) -> super::media_data::Actions {
			super::media_data::Actions { client: &self.0 }
		}
		pub fn tag(&self) -> super::tag::Actions {
			super::tag::Actions { client: &self.0 }
		}
		pub fn tag_on_object(&self) -> super::tag_on_object::Actions {
			super::tag_on_object::Actions { client: &self.0 }
		}
		pub fn label(&self) -> super::label::Actions {
			super::label::Actions { client: &self.0 }
		}
		pub fn label_on_object(&self) -> super::label_on_object::Actions {
			super::label_on_object::Actions { client: &self.0 }
		}
		pub fn space(&self) -> super::space::Actions {
			super::space::Actions { client: &self.0 }
		}
		pub fn object_in_space(&self) -> super::object_in_space::Actions {
			super::object_in_space::Actions { client: &self.0 }
		}
		pub fn job(&self) -> super::job::Actions {
			super::job::Actions { client: &self.0 }
		}
		pub fn album(&self) -> super::album::Actions {
			super::album::Actions { client: &self.0 }
		}
		pub fn object_in_album(&self) -> super::object_in_album::Actions {
			super::object_in_album::Actions { client: &self.0 }
		}
		pub fn comment(&self) -> super::comment::Actions {
			super::comment::Actions { client: &self.0 }
		}
		pub fn indexer_rule(&self) -> super::indexer_rule::Actions {
			super::indexer_rule::Actions { client: &self.0 }
		}
		pub fn indexer_rules_in_location(&self) -> super::indexer_rules_in_location::Actions {
			super::indexer_rules_in_location::Actions { client: &self.0 }
		}
	}
	impl ::prisma_client_rust::PrismaClient for PrismaClient {
		fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
			&self.0
		}
		fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
			&mut self.0
		}
		fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
			Self(self.0.with_tx_id(tx_id))
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum AlbumScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "is_hidden")]
		IsHidden,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for AlbumScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::IsHidden => "is_hidden".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum CommentScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "content")]
		Content,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
		#[serde(rename = "object_id")]
		ObjectId,
	}
	impl ToString for CommentScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Content => "content".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
				Self::ObjectId => "object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum FileConflictScalarFieldEnum {
		#[serde(rename = "original_object_id")]
		OriginalObjectId,
		#[serde(rename = "detactched_object_id")]
		DetactchedObjectId,
	}
	impl ToString for FileConflictScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::OriginalObjectId => "original_object_id".to_string(),
				Self::DetactchedObjectId => "detactched_object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum FilePathScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "is_dir")]
		IsDir,
		#[serde(rename = "cas_id")]
		CasId,
		#[serde(rename = "integrity_checksum")]
		IntegrityChecksum,
		#[serde(rename = "location_id")]
		LocationId,
		#[serde(rename = "materialized_path")]
		MaterializedPath,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "extension")]
		Extension,
		#[serde(rename = "size_in_bytes")]
		SizeInBytes,
		#[serde(rename = "inode")]
		Inode,
		#[serde(rename = "device")]
		Device,
		#[serde(rename = "object_id")]
		ObjectId,
		#[serde(rename = "key_id")]
		KeyId,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
		#[serde(rename = "date_indexed")]
		DateIndexed,
	}
	impl ToString for FilePathScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::IsDir => "is_dir".to_string(),
				Self::CasId => "cas_id".to_string(),
				Self::IntegrityChecksum => "integrity_checksum".to_string(),
				Self::LocationId => "location_id".to_string(),
				Self::MaterializedPath => "materialized_path".to_string(),
				Self::Name => "name".to_string(),
				Self::Extension => "extension".to_string(),
				Self::SizeInBytes => "size_in_bytes".to_string(),
				Self::Inode => "inode".to_string(),
				Self::Device => "device".to_string(),
				Self::ObjectId => "object_id".to_string(),
				Self::KeyId => "key_id".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
				Self::DateIndexed => "date_indexed".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum IndexerRuleScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "default")]
		Default,
		#[serde(rename = "rules_per_kind")]
		RulesPerKind,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for IndexerRuleScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Name => "name".to_string(),
				Self::Default => "default".to_string(),
				Self::RulesPerKind => "rules_per_kind".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum IndexerRulesInLocationScalarFieldEnum {
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "location_id")]
		LocationId,
		#[serde(rename = "indexer_rule_id")]
		IndexerRuleId,
	}
	impl ToString for IndexerRulesInLocationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::DateCreated => "date_created".to_string(),
				Self::LocationId => "location_id".to_string(),
				Self::IndexerRuleId => "indexer_rule_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum JobScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "node_id")]
		NodeId,
		#[serde(rename = "action")]
		Action,
		#[serde(rename = "status")]
		Status,
		#[serde(rename = "errors_text")]
		ErrorsText,
		#[serde(rename = "data")]
		Data,
		#[serde(rename = "metadata")]
		Metadata,
		#[serde(rename = "parent_id")]
		ParentId,
		#[serde(rename = "task_count")]
		TaskCount,
		#[serde(rename = "completed_task_count")]
		CompletedTaskCount,
		#[serde(rename = "date_estimated_completion")]
		DateEstimatedCompletion,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_started")]
		DateStarted,
		#[serde(rename = "date_completed")]
		DateCompleted,
	}
	impl ToString for JobScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Name => "name".to_string(),
				Self::NodeId => "node_id".to_string(),
				Self::Action => "action".to_string(),
				Self::Status => "status".to_string(),
				Self::ErrorsText => "errors_text".to_string(),
				Self::Data => "data".to_string(),
				Self::Metadata => "metadata".to_string(),
				Self::ParentId => "parent_id".to_string(),
				Self::TaskCount => "task_count".to_string(),
				Self::CompletedTaskCount => "completed_task_count".to_string(),
				Self::DateEstimatedCompletion => "date_estimated_completion".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateStarted => "date_started".to_string(),
				Self::DateCompleted => "date_completed".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum KeyScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "uuid")]
		Uuid,
		#[serde(rename = "version")]
		Version,
		#[serde(rename = "key_type")]
		KeyType,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "default")]
		Default,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "algorithm")]
		Algorithm,
		#[serde(rename = "hashing_algorithm")]
		HashingAlgorithm,
		#[serde(rename = "content_salt")]
		ContentSalt,
		#[serde(rename = "master_key")]
		MasterKey,
		#[serde(rename = "master_key_nonce")]
		MasterKeyNonce,
		#[serde(rename = "key_nonce")]
		KeyNonce,
		#[serde(rename = "key")]
		Key,
		#[serde(rename = "salt")]
		Salt,
		#[serde(rename = "automount")]
		Automount,
	}
	impl ToString for KeyScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Uuid => "uuid".to_string(),
				Self::Version => "version".to_string(),
				Self::KeyType => "key_type".to_string(),
				Self::Name => "name".to_string(),
				Self::Default => "default".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::Algorithm => "algorithm".to_string(),
				Self::HashingAlgorithm => "hashing_algorithm".to_string(),
				Self::ContentSalt => "content_salt".to_string(),
				Self::MasterKey => "master_key".to_string(),
				Self::MasterKeyNonce => "master_key_nonce".to_string(),
				Self::KeyNonce => "key_nonce".to_string(),
				Self::Key => "key".to_string(),
				Self::Salt => "salt".to_string(),
				Self::Automount => "automount".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum LabelOnObjectScalarFieldEnum {
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "label_id")]
		LabelId,
		#[serde(rename = "object_id")]
		ObjectId,
	}
	impl ToString for LabelOnObjectScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::DateCreated => "date_created".to_string(),
				Self::LabelId => "label_id".to_string(),
				Self::ObjectId => "object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum LabelScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for LabelScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum LocationScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "node_id")]
		NodeId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "path")]
		Path,
		#[serde(rename = "total_capacity")]
		TotalCapacity,
		#[serde(rename = "available_capacity")]
		AvailableCapacity,
		#[serde(rename = "is_archived")]
		IsArchived,
		#[serde(rename = "generate_preview_media")]
		GeneratePreviewMedia,
		#[serde(rename = "sync_preview_media")]
		SyncPreviewMedia,
		#[serde(rename = "hidden")]
		Hidden,
		#[serde(rename = "date_created")]
		DateCreated,
	}
	impl ToString for LocationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::NodeId => "node_id".to_string(),
				Self::Name => "name".to_string(),
				Self::Path => "path".to_string(),
				Self::TotalCapacity => "total_capacity".to_string(),
				Self::AvailableCapacity => "available_capacity".to_string(),
				Self::IsArchived => "is_archived".to_string(),
				Self::GeneratePreviewMedia => "generate_preview_media".to_string(),
				Self::SyncPreviewMedia => "sync_preview_media".to_string(),
				Self::Hidden => "hidden".to_string(),
				Self::DateCreated => "date_created".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum MediaDataScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pixel_width")]
		PixelWidth,
		#[serde(rename = "pixel_height")]
		PixelHeight,
		#[serde(rename = "longitude")]
		Longitude,
		#[serde(rename = "latitude")]
		Latitude,
		#[serde(rename = "fps")]
		Fps,
		#[serde(rename = "capture_device_make")]
		CaptureDeviceMake,
		#[serde(rename = "capture_device_model")]
		CaptureDeviceModel,
		#[serde(rename = "capture_device_software")]
		CaptureDeviceSoftware,
		#[serde(rename = "duration_seconds")]
		DurationSeconds,
		#[serde(rename = "codecs")]
		Codecs,
		#[serde(rename = "streams")]
		Streams,
	}
	impl ToString for MediaDataScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PixelWidth => "pixel_width".to_string(),
				Self::PixelHeight => "pixel_height".to_string(),
				Self::Longitude => "longitude".to_string(),
				Self::Latitude => "latitude".to_string(),
				Self::Fps => "fps".to_string(),
				Self::CaptureDeviceMake => "capture_device_make".to_string(),
				Self::CaptureDeviceModel => "capture_device_model".to_string(),
				Self::CaptureDeviceSoftware => "capture_device_software".to_string(),
				Self::DurationSeconds => "duration_seconds".to_string(),
				Self::Codecs => "codecs".to_string(),
				Self::Streams => "streams".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum NodeScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "platform")]
		Platform,
		#[serde(rename = "version")]
		Version,
		#[serde(rename = "last_seen")]
		LastSeen,
		#[serde(rename = "timezone")]
		Timezone,
		#[serde(rename = "date_created")]
		DateCreated,
	}
	impl ToString for NodeScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::Platform => "platform".to_string(),
				Self::Version => "version".to_string(),
				Self::LastSeen => "last_seen".to_string(),
				Self::Timezone => "timezone".to_string(),
				Self::DateCreated => "date_created".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum ObjectInAlbumScalarFieldEnum {
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "album_id")]
		AlbumId,
		#[serde(rename = "object_id")]
		ObjectId,
	}
	impl ToString for ObjectInAlbumScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::DateCreated => "date_created".to_string(),
				Self::AlbumId => "album_id".to_string(),
				Self::ObjectId => "object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum ObjectInSpaceScalarFieldEnum {
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "space_id")]
		SpaceId,
		#[serde(rename = "object_id")]
		ObjectId,
	}
	impl ToString for ObjectInSpaceScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::DateCreated => "date_created".to_string(),
				Self::SpaceId => "space_id".to_string(),
				Self::ObjectId => "object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum ObjectScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "kind")]
		Kind,
		#[serde(rename = "key_id")]
		KeyId,
		#[serde(rename = "hidden")]
		Hidden,
		#[serde(rename = "favorite")]
		Favorite,
		#[serde(rename = "important")]
		Important,
		#[serde(rename = "has_thumbnail")]
		HasThumbnail,
		#[serde(rename = "has_thumbstrip")]
		HasThumbstrip,
		#[serde(rename = "has_video_preview")]
		HasVideoPreview,
		#[serde(rename = "ipfs_id")]
		IpfsId,
		#[serde(rename = "note")]
		Note,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_accessed")]
		DateAccessed,
	}
	impl ToString for ObjectScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Kind => "kind".to_string(),
				Self::KeyId => "key_id".to_string(),
				Self::Hidden => "hidden".to_string(),
				Self::Favorite => "favorite".to_string(),
				Self::Important => "important".to_string(),
				Self::HasThumbnail => "has_thumbnail".to_string(),
				Self::HasThumbstrip => "has_thumbstrip".to_string(),
				Self::HasVideoPreview => "has_video_preview".to_string(),
				Self::IpfsId => "ipfs_id".to_string(),
				Self::Note => "note".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateAccessed => "date_accessed".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum OwnedOperationScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "timestamp")]
		Timestamp,
		#[serde(rename = "data")]
		Data,
		#[serde(rename = "model")]
		Model,
		#[serde(rename = "node_id")]
		NodeId,
	}
	impl ToString for OwnedOperationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Timestamp => "timestamp".to_string(),
				Self::Data => "data".to_string(),
				Self::Model => "model".to_string(),
				Self::NodeId => "node_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum SharedOperationScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "timestamp")]
		Timestamp,
		#[serde(rename = "model")]
		Model,
		#[serde(rename = "record_id")]
		RecordId,
		#[serde(rename = "kind")]
		Kind,
		#[serde(rename = "data")]
		Data,
		#[serde(rename = "node_id")]
		NodeId,
	}
	impl ToString for SharedOperationScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Timestamp => "timestamp".to_string(),
				Self::Model => "model".to_string(),
				Self::RecordId => "record_id".to_string(),
				Self::Kind => "kind".to_string(),
				Self::Data => "data".to_string(),
				Self::NodeId => "node_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum SortOrder {
		#[serde(rename = "asc")]
		Asc,
		#[serde(rename = "desc")]
		Desc,
	}
	impl ToString for SortOrder {
		fn to_string(&self) -> String {
			match self {
				Self::Asc => "asc".to_string(),
				Self::Desc => "desc".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum SpaceScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "description")]
		Description,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for SpaceScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::Description => "description".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum StatisticsScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "date_captured")]
		DateCaptured,
		#[serde(rename = "total_object_count")]
		TotalObjectCount,
		#[serde(rename = "library_db_size")]
		LibraryDbSize,
		#[serde(rename = "total_bytes_used")]
		TotalBytesUsed,
		#[serde(rename = "total_bytes_capacity")]
		TotalBytesCapacity,
		#[serde(rename = "total_unique_bytes")]
		TotalUniqueBytes,
		#[serde(rename = "total_bytes_free")]
		TotalBytesFree,
		#[serde(rename = "preview_media_bytes")]
		PreviewMediaBytes,
	}
	impl ToString for StatisticsScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::DateCaptured => "date_captured".to_string(),
				Self::TotalObjectCount => "total_object_count".to_string(),
				Self::LibraryDbSize => "library_db_size".to_string(),
				Self::TotalBytesUsed => "total_bytes_used".to_string(),
				Self::TotalBytesCapacity => "total_bytes_capacity".to_string(),
				Self::TotalUniqueBytes => "total_unique_bytes".to_string(),
				Self::TotalBytesFree => "total_bytes_free".to_string(),
				Self::PreviewMediaBytes => "preview_media_bytes".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum TagOnObjectScalarFieldEnum {
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "tag_id")]
		TagId,
		#[serde(rename = "object_id")]
		ObjectId,
	}
	impl ToString for TagOnObjectScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::DateCreated => "date_created".to_string(),
				Self::TagId => "tag_id".to_string(),
				Self::ObjectId => "object_id".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum TagScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "pub_id")]
		PubId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "color")]
		Color,
		#[serde(rename = "total_objects")]
		TotalObjects,
		#[serde(rename = "redundancy_goal")]
		RedundancyGoal,
		#[serde(rename = "date_created")]
		DateCreated,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for TagScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::PubId => "pub_id".to_string(),
				Self::Name => "name".to_string(),
				Self::Color => "color".to_string(),
				Self::TotalObjects => "total_objects".to_string(),
				Self::RedundancyGoal => "redundancy_goal".to_string(),
				Self::DateCreated => "date_created".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum TransactionIsolationLevel {
		#[serde(rename = "Serializable")]
		Serializable,
	}
	impl ToString for TransactionIsolationLevel {
		fn to_string(&self) -> String {
			match self {
				Self::Serializable => "Serializable".to_string(),
			}
		}
	}
	impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
	pub enum VolumeScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "node_id")]
		NodeId,
		#[serde(rename = "name")]
		Name,
		#[serde(rename = "mount_point")]
		MountPoint,
		#[serde(rename = "total_bytes_capacity")]
		TotalBytesCapacity,
		#[serde(rename = "total_bytes_available")]
		TotalBytesAvailable,
		#[serde(rename = "disk_type")]
		DiskType,
		#[serde(rename = "filesystem")]
		Filesystem,
		#[serde(rename = "is_system")]
		IsSystem,
		#[serde(rename = "date_modified")]
		DateModified,
	}
	impl ToString for VolumeScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::NodeId => "node_id".to_string(),
				Self::Name => "name".to_string(),
				Self::MountPoint => "mount_point".to_string(),
				Self::TotalBytesCapacity => "total_bytes_capacity".to_string(),
				Self::TotalBytesAvailable => "total_bytes_available".to_string(),
				Self::DiskType => "disk_type".to_string(),
				Self::Filesystem => "filesystem".to_string(),
				Self::IsSystem => "is_system".to_string(),
				Self::DateModified => "date_modified".to_string(),
			}
		}
	}
	impl Into<::prisma_client_rust::PrismaValue> for SortOrder {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				SortOrder::Asc => ::prisma_client_rust::PrismaValue::String("asc".to_string()),
				SortOrder::Desc => ::prisma_client_rust::PrismaValue::String("desc".to_string()),
			}
		}
	}
	pub mod read_filters {
		#[derive(Clone)]
		pub enum FloatNullableFilter {
			Equals(Option<f64>),
			InVec(Vec<f64>),
			NotInVec(Vec<f64>),
			Lt(f64),
			Lte(f64),
			Gt(f64),
			Gte(f64),
			Not(Option<f64>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for FloatNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) }
			}
		}
		#[derive(Clone)]
		pub enum StringFilter {
			Equals(String),
			InVec(Vec<String>),
			NotInVec(Vec<String>),
			Lt(String),
			Lte(String),
			Gt(String),
			Gte(String),
			Contains(String),
			StartsWith(String),
			EndsWith(String),
			Not(String),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::String(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::String(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Contains(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"contains".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::StartsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"startsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::EndsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"endsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum StringNullableFilter {
			Equals(Option<String>),
			InVec(Vec<String>),
			NotInVec(Vec<String>),
			Lt(String),
			Lte(String),
			Gt(String),
			Gte(String),
			Contains(String),
			StartsWith(String),
			EndsWith(String),
			Not(Option<String>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							value
								.map(|value| ::prisma_client_rust::PrismaValue::String(value))
								.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::String(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::String(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
					Self::Contains(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"contains".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::StartsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"startsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::EndsWith(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"endsWith".to_string(),
							::prisma_client_rust::PrismaValue::String(value),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum BooleanFilter {
			Equals(bool),
			Not(bool),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BooleanFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::Boolean(value),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Boolean(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum DateTimeFilter {
			Equals(
				::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
			),
			InVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			NotInVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::DateTime(value),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum DateTimeNullableFilter {
			Equals(
				Option<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			InVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			NotInVec(
				Vec<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
			Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
			Not(
				Option<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							value
								.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
								.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::DateTime(value),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
							.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum BigIntFilter {
			Equals(i64),
			InVec(Vec<i64>),
			NotInVec(Vec<i64>),
			Lt(i64),
			Lte(i64),
			Gt(i64),
			Gte(i64),
			Not(i64),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::BigInt(value),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum BytesFilter {
			Equals(Vec<u8>),
			InVec(Vec<Vec<u8>>),
			NotInVec(Vec<Vec<u8>>),
			Not(Vec<u8>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BytesFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::Bytes(value),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
									.collect(),
							),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Bytes(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum BytesNullableFilter {
			Equals(Option<Vec<u8>>),
			InVec(Vec<Vec<u8>>),
			NotInVec(Vec<Vec<u8>>),
			Not(Option<Vec<u8>>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for BytesNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							value
								.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
								.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
									.collect(),
							),
						)])
					}
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
							.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum IntFilter {
			Equals(i32),
			InVec(Vec<i32>),
			NotInVec(Vec<i32>),
			Lt(i32),
			Lte(i32),
			Gt(i32),
			Gte(i32),
			Not(i32),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							::prisma_client_rust::PrismaValue::Int(value as i64),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| {
										::prisma_client_rust::PrismaValue::Int(value as i64)
									})
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| {
										::prisma_client_rust::PrismaValue::Int(value as i64)
									})
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum IntNullableFilter {
			Equals(Option<i32>),
			InVec(Vec<i32>),
			NotInVec(Vec<i32>),
			Lt(i32),
			Lte(i32),
			Gt(i32),
			Gte(i32),
			Not(Option<i32>),
		}
		impl Into<::prisma_client_rust::SerializedWhereValue> for IntNullableFilter {
			fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
				match self {
					Self::Equals(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"equals".to_string(),
							value
								.map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
								.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
						)])
					}
					Self::InVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"in".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| {
										::prisma_client_rust::PrismaValue::Int(value as i64)
									})
									.collect(),
							),
						)])
					}
					Self::NotInVec(value) => {
						::prisma_client_rust::SerializedWhereValue::Object(vec![(
							"notIn".to_string(),
							::prisma_client_rust::PrismaValue::List(
								value
									.into_iter()
									.map(|value| {
										::prisma_client_rust::PrismaValue::Int(value as i64)
									})
									.collect(),
							),
						)])
					}
					Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						value
							.map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
							.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					)]),
				}
			}
		}
	}
	pub mod write_params {
		#[derive(Clone)]
		pub enum FloatNullableParam {
			Set(Option<f64>),
			Increment(f64),
			Decrement(f64),
			Multiply(f64),
			Divide(f64),
		}
		impl Into<::prisma_client_rust::PrismaValue> for FloatNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self { Self :: Set (value) => value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ())) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null) , Self :: Increment (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Decrement (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Multiply (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) , Self :: Divide (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (< :: prisma_client_rust :: bigdecimal :: BigDecimal as :: prisma_client_rust :: bigdecimal :: FromPrimitive > :: from_f64 (value) . unwrap () . normalized ()))]) }
			}
		}
		#[derive(Clone)]
		pub enum StringParam {
			Set(String),
		}
		impl Into<::prisma_client_rust::PrismaValue> for StringParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::String(value),
				}
			}
		}
		#[derive(Clone)]
		pub enum StringNullableParam {
			Set(Option<String>),
		}
		impl Into<::prisma_client_rust::PrismaValue> for StringNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				}
			}
		}
		#[derive(Clone)]
		pub enum BooleanParam {
			Set(bool),
		}
		impl Into<::prisma_client_rust::PrismaValue> for BooleanParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::Boolean(value),
				}
			}
		}
		#[derive(Clone)]
		pub enum DateTimeParam {
			Set(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
		}
		impl Into<::prisma_client_rust::PrismaValue> for DateTimeParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::DateTime(value),
				}
			}
		}
		#[derive(Clone)]
		pub enum DateTimeNullableParam {
			Set(
				Option<
					::prisma_client_rust::chrono::DateTime<
						::prisma_client_rust::chrono::FixedOffset,
					>,
				>,
			),
		}
		impl Into<::prisma_client_rust::PrismaValue> for DateTimeNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => value
						.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				}
			}
		}
		#[derive(Clone)]
		pub enum BigIntParam {
			Set(i64),
			Increment(i64),
			Decrement(i64),
			Multiply(i64),
			Divide(i64),
		}
		impl Into<::prisma_client_rust::PrismaValue> for BigIntParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::BigInt(value),
					Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
					Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::BigInt(value),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum BytesParam {
			Set(Vec<u8>),
		}
		impl Into<::prisma_client_rust::PrismaValue> for BytesParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::Bytes(value),
				}
			}
		}
		#[derive(Clone)]
		pub enum BytesNullableParam {
			Set(Option<Vec<u8>>),
		}
		impl Into<::prisma_client_rust::PrismaValue> for BytesNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => value
						.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				}
			}
		}
		#[derive(Clone)]
		pub enum IntParam {
			Set(i32),
			Increment(i32),
			Decrement(i32),
			Multiply(i32),
			Divide(i32),
		}
		impl Into<::prisma_client_rust::PrismaValue> for IntParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => ::prisma_client_rust::PrismaValue::Int(value as i64),
					Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				}
			}
		}
		#[derive(Clone)]
		pub enum IntNullableParam {
			Set(Option<i32>),
			Increment(i32),
			Decrement(i32),
			Multiply(i32),
			Divide(i32),
		}
		impl Into<::prisma_client_rust::PrismaValue> for IntNullableParam {
			fn into(self) -> ::prisma_client_rust::PrismaValue {
				match self {
					Self::Set(value) => value
						.map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
					Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
					Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				}
			}
		}
	}
}
pub use _prisma::*;
