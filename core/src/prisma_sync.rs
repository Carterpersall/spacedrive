// Code generated by SD Sync Generator. DO NOT EDIT

use crate::prisma;
pub enum ModelSyncData {
	Location(location::SyncId, sd_sync::SharedOperationData),
	FilePath(file_path::SyncId, sd_sync::SharedOperationData),
	Object(object::SyncId, sd_sync::SharedOperationData),
	Key(key::SyncId, sd_sync::SharedOperationData),
	Tag(tag::SyncId, sd_sync::SharedOperationData),
	Album(album::SyncId, sd_sync::SharedOperationData),
}
impl ModelSyncData {
	pub fn from_op(op: sd_sync::CRDTOperationType) -> Option<Self> {
		Some(match op {
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::location::NAME => {
				Self::Location(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::file_path::NAME => {
				Self::FilePath(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::object::NAME => {
				Self::Object(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::key::NAME => {
				Self::Key(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::tag::NAME => {
				Self::Tag(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			sd_sync::CRDTOperationType::Shared(op) if op.model == prisma::album::NAME => {
				Self::Album(serde_json::from_value(op.record_id).ok()?, op.data)
			}
			_ => return None,
		})
	}
}
pub mod owned_operation {
	use super::prisma::*;
	impl owned_operation::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				owned_operation::id::NAME => {
					owned_operation::id::set(::serde_json::from_value(val).unwrap())
				}
				owned_operation::timestamp::NAME => {
					owned_operation::timestamp::set(::serde_json::from_value(val).unwrap())
				}
				owned_operation::data::NAME => {
					owned_operation::data::set(::serde_json::from_value(val).unwrap())
				}
				owned_operation::model::NAME => {
					owned_operation::model::set(::serde_json::from_value(val).unwrap())
				}
				owned_operation::node::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					owned_operation::node::connect(
						node::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
	impl owned_operation::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				owned_operation::id::NAME => {
					owned_operation::id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod shared_operation {
	use super::prisma::*;
	impl shared_operation::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				shared_operation::id::NAME => {
					shared_operation::id::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::timestamp::NAME => {
					shared_operation::timestamp::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::model::NAME => {
					shared_operation::model::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::record_id::NAME => {
					shared_operation::record_id::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::kind::NAME => {
					shared_operation::kind::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::data::NAME => {
					shared_operation::data::set(::serde_json::from_value(val).unwrap())
				}
				shared_operation::node::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					shared_operation::node::connect(
						node::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
	impl shared_operation::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				shared_operation::id::NAME => {
					shared_operation::id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod statistics {
	use super::prisma::*;
	impl statistics::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				statistics::id::NAME => statistics::id::set(::serde_json::from_value(val).unwrap()),
				statistics::date_captured::NAME => {
					statistics::date_captured::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_object_count::NAME => {
					statistics::total_object_count::set(::serde_json::from_value(val).unwrap())
				}
				statistics::library_db_size::NAME => {
					statistics::library_db_size::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_bytes_used::NAME => {
					statistics::total_bytes_used::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_bytes_capacity::NAME => {
					statistics::total_bytes_capacity::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_unique_bytes::NAME => {
					statistics::total_unique_bytes::set(::serde_json::from_value(val).unwrap())
				}
				statistics::total_bytes_free::NAME => {
					statistics::total_bytes_free::set(::serde_json::from_value(val).unwrap())
				}
				statistics::preview_media_bytes::NAME => {
					statistics::preview_media_bytes::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl statistics::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				statistics::id::NAME => {
					statistics::id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod node {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = node::Types;
	}
	impl sd_sync::SyncType for node::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::LocalSyncType;
	}
	impl node::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				node::id::NAME => node::id::set(::serde_json::from_value(val).unwrap()),
				node::pub_id::NAME => node::pub_id::set(::serde_json::from_value(val).unwrap()),
				node::name::NAME => node::name::set(::serde_json::from_value(val).unwrap()),
				node::platform::NAME => node::platform::set(::serde_json::from_value(val).unwrap()),
				node::version::NAME => node::version::set(::serde_json::from_value(val).unwrap()),
				node::last_seen::NAME => {
					node::last_seen::set(::serde_json::from_value(val).unwrap())
				}
				node::timezone::NAME => node::timezone::set(::serde_json::from_value(val).unwrap()),
				node::date_created::NAME => {
					node::date_created::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl node::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				node::id::NAME => node::id::equals(::serde_json::from_value(val).unwrap()),
				node::pub_id::NAME => node::pub_id::equals(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
}
pub mod volume {
	use super::prisma::*;
	impl volume::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				volume::id::NAME => volume::id::set(::serde_json::from_value(val).unwrap()),
				volume::node_id::NAME => {
					volume::node_id::set(::serde_json::from_value(val).unwrap())
				}
				volume::name::NAME => volume::name::set(::serde_json::from_value(val).unwrap()),
				volume::mount_point::NAME => {
					volume::mount_point::set(::serde_json::from_value(val).unwrap())
				}
				volume::total_bytes_capacity::NAME => {
					volume::total_bytes_capacity::set(::serde_json::from_value(val).unwrap())
				}
				volume::total_bytes_available::NAME => {
					volume::total_bytes_available::set(::serde_json::from_value(val).unwrap())
				}
				volume::disk_type::NAME => {
					volume::disk_type::set(::serde_json::from_value(val).unwrap())
				}
				volume::filesystem::NAME => {
					volume::filesystem::set(::serde_json::from_value(val).unwrap())
				}
				volume::is_system::NAME => {
					volume::is_system::set(::serde_json::from_value(val).unwrap())
				}
				volume::date_modified::NAME => {
					volume::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl volume::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				volume::id::NAME => volume::id::equals(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
}
pub mod location {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = location::Types;
	}
	impl sd_sync::SyncType for location::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl location::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				location::id::NAME => location::id::set(::serde_json::from_value(val).unwrap()),
				location::pub_id::NAME => {
					location::pub_id::set(::serde_json::from_value(val).unwrap())
				}
				location::name::NAME => location::name::set(::serde_json::from_value(val).unwrap()),
				location::path::NAME => location::path::set(::serde_json::from_value(val).unwrap()),
				location::total_capacity::NAME => {
					location::total_capacity::set(::serde_json::from_value(val).unwrap())
				}
				location::available_capacity::NAME => {
					location::available_capacity::set(::serde_json::from_value(val).unwrap())
				}
				location::is_archived::NAME => {
					location::is_archived::set(::serde_json::from_value(val).unwrap())
				}
				location::generate_preview_media::NAME => {
					location::generate_preview_media::set(::serde_json::from_value(val).unwrap())
				}
				location::sync_preview_media::NAME => {
					location::sync_preview_media::set(::serde_json::from_value(val).unwrap())
				}
				location::hidden::NAME => {
					location::hidden::set(::serde_json::from_value(val).unwrap())
				}
				location::date_created::NAME => {
					location::date_created::set(::serde_json::from_value(val).unwrap())
				}
				location::node::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					location::node::connect(
						node::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
	impl location::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				location::id::NAME => location::id::equals(::serde_json::from_value(val).unwrap()),
				location::pub_id::NAME => {
					location::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod file_path {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = file_path::Types;
	}
	impl sd_sync::SyncType for file_path::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl file_path::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				file_path::id::NAME => file_path::id::set(::serde_json::from_value(val).unwrap()),
				file_path::pub_id::NAME => {
					file_path::pub_id::set(::serde_json::from_value(val).unwrap())
				}
				file_path::is_dir::NAME => {
					file_path::is_dir::set(::serde_json::from_value(val).unwrap())
				}
				file_path::cas_id::NAME => {
					file_path::cas_id::set(::serde_json::from_value(val).unwrap())
				}
				file_path::integrity_checksum::NAME => {
					file_path::integrity_checksum::set(::serde_json::from_value(val).unwrap())
				}
				file_path::location::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					file_path::location::connect(
						location::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				file_path::materialized_path::NAME => {
					file_path::materialized_path::set(::serde_json::from_value(val).unwrap())
				}
				file_path::name::NAME => {
					file_path::name::set(::serde_json::from_value(val).unwrap())
				}
				file_path::extension::NAME => {
					file_path::extension::set(::serde_json::from_value(val).unwrap())
				}
				file_path::size_in_bytes::NAME => {
					file_path::size_in_bytes::set(::serde_json::from_value(val).unwrap())
				}
				file_path::inode::NAME => {
					file_path::inode::set(::serde_json::from_value(val).unwrap())
				}
				file_path::device::NAME => {
					file_path::device::set(::serde_json::from_value(val).unwrap())
				}
				file_path::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					file_path::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				file_path::date_created::NAME => {
					file_path::date_created::set(::serde_json::from_value(val).unwrap())
				}
				file_path::date_modified::NAME => {
					file_path::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				file_path::date_indexed::NAME => {
					file_path::date_indexed::set(::serde_json::from_value(val).unwrap())
				}
				file_path::key::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					file_path::key::connect(
						key::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
	impl file_path::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				file_path::id::NAME => {
					file_path::id::equals(::serde_json::from_value(val).unwrap())
				}
				file_path::pub_id::NAME => {
					file_path::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				file_path::integrity_checksum::NAME => {
					file_path::integrity_checksum::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod object {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = object::Types;
	}
	impl sd_sync::SyncType for object::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl object::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				object::id::NAME => object::id::set(::serde_json::from_value(val).unwrap()),
				object::pub_id::NAME => object::pub_id::set(::serde_json::from_value(val).unwrap()),
				object::kind::NAME => object::kind::set(::serde_json::from_value(val).unwrap()),
				object::hidden::NAME => object::hidden::set(::serde_json::from_value(val).unwrap()),
				object::favorite::NAME => {
					object::favorite::set(::serde_json::from_value(val).unwrap())
				}
				object::important::NAME => {
					object::important::set(::serde_json::from_value(val).unwrap())
				}
				object::has_thumbnail::NAME => {
					object::has_thumbnail::set(::serde_json::from_value(val).unwrap())
				}
				object::has_thumbstrip::NAME => {
					object::has_thumbstrip::set(::serde_json::from_value(val).unwrap())
				}
				object::has_video_preview::NAME => {
					object::has_video_preview::set(::serde_json::from_value(val).unwrap())
				}
				object::ipfs_id::NAME => {
					object::ipfs_id::set(::serde_json::from_value(val).unwrap())
				}
				object::note::NAME => object::note::set(::serde_json::from_value(val).unwrap()),
				object::date_created::NAME => {
					object::date_created::set(::serde_json::from_value(val).unwrap())
				}
				object::date_accessed::NAME => {
					object::date_accessed::set(::serde_json::from_value(val).unwrap())
				}
				object::key::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					object::key::connect(key::UniqueWhereParam::deserialize(&val.0, val.1).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl object::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				object::id::NAME => object::id::equals(::serde_json::from_value(val).unwrap()),
				object::pub_id::NAME => {
					object::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod file_conflict {
	use super::prisma::*;
	impl file_conflict::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				file_conflict::original_object_id::NAME => {
					file_conflict::original_object_id::set(::serde_json::from_value(val).unwrap())
				}
				file_conflict::detactched_object_id::NAME => {
					file_conflict::detactched_object_id::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl file_conflict::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				file_conflict::original_object_id::NAME => {
					file_conflict::original_object_id::equals(
						::serde_json::from_value(val).unwrap(),
					)
				}
				file_conflict::detactched_object_id::NAME => {
					file_conflict::detactched_object_id::equals(
						::serde_json::from_value(val).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
pub mod key {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub uuid: String,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = key::Types;
	}
	impl sd_sync::SyncType for key::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl key::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				key::id::NAME => key::id::set(::serde_json::from_value(val).unwrap()),
				key::uuid::NAME => key::uuid::set(::serde_json::from_value(val).unwrap()),
				key::version::NAME => key::version::set(::serde_json::from_value(val).unwrap()),
				key::key_type::NAME => key::key_type::set(::serde_json::from_value(val).unwrap()),
				key::name::NAME => key::name::set(::serde_json::from_value(val).unwrap()),
				key::default::NAME => key::default::set(::serde_json::from_value(val).unwrap()),
				key::date_created::NAME => {
					key::date_created::set(::serde_json::from_value(val).unwrap())
				}
				key::algorithm::NAME => key::algorithm::set(::serde_json::from_value(val).unwrap()),
				key::hashing_algorithm::NAME => {
					key::hashing_algorithm::set(::serde_json::from_value(val).unwrap())
				}
				key::content_salt::NAME => {
					key::content_salt::set(::serde_json::from_value(val).unwrap())
				}
				key::master_key::NAME => {
					key::master_key::set(::serde_json::from_value(val).unwrap())
				}
				key::master_key_nonce::NAME => {
					key::master_key_nonce::set(::serde_json::from_value(val).unwrap())
				}
				key::key_nonce::NAME => key::key_nonce::set(::serde_json::from_value(val).unwrap()),
				key::key::NAME => key::key::set(::serde_json::from_value(val).unwrap()),
				key::salt::NAME => key::salt::set(::serde_json::from_value(val).unwrap()),
				key::automount::NAME => key::automount::set(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
	impl key::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				key::id::NAME => key::id::equals(::serde_json::from_value(val).unwrap()),
				key::uuid::NAME => key::uuid::equals(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
}
pub mod media_data {
	use super::prisma::*;
	impl media_data::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				media_data::pixel_width::NAME => {
					media_data::pixel_width::set(::serde_json::from_value(val).unwrap())
				}
				media_data::pixel_height::NAME => {
					media_data::pixel_height::set(::serde_json::from_value(val).unwrap())
				}
				media_data::longitude::NAME => {
					media_data::longitude::set(::serde_json::from_value(val).unwrap())
				}
				media_data::latitude::NAME => {
					media_data::latitude::set(::serde_json::from_value(val).unwrap())
				}
				media_data::fps::NAME => {
					media_data::fps::set(::serde_json::from_value(val).unwrap())
				}
				media_data::capture_device_make::NAME => {
					media_data::capture_device_make::set(::serde_json::from_value(val).unwrap())
				}
				media_data::capture_device_model::NAME => {
					media_data::capture_device_model::set(::serde_json::from_value(val).unwrap())
				}
				media_data::capture_device_software::NAME => {
					media_data::capture_device_software::set(::serde_json::from_value(val).unwrap())
				}
				media_data::duration_seconds::NAME => {
					media_data::duration_seconds::set(::serde_json::from_value(val).unwrap())
				}
				media_data::codecs::NAME => {
					media_data::codecs::set(::serde_json::from_value(val).unwrap())
				}
				media_data::streams::NAME => {
					media_data::streams::set(::serde_json::from_value(val).unwrap())
				}
				media_data::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					media_data::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
	impl media_data::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				media_data::id::NAME => {
					media_data::id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod tag {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = tag::Types;
	}
	impl sd_sync::SyncType for tag::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl tag::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				tag::id::NAME => tag::id::set(::serde_json::from_value(val).unwrap()),
				tag::pub_id::NAME => tag::pub_id::set(::serde_json::from_value(val).unwrap()),
				tag::name::NAME => tag::name::set(::serde_json::from_value(val).unwrap()),
				tag::color::NAME => tag::color::set(::serde_json::from_value(val).unwrap()),
				tag::total_objects::NAME => {
					tag::total_objects::set(::serde_json::from_value(val).unwrap())
				}
				tag::redundancy_goal::NAME => {
					tag::redundancy_goal::set(::serde_json::from_value(val).unwrap())
				}
				tag::date_created::NAME => {
					tag::date_created::set(::serde_json::from_value(val).unwrap())
				}
				tag::date_modified::NAME => {
					tag::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl tag::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				tag::id::NAME => tag::id::equals(::serde_json::from_value(val).unwrap()),
				tag::pub_id::NAME => tag::pub_id::equals(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
}
pub mod tag_on_object {
	use super::prisma::*;
	impl tag_on_object::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				tag_on_object::date_created::NAME => {
					tag_on_object::date_created::set(::serde_json::from_value(val).unwrap())
				}
				tag_on_object::tag::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					tag_on_object::tag::connect(
						tag::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				tag_on_object::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					tag_on_object::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
pub mod label {
	use super::prisma::*;
	impl label::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				label::id::NAME => label::id::set(::serde_json::from_value(val).unwrap()),
				label::pub_id::NAME => label::pub_id::set(::serde_json::from_value(val).unwrap()),
				label::name::NAME => label::name::set(::serde_json::from_value(val).unwrap()),
				label::date_created::NAME => {
					label::date_created::set(::serde_json::from_value(val).unwrap())
				}
				label::date_modified::NAME => {
					label::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl label::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				label::id::NAME => label::id::equals(::serde_json::from_value(val).unwrap()),
				label::pub_id::NAME => {
					label::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod label_on_object {
	use super::prisma::*;
	impl label_on_object::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				label_on_object::date_created::NAME => {
					label_on_object::date_created::set(::serde_json::from_value(val).unwrap())
				}
				label_on_object::label::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					label_on_object::label::connect(
						label::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				label_on_object::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					label_on_object::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
pub mod space {
	use super::prisma::*;
	impl space::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				space::id::NAME => space::id::set(::serde_json::from_value(val).unwrap()),
				space::pub_id::NAME => space::pub_id::set(::serde_json::from_value(val).unwrap()),
				space::name::NAME => space::name::set(::serde_json::from_value(val).unwrap()),
				space::description::NAME => {
					space::description::set(::serde_json::from_value(val).unwrap())
				}
				space::date_created::NAME => {
					space::date_created::set(::serde_json::from_value(val).unwrap())
				}
				space::date_modified::NAME => {
					space::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl space::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				space::id::NAME => space::id::equals(::serde_json::from_value(val).unwrap()),
				space::pub_id::NAME => {
					space::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod object_in_space {
	use super::prisma::*;
	impl object_in_space::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				object_in_space::date_created::NAME => {
					object_in_space::date_created::set(::serde_json::from_value(val).unwrap())
				}
				object_in_space::space::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					object_in_space::space::connect(
						space::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				object_in_space::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					object_in_space::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
pub mod job {
	use super::prisma::*;
	impl job::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				job::id::NAME => job::id::set(::serde_json::from_value(val).unwrap()),
				job::name::NAME => job::name::set(::serde_json::from_value(val).unwrap()),
				job::action::NAME => job::action::set(::serde_json::from_value(val).unwrap()),
				job::status::NAME => job::status::set(::serde_json::from_value(val).unwrap()),
				job::errors_text::NAME => {
					job::errors_text::set(::serde_json::from_value(val).unwrap())
				}
				job::data::NAME => job::data::set(::serde_json::from_value(val).unwrap()),
				job::metadata::NAME => job::metadata::set(::serde_json::from_value(val).unwrap()),
				job::task_count::NAME => {
					job::task_count::set(::serde_json::from_value(val).unwrap())
				}
				job::completed_task_count::NAME => {
					job::completed_task_count::set(::serde_json::from_value(val).unwrap())
				}
				job::date_estimated_completion::NAME => {
					job::date_estimated_completion::set(::serde_json::from_value(val).unwrap())
				}
				job::date_created::NAME => {
					job::date_created::set(::serde_json::from_value(val).unwrap())
				}
				job::date_started::NAME => {
					job::date_started::set(::serde_json::from_value(val).unwrap())
				}
				job::date_completed::NAME => {
					job::date_completed::set(::serde_json::from_value(val).unwrap())
				}
				job::nodes::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					job::nodes::connect(node::UniqueWhereParam::deserialize(&val.0, val.1).unwrap())
				}
				job::parent::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					job::parent::connect(job::UniqueWhereParam::deserialize(&val.0, val.1).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl job::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				job::id::NAME => job::id::equals(::serde_json::from_value(val).unwrap()),
				_ => return None,
			})
		}
	}
}
pub mod album {
	use super::prisma::*;
	#[derive(serde :: Serialize, serde :: Deserialize)]
	pub struct SyncId {
		pub pub_id: Vec<u8>,
	}
	impl sd_sync::SyncId for SyncId {
		type ModelTypes = album::Types;
	}
	impl sd_sync::SyncType for album::Types {
		type SyncId = SyncId;
		type Marker = sd_sync::SharedSyncType;
	}
	impl album::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				album::id::NAME => album::id::set(::serde_json::from_value(val).unwrap()),
				album::pub_id::NAME => album::pub_id::set(::serde_json::from_value(val).unwrap()),
				album::name::NAME => album::name::set(::serde_json::from_value(val).unwrap()),
				album::is_hidden::NAME => {
					album::is_hidden::set(::serde_json::from_value(val).unwrap())
				}
				album::date_created::NAME => {
					album::date_created::set(::serde_json::from_value(val).unwrap())
				}
				album::date_modified::NAME => {
					album::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl album::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				album::id::NAME => album::id::equals(::serde_json::from_value(val).unwrap()),
				album::pub_id::NAME => {
					album::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod object_in_album {
	use super::prisma::*;
	impl object_in_album::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				object_in_album::date_created::NAME => {
					object_in_album::date_created::set(::serde_json::from_value(val).unwrap())
				}
				object_in_album::album::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					object_in_album::album::connect(
						album::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				object_in_album::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					object_in_album::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
pub mod comment {
	use super::prisma::*;
	impl comment::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				comment::id::NAME => comment::id::set(::serde_json::from_value(val).unwrap()),
				comment::pub_id::NAME => {
					comment::pub_id::set(::serde_json::from_value(val).unwrap())
				}
				comment::content::NAME => {
					comment::content::set(::serde_json::from_value(val).unwrap())
				}
				comment::date_created::NAME => {
					comment::date_created::set(::serde_json::from_value(val).unwrap())
				}
				comment::date_modified::NAME => {
					comment::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				comment::object::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					comment::object::connect(
						object::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
	impl comment::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				comment::id::NAME => comment::id::equals(::serde_json::from_value(val).unwrap()),
				comment::pub_id::NAME => {
					comment::pub_id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod indexer_rule {
	use super::prisma::*;
	impl indexer_rule::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				indexer_rule::id::NAME => {
					indexer_rule::id::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::name::NAME => {
					indexer_rule::name::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::default::NAME => {
					indexer_rule::default::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::rules_per_kind::NAME => {
					indexer_rule::rules_per_kind::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::date_created::NAME => {
					indexer_rule::date_created::set(::serde_json::from_value(val).unwrap())
				}
				indexer_rule::date_modified::NAME => {
					indexer_rule::date_modified::set(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
	impl indexer_rule::UniqueWhereParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				indexer_rule::id::NAME => {
					indexer_rule::id::equals(::serde_json::from_value(val).unwrap())
				}
				_ => return None,
			})
		}
	}
}
pub mod indexer_rules_in_location {
	use super::prisma::*;
	impl indexer_rules_in_location::SetParam {
		pub fn deserialize(field: &str, val: ::serde_json::Value) -> Option<Self> {
			Some(match field {
				indexer_rules_in_location::date_created::NAME => {
					indexer_rules_in_location::date_created::set(
						::serde_json::from_value(val).unwrap(),
					)
				}
				indexer_rules_in_location::location::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					indexer_rules_in_location::location::connect(
						location::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				indexer_rules_in_location::indexer_rule::NAME => {
					let val: std::collections::HashMap<String, ::serde_json::Value> =
						::serde_json::from_value(val).unwrap();
					let val = val.into_iter().next().unwrap();
					indexer_rules_in_location::indexer_rule::connect(
						indexer_rule::UniqueWhereParam::deserialize(&val.0, val.1).unwrap(),
					)
				}
				_ => return None,
			})
		}
	}
}
